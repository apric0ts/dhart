/*!
	\file		pathfinder_C_cinterface.cpp
	\brief		Unit test source file for testing pathfinder functionality (C Interface)

	\author		TBA
	\date		12 Aug 2020
*/

#include "gtest/gtest.h"

#include "pathfinder_C.h"
#include "spatialstructures_C.h"	// Required for AlgorithmCostTitle

#include "path.h"					// Required for HF::SpatialStructures::Path, HF::SpatialStructures::PathMember
#include "node.h"					// Required for HF::SpatialStructures::Node
#include "graph.h"					// Required for HF::SpatialStructures::Graph
#include "path_finder.h"			// Required for HF::Pathfinding::CreateBoostGraph
#include "cost_algorithms.h"		// Required for CalculateEnergyExpenditure

namespace CInterfaceTests {
	TEST(_pathfinder_cinterface, CreatePath) {

	}

	TEST(_pathfinder_cinterface, CreatePaths) {

	}

	TEST(_pathfinder_cinterface, GetPathInfo) {

	}

	TEST(_pathfinder_cinterface, DestroyPath) {

	}

	TEST(_pathfinder_cinterface, CreateAllToAllPaths) {

	}

	TEST(_pathfinder_cinterface, CalculateDistanceAndPredecessor) {

	}

	TEST(C_Pathfinder, CreatePath) {
		// Requires #include "pathfinder_C.h", #include "graph.h", #include "path.h", #include "path_finder.h"

		// Create a Graph g, and compress it.
		HF::SpatialStructures::Graph g;
		g.addEdge(0, 1, 1);
		g.addEdge(0, 2, 2);
		g.addEdge(1, 3, 3);
		g.addEdge(2, 4, 1);
		g.addEdge(3, 4, 5);
		g.Compress();

		// Create a boostGraph from g
		auto boostGraph = HF::Pathfinding::CreateBoostGraph(g);

		// Prepare parameters for CreatePath
		HF::SpatialStructures::Path* out_path = nullptr;
		HF::SpatialStructures::PathMember* out_path_member = nullptr;
		int out_size = -1;

		CreatePath(&g, 0, 4, "\0", &out_size, &out_path, &out_path_member);

		// Use out_path, out_path_member

		// Remember to free resources when finished
		DestroyPath(out_path);

		// At this point, out_path_member has also been destroyed, so we set this to nullptr
		out_path_member = nullptr;
	}

	TEST(C_Pathfinder, CreatePaths) {
		// Requires #include "pathfinder_C.h", #include "graph.h", #include "path.h", #include "path_finder.h"

		HF::SpatialStructures::Graph g;
		g.addEdge(0, 1, 1);
		g.addEdge(0, 2, 2);
		g.addEdge(1, 3, 3);
		g.addEdge(2, 4, 1);
		g.addEdge(3, 4, 5);
		g.Compress();

		// Maximum amount of paths to search
		const int MAX_SIZE = 2;

		// Create a Graph g, and compress it
		auto boostGraph = HF::Pathfinding::CreateBoostGraph(g);

		// We want to find the shortest paths from 0 to 3, and 0 to 4.
		int start_nodes[] = { 0, 0 };
		int end_nodes[] = { 3, 4 };

		// Create dynamically-allocated arrays of pointers to Path
		// Create dynamically-allocated arrays of pointers to PathMember		
		HF::SpatialStructures::Path** out_path = new HF::SpatialStructures::Path * [MAX_SIZE];
		HF::SpatialStructures::PathMember** out_path_member = new HF::SpatialStructures::PathMember * [MAX_SIZE];

		// Sizes of paths generated by CreatePaths. Sizes of 0 mean that a path was unable to be generated.
		int* out_sizes = new int[MAX_SIZE];

		// Use CreatePaths
		CreatePaths(&g, start_nodes, end_nodes, "\0", out_path, out_path_member, out_sizes, MAX_SIZE);

		///
		/// Resource cleanup
		///

		for (int i = 0; i < MAX_SIZE; i++) {
			if (out_path[i]) {
				// Release memory for all pointers in out_path
				DestroyPath(out_path[i]);
				out_path[i] = nullptr;
			}
		}

		if (out_path) {
			// Release memory for pointer to out_path buffer
			delete[MAX_SIZE] out_path;
			out_path = nullptr;
		}

		if (out_path_member) {
			// Release memory for pointers to out_path_member buffer
			delete[MAX_SIZE] out_path_member;
			out_path_member = nullptr;
		}

		if (out_sizes) {
			// Release memory for pointer to out_sizes buffer
			delete[MAX_SIZE] out_sizes;
			out_sizes = nullptr;
		}
	}

	TEST(C_Pathfinder, CreatePathCostType) {
		// be sure to #include "boost_graph.h", #include "node.h", #include "graph.h", and #include <vector>

		// for brevity
		using HF::SpatialStructures::Node;
		using HF::SpatialStructures::Graph;
		using HF::Pathfinding::BoostGraph;
		using HF::SpatialStructures::CostAlgorithms::CalculateEnergyExpenditure;

		// Create the nodes
		Node node_0(1.0f, 1.0f, 2.0f);
		Node node_1(2.0f, 3.0f, 4.0f);
		Node node_2(11.0f, 22.0f, 140.0f);
		Node node_3(62.9f, 39.1f, 18.0f);
		Node node_4(19.5f, 27.1f, 29.9f);

		// Create a graph. No nodes/edges for now.
		Graph graph;

		// Add edges. These will have the default edge values, forming the default graph.
		graph.addEdge(node_0, node_1, 1);
		graph.addEdge(node_0, node_2, 2.5);
		graph.addEdge(node_1, node_3, 54.0);
		graph.addEdge(node_2, node_4, 39.0);
		graph.addEdge(node_3, node_4, 1.2);

		// Always compress the graph after adding edges!
		graph.Compress();

		// Retrieve a Subgraph, parent node ID 0 -- of alternate edge costs.
		// Add these alternate edges to graph.
		std::string desired_cost_type = AlgorithmCostTitle(COST_ALG_KEY::CROSS_SLOPE);
		auto edge_set = CalculateEnergyExpenditure(graph.GetSubgraph(0));
		graph.AddEdges(edge_set, desired_cost_type);

		// Prepare parameters for CreatePath
		HF::SpatialStructures::Path* out_path = nullptr;
		HF::SpatialStructures::PathMember* out_path_member = nullptr;
		int out_size = -1;

		// Use CreatePathCostType, be sure to use the .c_str() method if using a std::string for desired_cost_type
		CreatePath(&graph, 0, 4, desired_cost_type.c_str(), &out_size, &out_path, &out_path_member);

		///
		/// Use out_path, out_path_member
		///

		// Remember to free resources when finished
		DestroyPath(out_path);

		// At this point, out_path_member has also been destroyed, so we set this to nullptr
		out_path_member = nullptr;
	}

	TEST(C_Pathfinder, CreatePathsCostType) {
		// Requires #include "pathfinder_C.h", #include "graph.h", #include "path.h", #include "path_finder.h"

		// for brevity
		using HF::SpatialStructures::Node;
		using HF::SpatialStructures::Graph;
		using HF::Pathfinding::BoostGraph;
		using HF::SpatialStructures::CostAlgorithms::CalculateEnergyExpenditure;

		// Create the nodes
		Node node_0(1.0f, 1.0f, 2.0f);
		Node node_1(2.0f, 3.0f, 4.0f);
		Node node_2(11.0f, 22.0f, 14.0f);
		Node node_3(62.9f, 39.1f, 18.0f);
		Node node_4(99.5f, 47.1f, 29.9f);

		// Create a graph. No nodes/edges for now.
		Graph graph;

		// Add edges. These will have the default edge values, forming the default graph.
		graph.addEdge(node_0, node_1, 1);
		graph.addEdge(node_0, node_2, 2.5);
		graph.addEdge(node_1, node_3, 54.0);
		graph.addEdge(node_2, node_4, 39.0);
		graph.addEdge(node_3, node_4, 1.2);

		// Always compress the graph after adding edges!
		graph.Compress();

		// Retrieve a Subgraph, parent node ID 0 -- of alternate edge costs.
		// Add these alternate edges to graph.
		std::string desired_cost_type = AlgorithmCostTitle(COST_ALG_KEY::CROSS_SLOPE);
		auto edge_set = CalculateEnergyExpenditure(graph);
		graph.AddEdges(edge_set, desired_cost_type);

		// Maximum amount of paths to search
		const int MAX_SIZE = 2;

		// We want to find the shortest paths from 0 to 3, and 0 to 4.
		int start_nodes[] = { 0, 0 };
		int end_nodes[] = { 3, 4 };

		// Create dynamically-allocated arrays of pointers to Path
		// Create dynamically-allocated arrays of pointers to PathMember		
		HF::SpatialStructures::Path** out_path = new HF::SpatialStructures::Path * [MAX_SIZE];
		HF::SpatialStructures::PathMember** out_path_member = new HF::SpatialStructures::PathMember * [MAX_SIZE];

		// Sizes of paths generated by CreatePaths. Sizes of 0 mean that a path was unable to be generated.
		int* out_sizes = new int[MAX_SIZE];

		// Use CreatePathsCostType, be sure to use the .c_str() method if using a std::string for desired_cost_type
		CreatePaths(&graph, start_nodes, end_nodes, desired_cost_type.c_str(), out_path, out_path_member, out_sizes, MAX_SIZE);

		///
		/// Use out_path, out_path_member
		///

		///
		/// Resource cleanup
		///

		for (int i = 0; i < MAX_SIZE; i++) {
			if (out_path[i]) {
				// Release memory for all pointers in out_path
				DestroyPath(out_path[i]);
				out_path[i] = nullptr;
			}
		}

		if (out_path) {
			// Release memory for pointer to out_path buffer
			delete[MAX_SIZE] out_path;
			out_path = nullptr;
		}

		if (out_path_member) {
			// Release memory for pointers to out_path_member buffer
			delete[MAX_SIZE] out_path_member;
			out_path_member = nullptr;
		}

		if (out_sizes) {
			// Release memory for pointer to out_sizes buffer
			delete[MAX_SIZE] out_sizes;
			out_sizes = nullptr;
		}
	}

	TEST(C_Pathfinder, GetPathInfo) {
		// Requires #include "pathfinder_C.h", #include "path.h"

		// Requires #include "pathfinder_C.h", #include "graph.h", #include "path.h", #include "path_finder.h"

		// Create a Graph g, and compress it.
		HF::SpatialStructures::Graph g;
		g.addEdge(0, 1, 1);
		g.addEdge(0, 2, 2);
		g.addEdge(1, 3, 3);
		g.addEdge(2, 4, 1);
		g.addEdge(3, 4, 5);
		g.Compress();

		// Create a boostGraph from g
		auto boostGraph = HF::Pathfinding::CreateBoostGraph(g);

		HF::SpatialStructures::Path* out_path = nullptr;
		HF::SpatialStructures::PathMember* out_path_member = nullptr;
		int out_size = -1;

		CreatePath(&g, 0, 4, "\0", &out_size, &out_path, &out_path_member);

		// Get out_path's info, store results in out_path_member and out_size
		GetPathInfo(out_path, &out_path_member, &out_size);

		// Remember to free resources when finished
		DestroyPath(out_path);

		// At this point, out_path_member has also been destroyed, so we set this to nullptr
		out_path_member = nullptr;
	}

	TEST(C_Pathfinder, DestroyPath) {
		// Requires #include "pathfinder_C.h", #include "graph.h", #include "path.h", #include "path_finder.h"

		// Create a Graph g, and compress it.
		HF::SpatialStructures::Graph g;
		g.addEdge(0, 1, 1);
		g.addEdge(0, 2, 2);
		g.addEdge(1, 3, 3);
		g.addEdge(2, 4, 1);
		g.addEdge(3, 4, 5);
		g.Compress();

		// Create a boostGraph from g
		auto boostGraph = HF::Pathfinding::CreateBoostGraph(g);

		HF::SpatialStructures::Path* out_path = nullptr;
		HF::SpatialStructures::PathMember* out_path_member = nullptr;
		int out_size = -1;

		CreatePath(&g, 0, 4, "\0", &out_size, &out_path, &out_path_member);

		// Use out_path, out_path_member

		// Remember to free resources when finished
		DestroyPath(out_path);

		// At this point, out_path_member has also been destroyed, so we set this to nullptr
		out_path_member = nullptr;
	}

	TEST(C_Pathfinder, CreateAllToAllPaths) {
		HF::SpatialStructures::Graph g;

		// Add the edges
		g.addEdge(0, 1, 1);
		g.addEdge(0, 2, 2);
		g.addEdge(1, 3, 3);
		g.addEdge(1, 4, 4);
		g.addEdge(2, 4, 4);
		g.addEdge(3, 5, 5);
		g.addEdge(4, 6, 3);
		g.addEdge(5, 6, 1);

		// Always compress the graph after adding edges
		g.Compress();

		// Create a BoostGraph (std::unique_ptr)
		auto bg = HF::Pathfinding::CreateBoostGraph(g);

		// Total paths is node_count ^ 2
		size_t node_count = g.Nodes().size();
		size_t path_count = node_count * node_count;

		// Pointer to buffer of (Path *)
		HF::SpatialStructures::Path** out_paths = new HF::SpatialStructures::Path * [path_count];
		// out_paths[i...path_count - 1] will be alloc'ed by InsertPathsIntoArray

		// Pointer to buffer of (PathMember *)
		HF::SpatialStructures::PathMember** out_path_member = new HF::SpatialStructures::PathMember * [path_count];
		// out_path_member[i...path_count - 1] points to out_paths[i...path_count - 1]->GetPMPointer();

		// Pointer to buffer of (int)
		int* sizes = new int[path_count];

		//
		// The two loops for start_points and end_points
		// are just for the output.
		//
		int curr_id = 0;
		std::vector<int> start_points(path_count);
		// Populate the start points,
		// size will be (node_count)^2
		for (int i = 0; i < node_count; i++) {
			for (int k = 0; k < node_count; k++) {
				start_points[curr_id++] = i;
			}
		}

		curr_id = 0;

		std::vector<int> end_points(path_count);
		// Populate the end points,
		// size will be (node_count)^2
		for (int i = 0; i < node_count; i++) {
			for (int k = 0; k < node_count; k++) {
				end_points[curr_id++] = k;
			}
		}

		CreateAllToAllPaths(&g, "", out_paths, out_path_member, sizes, path_count);

		for (int i = 0; i < path_count; i++) {
			if (out_paths[i]) {
				// Always check if out_paths[i] is nonnull!
				int total_cost = 0;
				std::cout << "Path from " << start_points[i] << " to " << end_points[i] << std::endl;

				HF::SpatialStructures::Path p = *out_paths[i];
				for (auto m : p.members) {
					total_cost += m.cost;
					std::cout << "node ID: " << m.node << "\tcost " << m.cost << std::endl;
				}

				std::cout << "Total cost: " << total_cost << std::endl;
				std::cout << "--------------------------" << std::endl;
			}
		}

		//
		// Resource cleanup
		//
		if (sizes) {
			delete[] sizes;
			sizes = nullptr;
		}

		if (out_path_member) {
			delete[] out_path_member;
			out_path_member = nullptr;
		}

		if (out_paths) {
			for (int i = 0; i < path_count; i++) {
				if (out_paths[i]) {
					delete out_paths[i];
					out_paths[i] = nullptr;
				}
			}
			delete[] out_paths;
		}
	}
}
