using HumanFactors.Exceptions;
using HumanFactors.NativeUtils;
using HumanFactors.NativeUtils.CommonNativeArrays;
using HumanFactors.SpatialStructures;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Dynamic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;

/*! 
    \brief Calculate the shortest path between Points in a graph.

    \see ShortestPath for a list of pathfinding functions.
    \see Path for information on the fundamental path datatype. 

    \see SpatialStructures.Graph for information about the graph itself
    \see GraphGenerator to automatically generate a graph of accessible space on a mesh.

*/
namespace HumanFactors.Pathfinding
{

    /*!
        \brief Functions for finding the shortest path between two nodes in a graph.

        \see ShortestPath for generating a single path between two nodes.
        \see DijkstraShortestPath for generating multiple paths at once. 
    */
    public static class ShortestPath{

        /*!
            \brief Perform Dijkstra's shortest path algorithm to find a path between two nodes.
            
            \param graph The graph to conduct the search on.
            \param start_id The ID of the node to start at.
            \param end_id The ID of the node to find a path to. 
            
            \returns A path from <paramref name="start_id" /> to <paramref name="end_id" />  
            
            \throws IndexOutOfRangeException <paramref name="start_id" /> or <paramref name="end_id" /> are not the ids of
            any nodes in the graph.

            \see DijkstraShortestPathMulti for efficently generating multiple paths in parallel.
        */
        public static Path DijkstraShortestPath(Graph graph, int start_id, int end_id)
        {
            CVectorAndData cvad = NativeMethods.C_CreatePath(graph.Pointer, start_id, end_id);
            if (cvad.size <= 0)
                return null;
            else
                return new Path(cvad);
        }

        /*!
            \brief Perform Dijkstra's shortest path algorithm to find a path between two nodes.
            
            \param graph The graph to conduct the search on.
            \param start_node The X,Y,Z of a node in the graph node to start at.
            \param end_node The X,Y,Z of a node in the graph node to end at.
            
            \returns A path from start_node to end_node.
            
            \throws IndexOutOfRangeException start_node or end_node don't exist in the graph.

            \remarks Gets the start id and end of both nodes, then calls the ID overload. 

            \see DijkstraShortestPathMulti for efficently generating multiple paths in parallel.
        */
        public static Path DijkstraShortestPath(Graph graph, Vector3D start_node, Vector3D end_node)
        {
            int parent_id = graph.GetNodeID(start_node);
            int child_id = graph.GetNodeID(end_node);

            return DijkstraShortestPath(graph, parent_id, child_id);
        }

        /*! 
            \brief Find the shortest paths between each pair of start_id and end_id in order. 
            
            \param Graph The graph to generate paths in.
            \param start_ids Ids for the start points to generate paths from. 
            \param end_ids Ids for the end points to generate paths to
            
            \returns
            A list of paths in order from start_ids to end_ids. If a path could not be generated by a set of points,
            then the path at that location will be null. 

            \details Uses all available cores for parallel calculation. 

            \pre The length of start_ids must match the length of end_ids.

            \throws System.ArgumentException Length of start_ids didn't equal length of end_ids
            \throws IndexOutOfRangeException One or more of the start or end ids do not exist in <paramref name="graph" />.
        */
        public static Path[] DijkstraShortestPathMulti(Graph graph, int[] start_ids, int[] end_ids)
        {
            if (start_ids.Length != end_ids.Length) 
                throw new ArgumentException("Length of start_ids didn't equal length of end_ids");

            CVectorAndData[] cvads = NativeMethods.C_CreatePaths(graph.Pointer, start_ids, end_ids);
            Path[] paths = new Path[start_ids.Length];
            for(int i = 0; i < cvads.Length; i++)
            {
                if (cvads[i].IsValid())
                    paths[i] = new Path(cvads[i]);
                else
                    paths[i] = null;
            }

            return paths;
        }

        /*! 
            \brief Find the shortest paths between each pair of start_id and end_id in order. 
            
            \param Graph The graph to generate paths in.
            \param start_nodes Locations of the start points to generate paths from.
            \param end_ids Locations of the end nodes to generate paths to.
            
            \returns
            A list of paths in order from start_ids to end_ids. If a path could not be generated by a set of points,
            then the path at that location will be null. 

            \details Determines the IDs of nodes, then calls the other overload. Uses all available cores for parallel calculation. 

            \pre 1) The length of start_ids must match the length of end_ids.
            \pre 2) Each node in start_nodes and end_nodes must contain the x,y,z position of an existing node in graph

            \throws System.ArgumentException Length of start_ids didn't equal length of end_ids
            \throws IndexOutOfRangeException One or more of the start or end ids do not exist in <paramref name="graph" />.
        */
        public static Path[] DijkstraShortestPathMulti(Graph graph, IEnumerable<Vector3D> start_nodes, IEnumerable<Vector3D> end_nodes)
        {
            if (start_nodes.Count() != end_nodes.Count())
                throw new ArgumentException("Length of start_nodes didn't equal length of end_nodes");

            int size = start_nodes.Count();
            int[] start_ids = new int[size];
            int[] end_ids = new int[size];

            int i = 0;
            foreach (var start_end in start_nodes.Zip(end_nodes, (start, end) => new Tuple<Vector3D, Vector3D>(start, end)))
            {
                start_ids[i] = graph.GetNodeID(start_end.Item1);
                end_ids[i] = graph.GetNodeID(start_end.Item2);
                i++;
            }

            return DijkstraShortestPathMulti(graph, start_ids, end_ids);
        }

    }
}