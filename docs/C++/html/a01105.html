<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Analysis: HF::GraphGenerator::GraphGeneratorPrivate Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00275.html">HF</a></li><li class="navelem"><a class="el" href="a00276.html">GraphGenerator</a></li><li class="navelem"><a class="el" href="a01105.html">GraphGeneratorPrivate</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="a01102.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HF::GraphGenerator::GraphGeneratorPrivate Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains the private implementation of the <a class="el" href="a01101.html" title="Generate a graph of accessible space from a given start point.">GraphGenerator</a> to insulate the clients from the implementation.  
 <a href="a01105.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00014_source.html">graph_generator_private.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a665e92cd93b734ce8d901b679bbd57ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a665e92cd93b734ce8d901b679bbd57ea">GraphGeneratorPrivate</a> (<a class="el" href="a01101.html">GraphGenerator</a> &amp;<a class="el" href="a01105.html#a821adb5a1c656772091a8998cb1d3c7b">GG</a>)</td></tr>
<tr class="memdesc:a665e92cd93b734ce8d901b679bbd57ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graphgeneratorprivate with the settings of GG.  <a href="a01105.html#a665e92cd93b734ce8d901b679bbd57ea">More...</a><br /></td></tr>
<tr class="separator:a665e92cd93b734ce8d901b679bbd57ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eb6c332523a1c5b89d542a87c7ea23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01189.html">HF::SpatialStructures::Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a47eb6c332523a1c5b89d542a87c7ea23">BuildNetwork</a> ()</td></tr>
<tr class="memdesc:a47eb6c332523a1c5b89d542a87c7ea23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conduct a breadth first search of traversable space.  <a href="a01105.html#a47eb6c332523a1c5b89d542a87c7ea23">More...</a><br /></td></tr>
<tr class="separator:a47eb6c332523a1c5b89d542a87c7ea23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7b257d8db4110e76d249e81810ca1084"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a7b257d8db4110e76d249e81810ca1084">WalkableCheck</a> (const <a class="el" href="a01193.html">SpatialStructures::Node</a> &amp;position)</td></tr>
<tr class="memdesc:a7b257d8db4110e76d249e81810ca1084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is above a valid floor.  <a href="a01105.html#a7b257d8db4110e76d249e81810ca1084">More...</a><br /></td></tr>
<tr class="separator:a7b257d8db4110e76d249e81810ca1084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50db86451d7ae5569daa8463e10247ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a50db86451d7ae5569daa8463e10247ec">CheckStart</a> (<a class="el" href="a00276.html#a8c29578574c275e66fbd439be62c125e">v3</a> &amp;start)</td></tr>
<tr class="memdesc:a50db86451d7ae5569daa8463e10247ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push point to the ground if there is ground beneath it.  <a href="a01105.html#a50db86451d7ae5569daa8463e10247ec">More...</a><br /></td></tr>
<tr class="separator:a50db86451d7ae5569daa8463e10247ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551344f5e893380e34b7719b66d560f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a551344f5e893380e34b7719b66d560f1">GeneratePotentialChildren</a> (const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;parent, const std::vector&lt; <a class="el" href="a00011.html#a3394fa820b983014dcac29faca0e4f19">std::pair</a>&lt; int, int &gt;&gt; &amp;directions, std::vector&lt; <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &gt; &amp;out_children)</td></tr>
<tr class="memdesc:a551344f5e893380e34b7719b66d560f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate out_children with a potential child position for every direction in directions.  <a href="a01105.html#a551344f5e893380e34b7719b66d560f1">More...</a><br /></td></tr>
<tr class="separator:a551344f5e893380e34b7719b66d560f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7944155fef41ad8b6ae2c4258444aab1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a7944155fef41ad8b6ae2c4258444aab1">CrawlGeom</a> (<a class="el" href="a01109.html">UniqueQueue</a> &amp;todo)</td></tr>
<tr class="memdesc:a7944155fef41ad8b6ae2c4258444aab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin breadth first search to populate the graph with with nodes and edges.  <a href="a01105.html#a7944155fef41ad8b6ae2c4258444aab1">More...</a><br /></td></tr>
<tr class="separator:a7944155fef41ad8b6ae2c4258444aab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050d3cb17b0ea8c32625cf83ffe0d48d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a050d3cb17b0ea8c32625cf83ffe0d48d">CrawlGeomParallel</a> (<a class="el" href="a01109.html">UniqueQueue</a> &amp;todo)</td></tr>
<tr class="memdesc:a050d3cb17b0ea8c32625cf83ffe0d48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel version of CrawlGeom.  <a href="a01105.html#a050d3cb17b0ea8c32625cf83ffe0d48d">More...</a><br /></td></tr>
<tr class="separator:a050d3cb17b0ea8c32625cf83ffe0d48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bda9a1954db74dd7754c975da304e22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a5bda9a1954db74dd7754c975da304e22">ComputerParent</a> (const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;parent, const std::vector&lt; <a class="el" href="a00011.html#a3394fa820b983014dcac29faca0e4f19">std::pair</a>&lt; int, int &gt;&gt; &amp;directions, std::vector&lt; <a class="el" href="a01173.html">HF::SpatialStructures::Edge</a> &gt; &amp;out_relations)</td></tr>
<tr class="memdesc:a5bda9a1954db74dd7754c975da304e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate edges and children for parent in relations.  <a href="a01105.html#a5bda9a1954db74dd7754c975da304e22">More...</a><br /></td></tr>
<tr class="separator:a5bda9a1954db74dd7754c975da304e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec2599ce52947670024890df33f85e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a4ec2599ce52947670024890df33f85e9">CheckRay</a> (<a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;position, const <a class="el" href="a00276.html#a8c29578574c275e66fbd439be62c125e">v3</a> &amp;direction, <a class="el" href="a00276.html#a6180d5bc4bbfa9a5a426089e1f1ad598">HIT_FLAG</a> flag=HIT_FLAG::BOTH)</td></tr>
<tr class="memdesc:a4ec2599ce52947670024890df33f85e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a ray and overwrite position with the result.  <a href="a01105.html#a4ec2599ce52947670024890df33f85e9">More...</a><br /></td></tr>
<tr class="separator:a4ec2599ce52947670024890df33f85e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08636a123b62c95e1a3c438f84f2e06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#ac08636a123b62c95e1a3c438f84f2e06">CheckRay</a> (<a class="el" href="a00276.html#a8c29578574c275e66fbd439be62c125e">v3</a> &amp;position, const <a class="el" href="a00276.html#a8c29578574c275e66fbd439be62c125e">v3</a> &amp;direction, <a class="el" href="a00276.html#a6180d5bc4bbfa9a5a426089e1f1ad598">HIT_FLAG</a> flag=HIT_FLAG::BOTH)</td></tr>
<tr class="memdesc:ac08636a123b62c95e1a3c438f84f2e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a ray and overwrite position with the point of intersection.  <a href="a01105.html#ac08636a123b62c95e1a3c438f84f2e06">More...</a><br /></td></tr>
<tr class="separator:ac08636a123b62c95e1a3c438f84f2e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3a1c33e1b452f3938a2cc7da4d6d26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#acd3a1c33e1b452f3938a2cc7da4d6d26">OcclusionCheck</a> (const <a class="el" href="a01193.html">SpatialStructures::Node</a> &amp;parent, const <a class="el" href="a01193.html">SpatialStructures::Node</a> &amp;child)</td></tr>
<tr class="memdesc:acd3a1c33e1b452f3938a2cc7da4d6d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is an obstruction between parent and child.  <a href="a01105.html#acd3a1c33e1b452f3938a2cc7da4d6d26">More...</a><br /></td></tr>
<tr class="separator:acd3a1c33e1b452f3938a2cc7da4d6d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac869aa5099472e5ad240c98ee92637a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#ac869aa5099472e5ad240c98ee92637a4">isUpSlope</a> (const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;n1, const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;n2)</td></tr>
<tr class="memdesc:ac869aa5099472e5ad240c98ee92637a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph can traverse the slope from n1 to n2.  <a href="a01105.html#ac869aa5099472e5ad240c98ee92637a4">More...</a><br /></td></tr>
<tr class="separator:ac869aa5099472e5ad240c98ee92637a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acd7efa04ae228a721cef631a38af28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a2acd7efa04ae228a721cef631a38af28">GetChildren</a> (const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;parent, const std::vector&lt; <a class="el" href="a01193.html">SpatialStructures::Node</a> &gt; &amp;possible_children, std::vector&lt; <a class="el" href="a01173.html">HF::SpatialStructures::Edge</a> &gt; &amp;out_children)</td></tr>
<tr class="memdesc:a2acd7efa04ae228a721cef631a38af28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create all possible edges from parent to possible_children.  <a href="a01105.html#a2acd7efa04ae228a721cef631a38af28">More...</a><br /></td></tr>
<tr class="separator:a2acd7efa04ae228a721cef631a38af28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aa18d3ae2ef2082ab56ca9061d16ee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a29aa18d3ae2ef2082ab56ca9061d16ee">CheckChildren</a> (const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;parent, std::vector&lt; <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &gt; Children)</td></tr>
<tr class="memdesc:a29aa18d3ae2ef2082ab56ca9061d16ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset all children to the ground, then check if traversing from parent would require a step outside of step height limits.  <a href="a01105.html#a29aa18d3ae2ef2082ab56ca9061d16ee">More...</a><br /></td></tr>
<tr class="separator:a29aa18d3ae2ef2082ab56ca9061d16ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf12e73a371c75c3c3d0ca8d0082c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00278.html#af0378d900074d484ba791d4317e5935e">HF::SpatialStructures::STEP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#addf12e73a371c75c3c3d0ca8d0082c8f">CheckConnection</a> (const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;parent, const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;child)</td></tr>
<tr class="memdesc:addf12e73a371c75c3c3d0ca8d0082c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if parent can traverse to child. <br  />
  <a href="a01105.html#addf12e73a371c75c3c3d0ca8d0082c8f">More...</a><br /></td></tr>
<tr class="separator:addf12e73a371c75c3c3d0ca8d0082c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a556e9b9bdd1a6244d4c7d42a5ec9d81f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01189.html">HF::SpatialStructures::Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a556e9b9bdd1a6244d4c7d42a5ec9d81f">G</a></td></tr>
<tr class="memdesc:a556e9b9bdd1a6244d4c7d42a5ec9d81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal graph that is iterated upon as the program is executed.  <a href="a01105.html#a556e9b9bdd1a6244d4c7d42a5ec9d81f">More...</a><br /></td></tr>
<tr class="separator:a556e9b9bdd1a6244d4c7d42a5ec9d81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821adb5a1c656772091a8998cb1d3c7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01101.html">HF::GraphGenerator::GraphGenerator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html#a821adb5a1c656772091a8998cb1d3c7b">GG</a></td></tr>
<tr class="memdesc:a821adb5a1c656772091a8998cb1d3c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying graph generator to hold all the settings.  <a href="a01105.html#a821adb5a1c656772091a8998cb1d3c7b">More...</a><br /></td></tr>
<tr class="separator:a821adb5a1c656772091a8998cb1d3c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains the private implementation of the <a class="el" href="a01101.html" title="Generate a graph of accessible space from a given start point.">GraphGenerator</a> to insulate the clients from the implementation. </p>
<dl class="todo"><dt><b><a class="el" href="a00266.html#_todo000003">Todo:</a></b></dt><dd>Combine this with the graphgenerator public and create a single class. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00014_source.html#l00022">22</a> of file <a class="el" href="a00014_source.html">graph_generator_private.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a665e92cd93b734ce8d901b679bbd57ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665e92cd93b734ce8d901b679bbd57ea">&#9670;&nbsp;</a></span>GraphGeneratorPrivate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HF::GraphGenerator::GraphGeneratorPrivate::GraphGeneratorPrivate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01101.html">GraphGenerator</a> &amp;&#160;</td>
          <td class="paramname"><em>GG</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a graphgeneratorprivate with the settings of GG. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GG</td><td><a class="el" href="a01101.html" title="Generate a graph of accessible space from a given start point.">GraphGenerator</a> containing settings to use when BuildNetwork is called. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00064">64</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a47eb6c332523a1c5b89d542a87c7ea23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47eb6c332523a1c5b89d542a87c7ea23">&#9670;&nbsp;</a></span>BuildNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01189.html">Graph</a> HF::GraphGenerator::GraphGeneratorPrivate::BuildNetwork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conduct a breadth first search of traversable space. </p>
<dl class="section return"><dt>Returns</dt><dd>The Graph generated using the settings from GG. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01101.html#a0044b9075921c7510b047f9076ad0a5e" title="Generate a Graph of accessible space.">GraphGenerator::BuildNetwork</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00067">67</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00011_source.html#l00100">CheckStart()</a>, <a class="el" href="a00008_source.html#l00075">HF::GraphGenerator::GraphGenerator::core_count</a>, <a class="el" href="a00011_source.html#l00251">CrawlGeom()</a>, <a class="el" href="a00011_source.html#l00296">CrawlGeomParallel()</a>, <a class="el" href="a00014_source.html#l00025">G</a>, <a class="el" href="a00014_source.html#l00026">GG</a>, <a class="el" href="a00017_source.html#l00011">HF::GraphGenerator::UniqueQueue::push()</a>, <a class="el" href="a00137_source.html#l00013">HF::SpatialStructures::roundhf()</a>, and <a class="el" href="a00008_source.html#l00078">HF::GraphGenerator::GraphGenerator::start</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00005_source.html#l00020">HF::GraphGenerator::GraphGenerator::BuildNetwork()</a>.</p>

</div>
</div>
<a id="a29aa18d3ae2ef2082ab56ca9061d16ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29aa18d3ae2ef2082ab56ca9061d16ee">&#9670;&nbsp;</a></span>CheckChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="a01193.html">Node</a> &gt; HF::GraphGenerator::GraphGeneratorPrivate::CheckChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &gt;&#160;</td>
          <td class="paramname"><em>Children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset all children to the ground, then check if traversing from parent would require a step outside of step height limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of all children in children. </td></tr>
    <tr><td class="paramname">children</td><td>Child nodes to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All children that are above a valid floor and can be traversed to by parent without requiring a step outside of step height limits. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00266.html#_todo000009">Todo:</a></b></dt><dd>Why is Children not const? </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00170">170</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00011_source.html#l00411">CheckRay()</a>, <a class="el" href="a00011_source.html#l00027">HF::GraphGenerator::down</a>, <a class="el" href="a00008_source.html#l00080">HF::GraphGenerator::GraphGenerator::downstep</a>, <a class="el" href="a00014_source.html#l00026">GG</a>, and <a class="el" href="a00008_source.html#l00083">HF::GraphGenerator::GraphGenerator::upstep</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00152">GetChildren()</a>.</p>

</div>
</div>
<a id="addf12e73a371c75c3c3d0ca8d0082c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf12e73a371c75c3c3d0ca8d0082c8f">&#9670;&nbsp;</a></span>CheckConnection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00278.html#af0378d900074d484ba791d4317e5935e">STEP</a> HF::GraphGenerator::GraphGeneratorPrivate::CheckConnection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if parent can traverse to child. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of child. </td></tr>
    <tr><td class="paramname">child</td><td>Child generated from parent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of STEP from parent to child.</dd></dl>
<p>Specifically, this function checks for a direct line of sight. If the line of sight check succeeds, then it checks to see if the slope between parent and child is within the defined limits. If not, then it will offset the child node upward by upstep if it's higher than the parent, or downward by downstep if it's lower than parent and try the occlusion check again.</p>
<dl class="section see"><dt>See also</dt><dd>STEP for details on each type of step. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00189">189</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00146_source.html#l00019">HF::SpatialStructures::DOWN</a>, <a class="el" href="a00008_source.html#l00080">HF::GraphGenerator::GraphGenerator::downstep</a>, <a class="el" href="a00014_source.html#l00026">GG</a>, <a class="el" href="a00011_source.html#l00139">isUpSlope()</a>, <a class="el" href="a00146_source.html#l00017">HF::SpatialStructures::NONE</a>, <a class="el" href="a00146_source.html#l00016">HF::SpatialStructures::NOT_CONNECTED</a>, <a class="el" href="a00011_source.html#l00122">OcclusionCheck()</a>, <a class="el" href="a00146_source.html#l00020">HF::SpatialStructures::OVER</a>, <a class="el" href="a00146_source.html#l00018">HF::SpatialStructures::UP</a>, and <a class="el" href="a00008_source.html#l00083">HF::GraphGenerator::GraphGenerator::upstep</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00152">GetChildren()</a>.</p>

</div>
</div>
<a id="a4ec2599ce52947670024890df33f85e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec2599ce52947670024890df33f85e9">&#9670;&nbsp;</a></span>CheckRay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::GraphGenerator::GraphGeneratorPrivate::CheckRay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00276.html#a8c29578574c275e66fbd439be62c125e">v3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00276.html#a6180d5bc4bbfa9a5a426089e1f1ad598">HIT_FLAG</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code>HIT_FLAG::BOTH</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a ray and overwrite position with the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Node to use as the origin. On Hit, this node's position will be overridden </td></tr>
    <tr><td class="paramname">direction</td><td>Direction to fire the ray in </td></tr>
    <tr><td class="paramname">flag</td><td>The type of geometry to intersect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the ray intersected any geometry. False otherwise. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If true is returned, position contains the point where the casted ray intersected geometry. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00411">411</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00008_source.html#l00039">HF::GraphGenerator::BOTH</a>, <a class="el" href="a00119_source.html#l00163">HF::RayTracer::EmbreeRayTracer::FireRay()</a>, <a class="el" href="a00008_source.html#l00035">HF::GraphGenerator::FLOORS</a>, <a class="el" href="a00014_source.html#l00026">GG</a>, <a class="el" href="a00008_source.html#l00037">HF::GraphGenerator::OBSTACLES</a>, <a class="el" href="a00008_source.html#l00076">HF::GraphGenerator::GraphGenerator::ray_tracer</a>, and <a class="el" href="a00008_source.html#l00073">HF::GraphGenerator::GraphGenerator::walkable_surfaces</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00170">CheckChildren()</a>, and <a class="el" href="a00011_source.html#l00100">CheckStart()</a>.</p>

</div>
</div>
<a id="ac08636a123b62c95e1a3c438f84f2e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08636a123b62c95e1a3c438f84f2e06">&#9670;&nbsp;</a></span>CheckRay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::GraphGenerator::GraphGeneratorPrivate::CheckRay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00276.html#a8c29578574c275e66fbd439be62c125e">v3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00276.html#a8c29578574c275e66fbd439be62c125e">v3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00276.html#a6180d5bc4bbfa9a5a426089e1f1ad598">HIT_FLAG</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code>HIT_FLAG::BOTH</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a ray and overwrite position with the point of intersection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Node to use as the origin. On intersection, this node's position will be overridden with the point of intersection. </td></tr>
    <tr><td class="paramname">direction</td><td>Direction to cast the ray in. </td></tr>
    <tr><td class="paramname">flag</td><td>The type of geometry to collide with. See HIT_FLAG for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on hit, false otherwise. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If true is returned, position contains the point where the casted ray intersected geometry.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if HIT_FLAG isn't a valid value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00395">395</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00008_source.html#l00039">HF::GraphGenerator::BOTH</a>, <a class="el" href="a00119_source.html#l00163">HF::RayTracer::EmbreeRayTracer::FireRay()</a>, <a class="el" href="a00008_source.html#l00035">HF::GraphGenerator::FLOORS</a>, <a class="el" href="a00014_source.html#l00026">GG</a>, <a class="el" href="a00008_source.html#l00037">HF::GraphGenerator::OBSTACLES</a>, and <a class="el" href="a00008_source.html#l00076">HF::GraphGenerator::GraphGenerator::ray_tracer</a>.</p>

</div>
</div>
<a id="a50db86451d7ae5569daa8463e10247ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50db86451d7ae5569daa8463e10247ec">&#9670;&nbsp;</a></span>CheckStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::GraphGenerator::GraphGeneratorPrivate::CheckStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00276.html#a8c29578574c275e66fbd439be62c125e">v3</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push point to the ground if there is ground beneath it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start point to check and modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if CheckRay(start, down) is true, false otherwise </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If true is returned, the start point is placed directly on top of the geometry below it. If false, the start point is unmodified.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00266.html#_todo000004">Todo:</a></b></dt><dd>Is this needed? This is identical to CheckRay. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00100">100</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00011_source.html#l00411">CheckRay()</a>, and <a class="el" href="a00011_source.html#l00027">HF::GraphGenerator::down</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00067">BuildNetwork()</a>.</p>

</div>
</div>
<a id="a5bda9a1954db74dd7754c975da304e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bda9a1954db74dd7754c975da304e22">&#9670;&nbsp;</a></span>ComputerParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::GraphGenerator::GraphGeneratorPrivate::ComputerParent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00011.html#a3394fa820b983014dcac29faca0e4f19">std::pair</a>&lt; int, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a01173.html">HF::SpatialStructures::Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_relations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate edges and children for parent in relations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent node to generate children from. </td></tr>
    <tr><td class="paramname">directions</td><td>Directions to generate children in. </td></tr>
    <tr><td class="paramname">out_relations</td><td>Output parameter for relations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>out_relation contains all valid edges between parent and its children.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01105.html#a551344f5e893380e34b7719b66d560f1" title="Populate out_children with a potential child position for every direction in directions.">GeneratePotentialChildren</a> for info on how directions are used to generate children. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00444">444</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00011_source.html#l00104">GeneratePotentialChildren()</a>, and <a class="el" href="a00011_source.html#l00152">GetChildren()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00251">CrawlGeom()</a>, and <a class="el" href="a00011_source.html#l00296">CrawlGeomParallel()</a>.</p>

</div>
</div>
<a id="a7944155fef41ad8b6ae2c4258444aab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7944155fef41ad8b6ae2c4258444aab1">&#9670;&nbsp;</a></span>CrawlGeom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::GraphGenerator::GraphGeneratorPrivate::CrawlGeom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01109.html">UniqueQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>todo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin breadth first search to populate the graph with with nodes and edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">todo</td><td>Todo list to hold unchecked nodes. Must atleast contain a single start point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>todo contains the starting point for the graph.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00266.html#_todo000006">Todo:</a></b></dt><dd>Extract the set logic for directions to another function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01105.html#a050d3cb17b0ea8c32625cf83ffe0d48d" title="A parallel version of CrawlGeom.">CrawlGeomParallel</a> for a parallel version. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00251">251</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00149_source.html#l00224">HF::SpatialStructures::Graph::addEdge()</a>, <a class="el" href="a00011_source.html#l00444">ComputerParent()</a>, <a class="el" href="a00017_source.html#l00055">HF::GraphGenerator::UniqueQueue::empty()</a>, <a class="el" href="a00014_source.html#l00025">G</a>, <a class="el" href="a00014_source.html#l00026">GG</a>, <a class="el" href="a00008_source.html#l00088">HF::GraphGenerator::GraphGenerator::max_nodes</a>, <a class="el" href="a00008_source.html#l00086">HF::GraphGenerator::GraphGenerator::max_step_connection</a>, <a class="el" href="a00011_source.html#l00035">HF::GraphGenerator::permutations()</a>, <a class="el" href="a00017_source.html#l00025">HF::GraphGenerator::UniqueQueue::pop()</a>, and <a class="el" href="a00017_source.html#l00011">HF::GraphGenerator::UniqueQueue::push()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00067">BuildNetwork()</a>.</p>

</div>
</div>
<a id="a050d3cb17b0ea8c32625cf83ffe0d48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050d3cb17b0ea8c32625cf83ffe0d48d">&#9670;&nbsp;</a></span>CrawlGeomParallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::GraphGenerator::GraphGeneratorPrivate::CrawlGeomParallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01109.html">UniqueQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>todo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A parallel version of CrawlGeom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">todo</td><td>Todo list to use for execution. Must atleast contain a single start point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>todo contains the start point for the graph.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00266.html#_todo000007">Todo:</a></b></dt><dd>Extract the set logic for directions to another function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01105.html#a7944155fef41ad8b6ae2c4258444aab1" title="Begin breadth first search to populate the graph with with nodes and edges.">CrawlGeom</a> for a serial version. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00296">296</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00149_source.html#l00224">HF::SpatialStructures::Graph::addEdge()</a>, <a class="el" href="a00011_source.html#l00444">ComputerParent()</a>, <a class="el" href="a00017_source.html#l00055">HF::GraphGenerator::UniqueQueue::empty()</a>, <a class="el" href="a00014_source.html#l00025">G</a>, <a class="el" href="a00014_source.html#l00026">GG</a>, <a class="el" href="a00008_source.html#l00088">HF::GraphGenerator::GraphGenerator::max_nodes</a>, <a class="el" href="a00008_source.html#l00086">HF::GraphGenerator::GraphGenerator::max_step_connection</a>, <a class="el" href="a00011_source.html#l00035">HF::GraphGenerator::permutations()</a>, <a class="el" href="a00017_source.html#l00025">HF::GraphGenerator::UniqueQueue::pop()</a>, <a class="el" href="a00017_source.html#l00064">HF::GraphGenerator::UniqueQueue::popMany()</a>, <a class="el" href="a00017_source.html#l00011">HF::GraphGenerator::UniqueQueue::push()</a>, and <a class="el" href="a00017_source.html#l00032">HF::GraphGenerator::UniqueQueue::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00067">BuildNetwork()</a>.</p>

</div>
</div>
<a id="a551344f5e893380e34b7719b66d560f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551344f5e893380e34b7719b66d560f1">&#9670;&nbsp;</a></span>GeneratePotentialChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::GraphGenerator::GraphGeneratorPrivate::GeneratePotentialChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00011.html#a3394fa820b983014dcac29faca0e4f19">std::pair</a>&lt; int, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate out_children with a potential child position for every direction in directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent to generate children for. </td></tr>
    <tr><td class="paramname">directions</td><td>X,Y pairs to use for generating children. I.E. A pair of <code>{1,2}</code>would create a child at <code>{parent.x + 1*spacing.x, parent.y + 2*spacing.y, parent.z + spacing.z}.</code> </td></tr>
    <tr><td class="paramname">out_children</td><td>Output parameter for children. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>out_children is filled with children generated from parent and directions.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00266.html#_todo000005">Todo:</a></b></dt><dd>Potential speed gain here by using indexing instead of emplace_back. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00104">104</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00014_source.html#l00026">GG</a>, <a class="el" href="a00137_source.html#l00013">HF::SpatialStructures::roundhf()</a>, and <a class="el" href="a00008_source.html#l00077">HF::GraphGenerator::GraphGenerator::spacing</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00444">ComputerParent()</a>.</p>

</div>
</div>
<a id="a2acd7efa04ae228a721cef631a38af28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acd7efa04ae228a721cef631a38af28">&#9670;&nbsp;</a></span>GetChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::GraphGenerator::GraphGeneratorPrivate::GetChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a01193.html">SpatialStructures::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>possible_children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a01173.html">HF::SpatialStructures::Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create all possible edges from parent to possible_children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent node used to generate contents of possible_children. </td></tr>
    <tr><td class="paramname">possible_children</td><td>Possible children for parent. Usually generated from GeneratePotentialChildren. </td></tr>
    <tr><td class="paramname">out_children</td><td>An output array for valid edges in after they've been evaluated. </td></tr>
  </table>
  </dd>
</dl>
<p>All children are offset to the ground using <a class="el" href="a01105.html#a29aa18d3ae2ef2082ab56ca9061d16ee">CheckChildren</a>, then a connection to parent is checked for using CheckConnection. If CheckChildren or CheckConnection is not successful for a child node, then it will not have an edge created in out_children.</p>
<dl class="section post"><dt>Postcondition</dt><dd>out_children contains a set of all valid edges between parent and the children in possible_children. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00152">152</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00011_source.html#l00170">CheckChildren()</a>, <a class="el" href="a00011_source.html#l00189">CheckConnection()</a>, <a class="el" href="a01481_source.html#l00040">HF::SpatialStructures::Node::distanceTo()</a>, and <a class="el" href="a00146_source.html#l00016">HF::SpatialStructures::NOT_CONNECTED</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00444">ComputerParent()</a>.</p>

</div>
</div>
<a id="ac869aa5099472e5ad240c98ee92637a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac869aa5099472e5ad240c98ee92637a4">&#9670;&nbsp;</a></span>isUpSlope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::GraphGenerator::GraphGeneratorPrivate::isUpSlope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01193.html">HF::SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the graph can traverse the slope from n1 to n2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>Node that's being traversed from. </td></tr>
    <tr><td class="paramname">n2</td><td>Node that's being traversed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the slope between n1 and n2 is within the limits in our settings. False otherwise. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00266.html#_todo000008">Todo:</a></b></dt><dd>Rename this function to SlopeCheck, or SlopeCalc like the function it's based on in the original python code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00139">139</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00008_source.html#l00082">HF::GraphGenerator::GraphGenerator::downslope</a>, <a class="el" href="a00014_source.html#l00026">GG</a>, <a class="el" href="a00008_source.html#l00081">HF::GraphGenerator::GraphGenerator::upslope</a>, <a class="el" href="a00155_source.html#l00040">HF::SpatialStructures::Node::x</a>, <a class="el" href="a00155_source.html#l00040">HF::SpatialStructures::Node::y</a>, and <a class="el" href="a00155_source.html#l00040">HF::SpatialStructures::Node::z</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00189">CheckConnection()</a>.</p>

</div>
</div>
<a id="acd3a1c33e1b452f3938a2cc7da4d6d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3a1c33e1b452f3938a2cc7da4d6d26">&#9670;&nbsp;</a></span>OcclusionCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::GraphGenerator::GraphGeneratorPrivate::OcclusionCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01193.html">SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01193.html">SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if there is an obstruction between parent and child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent node to cast the ray from. </td></tr>
    <tr><td class="paramname">child</td><td>Child node to cast the ray to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is an obstacle blocking line of sight between between parent and child. </dd></dl>
<p>This function casts an occlusion ray from parent to child with a maximum distance equal to the distance between both nodes. </p>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00122">122</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a01481_source.html#l00130">HF::SpatialStructures::Node::directionTo()</a>, <a class="el" href="a01481_source.html#l00040">HF::SpatialStructures::Node::distanceTo()</a>, <a class="el" href="a00119_source.html#l00291">HF::RayTracer::EmbreeRayTracer::FireOcclusionRay()</a>, <a class="el" href="a00014_source.html#l00026">GG</a>, <a class="el" href="a00008_source.html#l00076">HF::GraphGenerator::GraphGenerator::ray_tracer</a>, <a class="el" href="a00155_source.html#l00040">HF::SpatialStructures::Node::x</a>, <a class="el" href="a00155_source.html#l00040">HF::SpatialStructures::Node::y</a>, and <a class="el" href="a00155_source.html#l00040">HF::SpatialStructures::Node::z</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00189">CheckConnection()</a>.</p>

</div>
</div>
<a id="a7b257d8db4110e76d249e81810ca1084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b257d8db4110e76d249e81810ca1084">&#9670;&nbsp;</a></span>WalkableCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::GraphGenerator::GraphGeneratorPrivate::WalkableCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01193.html">SpatialStructures::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a node is above a valid floor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Node to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node is above a valid floor, false othewise. </dd></dl>
<p>Identical to CheckRay, but without any side effects. (the value of position won't change). </p>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00056">56</a> of file <a class="el" href="a00011_source.html">graph_generator_private.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00011_source.html#l00027">HF::GraphGenerator::down</a>, and <a class="el" href="a00008_source.html#l00035">HF::GraphGenerator::FLOORS</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a556e9b9bdd1a6244d4c7d42a5ec9d81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556e9b9bdd1a6244d4c7d42a5ec9d81f">&#9670;&nbsp;</a></span>G</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01189.html">HF::SpatialStructures::Graph</a> HF::GraphGenerator::GraphGeneratorPrivate::G</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An internal graph that is iterated upon as the program is executed. </p>

<p class="definition">Definition at line <a class="el" href="a00014_source.html#l00025">25</a> of file <a class="el" href="a00014_source.html">graph_generator_private.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00067">BuildNetwork()</a>, <a class="el" href="a00011_source.html#l00251">CrawlGeom()</a>, and <a class="el" href="a00011_source.html#l00296">CrawlGeomParallel()</a>.</p>

</div>
</div>
<a id="a821adb5a1c656772091a8998cb1d3c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821adb5a1c656772091a8998cb1d3c7b">&#9670;&nbsp;</a></span>GG</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01101.html">HF::GraphGenerator::GraphGenerator</a>&amp; HF::GraphGenerator::GraphGeneratorPrivate::GG</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The underlying graph generator to hold all the settings. </p>

<p class="definition">Definition at line <a class="el" href="a00014_source.html#l00026">26</a> of file <a class="el" href="a00014_source.html">graph_generator_private.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00011_source.html#l00067">BuildNetwork()</a>, <a class="el" href="a00011_source.html#l00170">CheckChildren()</a>, <a class="el" href="a00011_source.html#l00189">CheckConnection()</a>, <a class="el" href="a00011_source.html#l00395">CheckRay()</a>, <a class="el" href="a00011_source.html#l00251">CrawlGeom()</a>, <a class="el" href="a00011_source.html#l00296">CrawlGeomParallel()</a>, <a class="el" href="a00011_source.html#l00104">GeneratePotentialChildren()</a>, <a class="el" href="a00011_source.html#l00139">isUpSlope()</a>, and <a class="el" href="a00011_source.html#l00122">OcclusionCheck()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Cpp/analysismethods/src/<a class="el" href="a00014_source.html">graph_generator_private.h</a></li>
<li>Cpp/analysismethods/src/<a class="el" href="a00011_source.html">graph_generator_private.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
