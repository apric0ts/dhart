<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Analysis: HF::SpatialStructures::Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00305.html">HF</a></li><li class="navelem"><a class="el" href="a00308.html">SpatialStructures</a></li><li class="navelem"><a class="el" href="a01220.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="a01217.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HF::SpatialStructures::Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="a01220.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">Graph</a> of nodes connected by edges that supports both integers and <a class="el" href="a01224.html" title="A point in space with an ID.">HF::SpatialStructures::Node</a>.  
 <a href="a01220.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00173_source.html">graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8225b5596508853ec637e72873a45cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#af8225b5596508853ec637e72873a45cb">Graph</a> (const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;edges, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;distances, const std::vector&lt; <a class="el" href="a01224.html">Node</a> &gt; &amp;<a class="el" href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>)</td></tr>
<tr class="memdesc:af8225b5596508853ec637e72873a45cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graph from a list of nodes, edges, and distances.  <a href="a01220.html#af8225b5596508853ec637e72873a45cb">More...</a><br /></td></tr>
<tr class="separator:af8225b5596508853ec637e72873a45cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5456486f43b49867082946106542f09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#ad5456486f43b49867082946106542f09">Graph</a> ()</td></tr>
<tr class="memdesc:ad5456486f43b49867082946106542f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty graph.  <a href="a01220.html#ad5456486f43b49867082946106542f09">More...</a><br /></td></tr>
<tr class="separator:ad5456486f43b49867082946106542f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00121404a647b0d619f201cf9ebc797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#af00121404a647b0d619f201cf9ebc797">HasEdge</a> (const std::array&lt; float, 3 &gt; &amp;parent, const std::array&lt; float, 3 &gt; &amp;child, bool undirected=false) const</td></tr>
<tr class="memdesc:af00121404a647b0d619f201cf9ebc797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge from parent to child.  <a href="a01220.html#af00121404a647b0d619f201cf9ebc797">More...</a><br /></td></tr>
<tr class="separator:af00121404a647b0d619f201cf9ebc797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affca013028fca6ac730f3f313744500b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#affca013028fca6ac730f3f313744500b">HasEdge</a> (const <a class="el" href="a01224.html">Node</a> &amp;parent, const <a class="el" href="a01224.html">Node</a> &amp;child, const bool undirected=false) const</td></tr>
<tr class="memdesc:affca013028fca6ac730f3f313744500b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge from parent to child.  <a href="a01220.html#affca013028fca6ac730f3f313744500b">More...</a><br /></td></tr>
<tr class="separator:affca013028fca6ac730f3f313744500b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae29b0f69f0fff53113b7f968a128796"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#aae29b0f69f0fff53113b7f968a128796">HasEdge</a> (int parent, int child, bool undirected=false) const</td></tr>
<tr class="separator:aae29b0f69f0fff53113b7f968a128796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01224.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a> () const</td></tr>
<tr class="memdesc:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of nodes from the graph sorted by ID.  <a href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">More...</a><br /></td></tr>
<tr class="separator:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f521e01db7e3c038ab2c1fac09b67df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01204.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a9f521e01db7e3c038ab2c1fac09b67df">GetUndirectedEdges</a> (const <a class="el" href="a01224.html">Node</a> &amp;N) const</td></tr>
<tr class="memdesc:a9f521e01db7e3c038ab2c1fac09b67df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all edges to and from node N.  <a href="a01220.html#a9f521e01db7e3c038ab2c1fac09b67df">More...</a><br /></td></tr>
<tr class="separator:a9f521e01db7e3c038ab2c1fac09b67df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26ebb794b444e2214cf0b0fed5a529"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00308.html#a01212">EdgeSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a1a26ebb794b444e2214cf0b0fed5a529">GetEdges</a> () const</td></tr>
<tr class="memdesc:a1a26ebb794b444e2214cf0b0fed5a529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get every in the given graph as IDs.  <a href="a01220.html#a1a26ebb794b444e2214cf0b0fed5a529">More...</a><br /></td></tr>
<tr class="separator:a1a26ebb794b444e2214cf0b0fed5a529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3285be5da987692e0b3671f49d67d21b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a3285be5da987692e0b3671f49d67d21b">AggregateGraph</a> (<a class="el" href="a00308.html#a6b23c0b2531c78f6d5049873c184f4f9">COST_AGGREGATE</a> agg_type, bool directed=true) const</td></tr>
<tr class="memdesc:a3285be5da987692e0b3671f49d67d21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summarize the costs of every outgoing edge for every node in the graph.  <a href="a01220.html#a3285be5da987692e0b3671f49d67d21b">More...</a><br /></td></tr>
<tr class="separator:a3285be5da987692e0b3671f49d67d21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ea4fda7d310b500456ff14527bab9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a01204.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a7c2ea4fda7d310b500456ff14527bab9">operator[]</a> (const <a class="el" href="a01224.html">Node</a> &amp;n) const</td></tr>
<tr class="memdesc:a7c2ea4fda7d310b500456ff14527bab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all edges from <a class="el" href="a01224.html" title="A point in space with an ID.">Node</a> n.  <a href="a01220.html#a7c2ea4fda7d310b500456ff14527bab9">More...</a><br /></td></tr>
<tr class="separator:a7c2ea4fda7d310b500456ff14527bab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604a648f1f73d687ad4544d2ac163212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a> (const <a class="el" href="a01224.html">Node</a> &amp;parent, const <a class="el" href="a01224.html">Node</a> &amp;child, float score=1.0f)</td></tr>
<tr class="memdesc:a604a648f1f73d687ad4544d2ac163212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new edge to the graph from parent to child.  <a href="a01220.html#a604a648f1f73d687ad4544d2ac163212">More...</a><br /></td></tr>
<tr class="separator:a604a648f1f73d687ad4544d2ac163212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa04fa06b0802acd9eebe46a8c7a1787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#afa04fa06b0802acd9eebe46a8c7a1787">addEdge</a> (int parent_id, int child_id, float score)</td></tr>
<tr class="memdesc:afa04fa06b0802acd9eebe46a8c7a1787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new edge to the graph from parent to child.  <a href="a01220.html#afa04fa06b0802acd9eebe46a8c7a1787">More...</a><br /></td></tr>
<tr class="separator:afa04fa06b0802acd9eebe46a8c7a1787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de020064d58c4ab376a26c30be863a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a> (const <a class="el" href="a01224.html">Node</a> &amp;n) const</td></tr>
<tr class="memdesc:a4de020064d58c4ab376a26c30be863a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if n exists in the graph.  <a href="a01220.html#a4de020064d58c4ab376a26c30be863a3">More...</a><br /></td></tr>
<tr class="separator:a4de020064d58c4ab376a26c30be863a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddbbec01c6354b7076f47f71fc1a220"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; float, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#aeddbbec01c6354b7076f47f71fc1a220">NodesAsFloat3</a> () const</td></tr>
<tr class="memdesc:aeddbbec01c6354b7076f47f71fc1a220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of nodes as float arrays.  <a href="a01220.html#aeddbbec01c6354b7076f47f71fc1a220">More...</a><br /></td></tr>
<tr class="separator:aeddbbec01c6354b7076f47f71fc1a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2710af2a75976862d7a235793567d2f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a2710af2a75976862d7a235793567d2f3">size</a> () const</td></tr>
<tr class="memdesc:a2710af2a75976862d7a235793567d2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how many nodes are in the graph.  <a href="a01220.html#a2710af2a75976862d7a235793567d2f3">More...</a><br /></td></tr>
<tr class="separator:a2710af2a75976862d7a235793567d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59beedafb4af0ee99d54761e1c681fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#af59beedafb4af0ee99d54761e1c681fc">getID</a> (const <a class="el" href="a01224.html">Node</a> &amp;node) const</td></tr>
<tr class="memdesc:af59beedafb4af0ee99d54761e1c681fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the ID for node in this graph.  <a href="a01220.html#af59beedafb4af0ee99d54761e1c681fc">More...</a><br /></td></tr>
<tr class="separator:af59beedafb4af0ee99d54761e1c681fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cece77d0eee98df39ecc6d3a366ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a> ()</td></tr>
<tr class="memdesc:a41cece77d0eee98df39ecc6d3a366ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress the graph to a CSR and enable the usage of several functions.  <a href="a01220.html#a41cece77d0eee98df39ecc6d3a366ec8">More...</a><br /></td></tr>
<tr class="separator:a41cece77d0eee98df39ecc6d3a366ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccd105c93a826bde0457449f774fd04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01216.html">CSRPtrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#afccd105c93a826bde0457449f774fd04">GetCSRPointers</a> ()</td></tr>
<tr class="memdesc:afccd105c93a826bde0457449f774fd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the size of and pointers to the 3 arrays that comprise this graph's CSR. graph if it isn't compressed already  <a href="a01220.html#afccd105c93a826bde0457449f774fd04">More...</a><br /></td></tr>
<tr class="separator:afccd105c93a826bde0457449f774fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794c342603cefb342fdc698ba539b25f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01224.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a794c342603cefb342fdc698ba539b25f">NodeFromID</a> (int id) const</td></tr>
<tr class="memdesc:a794c342603cefb342fdc698ba539b25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the node that corresponds to id.  <a href="a01220.html#a794c342603cefb342fdc698ba539b25f">More...</a><br /></td></tr>
<tr class="separator:a794c342603cefb342fdc698ba539b25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994dbd15119eb6548d2e15f4de4b88a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a994dbd15119eb6548d2e15f4de4b88a6">Clear</a> ()</td></tr>
<tr class="memdesc:a994dbd15119eb6548d2e15f4de4b88a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all nodes and edges from the graph.  <a href="a01220.html#a994dbd15119eb6548d2e15f4de4b88a6">More...</a><br /></td></tr>
<tr class="separator:a994dbd15119eb6548d2e15f4de4b88a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8abc9a6de7add5c18492fdd5d8b2066"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01224.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#ae8abc9a6de7add5c18492fdd5d8b2066">GetChildren</a> (const <a class="el" href="a01224.html">Node</a> &amp;n) const</td></tr>
<tr class="memdesc:ae8abc9a6de7add5c18492fdd5d8b2066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve n's child nodes - n is a parent node  <a href="a01220.html#ae8abc9a6de7add5c18492fdd5d8b2066">More...</a><br /></td></tr>
<tr class="separator:ae8abc9a6de7add5c18492fdd5d8b2066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c92dcac871808647549eea88d5b3837"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01224.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a5c92dcac871808647549eea88d5b3837">GetChildren</a> (const int parent_id)</td></tr>
<tr class="memdesc:a5c92dcac871808647549eea88d5b3837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve node parent_id's child nodes  <a href="a01220.html#a5c92dcac871808647549eea88d5b3837">More...</a><br /></td></tr>
<tr class="separator:a5c92dcac871808647549eea88d5b3837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1638cb2954e7345735c6570039d2b94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#aa1638cb2954e7345735c6570039d2b94">AddNodeAttribute</a> (int id, std::string attribute, std::string score)</td></tr>
<tr class="memdesc:aa1638cb2954e7345735c6570039d2b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute to the node at id  <a href="a01220.html#aa1638cb2954e7345735c6570039d2b94">More...</a><br /></td></tr>
<tr class="separator:aa1638cb2954e7345735c6570039d2b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd226cc2931bf6158721204095574005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#acd226cc2931bf6158721204095574005">AddNodeAttributes</a> (std::vector&lt; int &gt; id, std::string name, std::vector&lt; std::string &gt; scores)</td></tr>
<tr class="memdesc:acd226cc2931bf6158721204095574005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute to the node at id. If the node at id already has a score for the attribute at name, then existing score should be overwritten  <a href="a01220.html#acd226cc2931bf6158721204095574005">More...</a><br /></td></tr>
<tr class="separator:acd226cc2931bf6158721204095574005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd218785fbf6dabaa2fba2dca738618"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#aedd218785fbf6dabaa2fba2dca738618">GetNodeAttributes</a> (std::string attribute) const</td></tr>
<tr class="memdesc:aedd218785fbf6dabaa2fba2dca738618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the score for the given attribute of every node in the graph. Nodes that do not have a score for this attribute should return an empty string for this array.  <a href="a01220.html#aedd218785fbf6dabaa2fba2dca738618">More...</a><br /></td></tr>
<tr class="separator:aedd218785fbf6dabaa2fba2dca738618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0279f117df3d0d29d0a06301dac146a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a0279f117df3d0d29d0a06301dac146a9">ClearNodeAttributes</a> (std::string name)</td></tr>
<tr class="memdesc:a0279f117df3d0d29d0a06301dac146a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the attribute at name and all of its contents from the internal hashmap  <a href="a01220.html#a0279f117df3d0d29d0a06301dac146a9">More...</a><br /></td></tr>
<tr class="separator:a0279f117df3d0d29d0a06301dac146a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a459ae9952e205951060473d2ade3078e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a459ae9952e205951060473d2ade3078e">NodeAttributeValueMap</a> = std::unordered_map&lt; int, std::string &gt;</td></tr>
<tr class="separator:a459ae9952e205951060473d2ade3078e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afca147a681e4b39bc471e02d0f07eb37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a> (const <a class="el" href="a01224.html">Node</a> &amp;input_node)</td></tr>
<tr class="memdesc:afca147a681e4b39bc471e02d0f07eb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique ID for this x, y, z position, assigning it an new one if it doesn't already exist  <a href="a01220.html#afca147a681e4b39bc471e02d0f07eb37">More...</a><br /></td></tr>
<tr class="separator:afca147a681e4b39bc471e02d0f07eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133b6f44ac90ed6135752e32482b70f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a133b6f44ac90ed6135752e32482b70f5">getOrAssignID</a> (int input_int)</td></tr>
<tr class="memdesc:a133b6f44ac90ed6135752e32482b70f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an ID to the graph if it doesn't exist already.  <a href="a01220.html#a133b6f44ac90ed6135752e32482b70f5">More...</a><br /></td></tr>
<tr class="separator:a133b6f44ac90ed6135752e32482b70f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902d654a1c1b6d391c27c6c2bd618bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a902d654a1c1b6d391c27c6c2bd618bbc">checkForEdge</a> (int parent, int child) const</td></tr>
<tr class="memdesc:a902d654a1c1b6d391c27c6c2bd618bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge between parent and child exists in the graph.  <a href="a01220.html#a902d654a1c1b6d391c27c6c2bd618bbc">More...</a><br /></td></tr>
<tr class="separator:a902d654a1c1b6d391c27c6c2bd618bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad59ab7164b64e3d78b7032b28c2c6663"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01224.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#ad59ab7164b64e3d78b7032b28c2c6663">ordered_nodes</a></td></tr>
<tr class="memdesc:ad59ab7164b64e3d78b7032b28c2c6663"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of nodes contained by the graph.  <a href="a01220.html#ad59ab7164b64e3d78b7032b28c2c6663">More...</a><br /></td></tr>
<tr class="separator:ad59ab7164b64e3d78b7032b28c2c6663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6515ac2323a16e27adab7b20561a649"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#ab6515ac2323a16e27adab7b20561a649">id_to_nodes</a></td></tr>
<tr class="memdesc:ab6515ac2323a16e27adab7b20561a649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps ids to indexes in ordered_nodes.  <a href="a01220.html#ab6515ac2323a16e27adab7b20561a649">More...</a><br /></td></tr>
<tr class="separator:ab6515ac2323a16e27adab7b20561a649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da5e288f03773d18053c82731369b2a"><td class="memItemLeft" align="right" valign="top">robin_hood::unordered_map&lt; <a class="el" href="a01224.html">Node</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a4da5e288f03773d18053c82731369b2a">idmap</a></td></tr>
<tr class="memdesc:a4da5e288f03773d18053c82731369b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list of X,Y,Z positions to ids.  <a href="a01220.html#a4da5e288f03773d18053c82731369b2a">More...</a><br /></td></tr>
<tr class="separator:a4da5e288f03773d18053c82731369b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d4522c02692328c767ff439ca6511a"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; float, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a77d4522c02692328c767ff439ca6511a">edge_matrix</a></td></tr>
<tr class="memdesc:a77d4522c02692328c767ff439ca6511a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying CSR containing edge nformation.  <a href="a01220.html#a77d4522c02692328c767ff439ca6511a">More...</a><br /></td></tr>
<tr class="separator:a77d4522c02692328c767ff439ca6511a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab13304c641df6fdcd3662d5c54dc78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#aaab13304c641df6fdcd3662d5c54dc78">next_id</a> = 0</td></tr>
<tr class="memdesc:aaab13304c641df6fdcd3662d5c54dc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id for the next unique node.  <a href="a01220.html#aaab13304c641df6fdcd3662d5c54dc78">More...</a><br /></td></tr>
<tr class="separator:aaab13304c641df6fdcd3662d5c54dc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf07c256da74c2a03f81b4977364e85"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Triplet&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a1cf07c256da74c2a03f81b4977364e85">triplets</a></td></tr>
<tr class="memdesc:a1cf07c256da74c2a03f81b4977364e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edges to be converted to a CSR when <a class="el" href="a01220.html#a41cece77d0eee98df39ecc6d3a366ec8" title="Compress the graph to a CSR and enable the usage of several functions.">Graph::Compress()</a> is called.  <a href="a01220.html#a1cf07c256da74c2a03f81b4977364e85">More...</a><br /></td></tr>
<tr class="separator:a1cf07c256da74c2a03f81b4977364e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbd600663187d7cf985e9b6e7cea73f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a1cbd600663187d7cf985e9b6e7cea73f">needs_compression</a> = true</td></tr>
<tr class="memdesc:a1cbd600663187d7cf985e9b6e7cea73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the CSR is inaccurate and requires compression.  <a href="a01220.html#a1cbd600663187d7cf985e9b6e7cea73f">More...</a><br /></td></tr>
<tr class="separator:a1cbd600663187d7cf985e9b6e7cea73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c573322aa34d24211cdfe29033cdae8"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="a01220.html#a459ae9952e205951060473d2ade3078e">NodeAttributeValueMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01220.html#a9c573322aa34d24211cdfe29033cdae8">node_attr_map</a></td></tr>
<tr class="memdesc:a9c573322aa34d24211cdfe29033cdae8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a01224.html" title="A point in space with an ID.">Node</a> attribute type : Map of node id to node attribute.  <a href="a01220.html#a9c573322aa34d24211cdfe29033cdae8">More...</a><br /></td></tr>
<tr class="separator:a9c573322aa34d24211cdfe29033cdae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="a01220.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">Graph</a> of nodes connected by edges that supports both integers and <a class="el" href="a01224.html" title="A point in space with an ID.">HF::SpatialStructures::Node</a>. </p>
<p>Internally, this object uses <a class="el" href="a00313.html" title="Eigen a C++ template library for linear algebra: matrices, vectors, numerical solvers,...">Eigen</a> (<a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a>) to store and maintain a CSR matrix.</p>
<dl class="section invariant"><dt>Invariant</dt><dd>Every node in the graph will have a Unique ID with no repeats </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00268">268</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a459ae9952e205951060473d2ade3078e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459ae9952e205951060473d2ade3078e">&#9670;&nbsp;</a></span>NodeAttributeValueMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01220.html#a459ae9952e205951060473d2ade3078e">HF::SpatialStructures::Graph::NodeAttributeValueMap</a> =  std::unordered_map&lt;int, std::string&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00269">269</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af8225b5596508853ec637e72873a45cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8225b5596508853ec637e72873a45cb">&#9670;&nbsp;</a></span>Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HF::SpatialStructures::Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a01224.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a graph from a list of nodes, edges, and distances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>Ordered array of arrays of edges for each node in nodes. </td></tr>
    <tr><td class="paramname">distances</td><td>Ordered array of distance from parent to child for each edge in edges. </td></tr>
    <tr><td class="paramname">Nodes</td><td>Ordered array of nodes to act as a parent to all children in it's array in edges.</td></tr>
  </table>
  </dd>
</dl>
<p>Preallocates the matrix it in element by element and compresses it.</p>
<dl class="section pre"><dt>Precondition</dt><dd>1) The size of all input arrays must match: <code>(edges.size() == nodes.size() &amp;&amp; nodes.size() == distances.size())</code></dd>
<dd>
2) For the node at <code>nodes[i]</code>, <code>edges[i]</code> should contain an array for the id of all nodes that <code>nodes[i]</code> has an edge from and, and <code>distances[i]</code> should contain an array of the the distance from <code>nodes[i]</code> to one of the nodes it has an edge to in <code>edges[i]</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After constructing a graph with this constructor, it will not be able to be modified. Use the empty constructor and use addEdge if you want to modify the graph after construction. This may change in the future.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This constructor can offer "slightly higher performance and memory consumption" than constructing a graph using <a class="el" href="a01220.html#a604a648f1f73d687ad4544d2ac163212" title="Add a new edge to the graph from parent to child.">Graph::addEdge</a> in a loop according to official eigen documentation, however it may not be feasible for certain situations where the entire graph isn't known before the constructor is called. The implementation is based on the algorithm from <a class="el" href="a00313.html" title="Eigen a C++ template library for linear algebra: matrices, vectors, numerical solvers,...">Eigen</a>'s documentation under the section Filling a Sparse Matrix <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00328">328</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="ad5456486f43b49867082946106542f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5456486f43b49867082946106542f09">&#9670;&nbsp;</a></span>Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HF::SpatialStructures::Graph::Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty graph. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This can be used to create a new graph to later be filled with edges/nodes by calling <a class="el" href="a01220.html#a604a648f1f73d687ad4544d2ac163212" title="Add a new edge to the graph from parent to child.">Graph::addEdge()</a> then calling <a class="el" href="a01220.html#a41cece77d0eee98df39ecc6d3a366ec8" title="Compress the graph to a CSR and enable the usage of several functions.">Graph::Compress()</a>. Implementation is based on the <a class="el" href="a00313.html" title="Eigen a C++ template library for linear algebra: matrices, vectors, numerical solvers,...">Eigen</a> documentation for Filling a CSR: <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01220.html#a604a648f1f73d687ad4544d2ac163212" title="Add a new edge to the graph from parent to child.">Graph::addEdge()</a> for details on adding edges. </dd>
<dd>
<a class="el" href="a01220.html#a41cece77d0eee98df39ecc6d3a366ec8" title="Compress the graph to a CSR and enable the usage of several functions.">Graph::Compress()</a> for details on compressing the graph.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph;     <span class="comment">// This represents an order-zero graph (null graph)</span></div>
<div class="line">                                        <span class="comment">// It lacks vertices and edges.</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00400">400</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a604a648f1f73d687ad4544d2ac163212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604a648f1f73d687ad4544d2ac163212">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new edge to the graph from parent to child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent node of the edge. </td></tr>
    <tr><td class="paramname">child</td><td>Child node of the edge. </td></tr>
    <tr><td class="paramname">score</td><td>Cost of traversing from aprent to child. </td></tr>
  </table>
  </dd>
</dl>
<p>If the parent or child node do not have an ID. An ID will be assigned automatically.</p>
<dl class="section warning"><dt>Warning</dt><dd>This will not work if the graph wasn't created from the empty constructor since it has no internal edge list to add to.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This adds a new element to the triplet list so next time Compress is called, the value is added to the graph.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00296.html#_todo000035">Todo:</a></b></dt><dd>How should this signal that the graph can't have edges added to it? Or how do we add edges to an existing graph quickly without adding to its edge list?</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a pair of nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> n_parent(4.0f, 5.0f, 6.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> n_child(7.0f, 8.0f, 9.0f);</div>
<div class="line"> </div>
<div class="line">graph.<a class="code" href="a01220.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(n_parent, n_child);   <span class="comment">// default score is 1.0f</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00226">226</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00278_source.html#l00099">AddEdgeFromNodeIDs()</a>, <a class="el" href="a00278_source.html#l00079">AddEdgeFromNodes()</a>, <a class="el" href="a00011_source.html#l00290">HF::GraphGenerator::GraphGeneratorPrivate::CrawlGeom()</a>, and <a class="el" href="a00011_source.html#l00316">HF::GraphGenerator::GraphGeneratorPrivate::CrawlGeomParallel()</a>.</p>

</div>
</div>
<a id="afa04fa06b0802acd9eebe46a8c7a1787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa04fa06b0802acd9eebe46a8c7a1787">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new edge to the graph from parent to child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent node of the edge. </td></tr>
    <tr><td class="paramname">child</td><td>Child node of the edge. </td></tr>
    <tr><td class="paramname">score</td><td>Cost of traversing from aprent to child. </td></tr>
  </table>
  </dd>
</dl>
<p>If the parent or child ids don't exist in the dictionary, they will be added.</p>
<dl class="section warning"><dt>Warning</dt><dd>This will not work if the graph wasn't created from the empty constructor since it has no internal edge list to add to.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This adds a new element to the triplet list so next time Compress is called, the value is added to the graph. (Note: if an edge exists between parent_id and child_id, the score value will be added to the existing score value for the edge formed by parent_id and child_id).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00296.html#_todo000036">Todo:</a></b></dt><dd>How should this signal that the graph can't have edges added to it? Or how do we add edges to an existing graph quickly without adding to its edge list?</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> parent = 1;</div>
<div class="line"><span class="keywordtype">int</span> child = 2;</div>
<div class="line"> </div>
<div class="line">graph.<a class="code" href="a01220.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(parent, child, 1.0f);</div>
<div class="line">graph.<a class="code" href="a01220.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a>();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00239">239</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="aa1638cb2954e7345735c6570039d2b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1638cb2954e7345735c6570039d2b94">&#9670;&nbsp;</a></span>AddNodeAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::AddNodeAttribute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an attribute to the node at id </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the node that will receive attribute</td></tr>
    <tr><td class="paramname">attribute</td><td>The attribute that the node at ID will receive</td></tr>
    <tr><td class="paramname">score</td><td>The weight, or distance that extends from the node at id</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00445">445</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00158_source.html#l00024">HF::SpatialStructures::CostAlgorithms::is_floating_type()</a>.</p>

</div>
</div>
<a id="acd226cc2931bf6158721204095574005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd226cc2931bf6158721204095574005">&#9670;&nbsp;</a></span>AddNodeAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::AddNodeAttributes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>scores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an attribute to the node at id. If the node at id already has a score for the attribute at name, then existing score should be overwritten </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The container of IDs from which nodes will be retrieved and given attributes</td></tr>
    <tr><td class="paramname">name</td><td>The attribute that each node will receive</td></tr>
    <tr><td class="paramname">scores</td><td>The container of score, ordered by the container of node IDs</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00533">533</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00278_source.html#l00167">AddNodeAttributes()</a>.</p>

</div>
</div>
<a id="a3285be5da987692e0b3671f49d67d21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3285be5da987692e0b3671f49d67d21b">&#9670;&nbsp;</a></span>AggregateGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; HF::SpatialStructures::Graph::AggregateGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html#a6b23c0b2531c78f6d5049873c184f4f9">COST_AGGREGATE</a>&#160;</td>
          <td class="paramname"><em>agg_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Summarize the costs of every outgoing edge for every node in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agg_type</td><td>Type of aggregation to use. </td></tr>
    <tr><td class="paramname">directed</td><td>If true, include both incoming and outgoing edges for calculating a node's score. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ordered list of scores for agg_type on each node in the graph. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Useful for getting scores from the <a class="el" href="a00310.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if agg_type doesn't match any value of COST_AGGREGATE. </td></tr>
    <tr><td class="paramname">Std::exception</td><td>if the graph isn't compressed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time Complexity</dt><dd>If undirected: <code>O(k)</code> where k is the total number of edges in the graph.<br  />
If directed: <code>O(n)</code> where n is the total number of nodes in the graph.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00308.html#a6b23c0b2531c78f6d5049873c184f4f9" title="Methods of aggregating the costs for edges for each node in the graph.">COST_AGGREGATE</a> to see a list of supported aggregation types. <div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// graph must be compressed, or a exception will be thrown</span></div>
<div class="line"><a class="code" href="a00308.html#a6b23c0b2531c78f6d5049873c184f4f9">HF::SpatialStructures::COST_AGGREGATE</a> aggregate = <a class="code" href="a00308.html#a6b23c0b2531c78f6d5049873c184f4f9a16de38737a9f8366e9b2042b4e9b6290">HF::SpatialStructures::COST_AGGREGATE::AVERAGE</a>;       <span class="comment">// aggregate == 1 in this case</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// directed parameter may be true or false</span></div>
<div class="line">std::vector&lt;float&gt; aggregate_graph = graph.<a class="code" href="a01220.html#a3285be5da987692e0b3671f49d67d21b">AggregateGraph</a>(aggregate, <span class="keyword">true</span>); </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00158">158</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00170_source.html#l00132">HF::SpatialStructures::Aggregate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00278_source.html#l00050">AggregateCosts()</a>.</p>

</div>
</div>
<a id="a902d654a1c1b6d391c27c6c2bd618bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902d654a1c1b6d391c27c6c2bd618bbc">&#9670;&nbsp;</a></span>checkForEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::checkForEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if an edge between parent and child exists in the graph. </p>
<p>Iterates through every row in the parent's column to find child. If child is not found in this column, false is returned. If child can be found in this column, then true is returned.</p>
<dl class="section user"><dt>Time Complexity</dt><dd>O(k) where k is the number of edges from parent. <div class="fragment"><div class="line">        </div>
<div class="line">        <span class="comment">// Iterate through parent&#39;s row to see if it has child.</span></div>
<div class="line">        <span class="keywordflow">for</span> (SparseMatrix&lt;float, 1&gt;::InnerIterator it(<a class="code" href="a01220.html#a77d4522c02692328c767ff439ca6511a">edge_matrix</a>, parent); it; ++it)</div>
<div class="line">            <span class="keywordflow">if</span> (it.col() == child) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// If we&#39;ve gotten to this point, then the child doesn&#39;t exist in parent&#39;s row</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00258">258</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a994dbd15119eb6548d2e15f4de4b88a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994dbd15119eb6548d2e15f4de4b88a6">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all nodes and edges from the graph. </p>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If we want to remove all nodes and edges from graph, we may do so with Clear:</span></div>
<div class="line">graph.<a class="code" href="a01220.html#a994dbd15119eb6548d2e15f4de4b88a6">Clear</a>();                      <span class="comment">// edge_matrix is zeroed out, buffer is squeezed,</span></div>
<div class="line">                                    <span class="comment">// triplets are also cleared, and</span></div>
<div class="line">                                    <span class="comment">// needs_compression == true</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00417">417</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00278_source.html#l00143">ClearGraph()</a>.</p>

</div>
</div>
<a id="a0279f117df3d0d29d0a06301dac146a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0279f117df3d0d29d0a06301dac146a9">&#9670;&nbsp;</a></span>ClearNodeAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::ClearNodeAttributes </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the attribute at name and all of its contents from the internal hashmap </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute that will be cleared from this graph's internal hashmap</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00584">584</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00278_source.html#l00266">ClearAttributeType()</a>.</p>

</div>
</div>
<a id="a41cece77d0eee98df39ecc6d3a366ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cece77d0eee98df39ecc6d3a366ec8">&#9670;&nbsp;</a></span>Compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::Compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress the graph to a CSR and enable the usage of several functions. </p>
<p>This won't do anything if called on an already compressed graph. The graph is "compressed" by resizing the edge matrix to the maximum ID of any node in triplets, then calling setFromTriplets().</p>
<dl class="section note"><dt>Note</dt><dd>This function actually doesn't actually reduce memory usage since it keeps the edge list in order to allow for modifications to the graph. In the future, it may be beneficial allow for the user to pass in a boolean that would delete the triplet array if true.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method of constructing the CSR is based on <a class="el" href="a00313.html" title="Eigen a C++ template library for linear algebra: matrices, vectors, numerical solvers,...">Eigen</a>'s documentation for Filling a sparse matrix <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a pair of nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> n_parent(4.0f, 5.0f, 6.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> n_child(7.0f, 8.0f, 9.0f);</div>
<div class="line"> </div>
<div class="line">graph.<a class="code" href="a01220.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(n_parent, n_child);   <span class="comment">// default score is 1.0f</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// In order to use GetEdges, or AggregateGraph, we must compress our graph instance</span></div>
<div class="line">graph.<a class="code" href="a01220.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a>();                       <span class="comment">// GetEdges and AggregateGraph are now usable</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00397">397</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00278_source.html#l00137">Compress()</a>.</p>

</div>
</div>
<a id="a5c92dcac871808647549eea88d5b3837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c92dcac871808647549eea88d5b3837">&#9670;&nbsp;</a></span>GetChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01224.html">Node</a> &gt; HF::SpatialStructures::Graph::GetChildren </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>parent_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve node parent_id's child nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td>The parent node ID from which child nodes will be derived <dl class="section return"><dt>Returns</dt><dd>A container of child nodes that form edges that extend from node parent_id</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00441">441</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="ae8abc9a6de7add5c18492fdd5d8b2066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8abc9a6de7add5c18492fdd5d8b2066">&#9670;&nbsp;</a></span>GetChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01224.html">Node</a> &gt; HF::SpatialStructures::Graph::GetChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve n's child nodes - n is a parent node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The parent node from which child nodes will be derived <dl class="section return"><dt>Returns</dt><dd>A container of child nodes that form edges that extend from parent node n</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00429">429</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="afccd105c93a826bde0457449f774fd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccd105c93a826bde0457449f774fd04">&#9670;&nbsp;</a></span>GetCSRPointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01216.html">CSRPtrs</a> HF::SpatialStructures::Graph::GetCSRPointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the size of and pointers to the 3 arrays that comprise this graph's CSR. graph if it isn't compressed already </p>
<dl class="section return"><dt>Returns</dt><dd>Pointers and sizes of the arrays that comprise the CSR. If the CSR cannot be constructed due to factors such as an empty input array, then the <a class="el" href="a01216.html" title="A struct to hold all necessary information for a CSR.">CSRPtrs</a> contain null values for it's pointers. </dd></dl>
<p>This will automatically call Compress if it hasn't been called already.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This can be useful for reconstructing or mapping to the CSR without interacting with eigen at all. Numpy can directly make map the arrays returned by this function to it's own CSR implementation.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a pair of nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> n_parent(4.0f, 5.0f, 6.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> n_child(7.0f, 8.0f, 9.0f);</div>
<div class="line"> </div>
<div class="line">graph.<a class="code" href="a01220.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(n_parent, n_child);   <span class="comment">// default score is 1.0f</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Graph will be compressed automatically be GetCSRPointers</span></div>
<div class="line">CSRPtrs returned_csr = graph.<a class="code" href="a01220.html#afccd105c93a826bde0457449f774fd04">GetCSRPointers</a>();</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="a01216.html#a4665024245e559dac8c3d620372dc47e" title="Verify the CSR referenced by this instance is valid.">CSRPtrs.AreValid()</a> for checking if the return value represents a valid CSR. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00034">34</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00278_source.html#l00137">Compress()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00278_source.html#l00104">GetCSRPointers()</a>.</p>

</div>
</div>
<a id="a1a26ebb794b444e2214cf0b0fed5a529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a26ebb794b444e2214cf0b0fed5a529">&#9670;&nbsp;</a></span>GetEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a00308.html#a01212">EdgeSet</a> &gt; HF::SpatialStructures::Graph::GetEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get every in the given graph as IDs. </p>
<dl class="section return"><dt>Returns</dt><dd>An array of edgesets for every node in the graph (<a class="el" href="a01220.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">Graph</a> in the form of IDs). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the graph hasn't been compressed. compressed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time Complexity</dt><dd>O(k) where k is the number of edges in the graph.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);    </div>
<div class="line"> </div>
<div class="line"><span class="comment">// graph must be compressed, or a exception will be thrown</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// To brief, an EdgeSet has the following layout: struct EdgeSet { int parent;</span></div>
<div class="line"><span class="comment">// std::vector&lt;IntEdge&gt; children; };</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// An IntEdge has the following layout: struct IntEdge { int child; float</span></div>
<div class="line"><span class="comment">// weight; };</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A std::vector&lt;EdgeSet&gt; is a Graph, in the form of IDs.</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::EdgeSet&gt; edge_set = graph.<a class="code" href="a01220.html#a1a26ebb794b444e2214cf0b0fed5a529">GetEdges</a>();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00089">89</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00122_source.html#l00020">HF::Pathfinding::BoostGraph::BoostGraph()</a>.</p>

</div>
</div>
<a id="af59beedafb4af0ee99d54761e1c681fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59beedafb4af0ee99d54761e1c681fc">&#9670;&nbsp;</a></span>getID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the ID for node in this graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID assigned to this node. -1 if it was not yet added to the graph </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> other_node(55.0f, 66.1f, 15.5f, 9510);  <span class="comment">// Let&#39;s construct a Node we know is not in graph.</span></div>
<div class="line"><span class="keywordtype">bool</span> has_key = graph.<a class="code" href="a01220.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a>(other_node);                            <span class="comment">// other_node does not exist in graph, so has_key == false;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> ID = graph.<a class="code" href="a01220.html#af59beedafb4af0ee99d54761e1c681fc">getID</a>(other_node);                                   <span class="comment">// ID will assigned -1, because other_node is not a part of graph.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Likewise, if we pass a Node instance that indeed exists...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of</span></div>
<div class="line"><span class="comment">// std::vector&lt;Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.<a class="code" href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to hasKey. Any node</span></div>
<div class="line"><span class="comment">// that exists with graph can be passed to this member function to determine if</span></div>
<div class="line"><span class="comment">// the graph has the node&#39;s key, or not.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;                  <span class="comment">// we assume for this example that index 2 is valid.</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> good_node = get_nodes[index];</div>
<div class="line"> </div>
<div class="line">ID = graph.<a class="code" href="a01220.html#af59beedafb4af0ee99d54761e1c681fc">getID</a>(good_node);    <span class="comment">// ID &gt; -1, i.e. it is a Node instance that exists within this Graph.</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00026">26</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00278_source.html#l00126">GetNodeID()</a>.</p>

</div>
</div>
<a id="aedd218785fbf6dabaa2fba2dca738618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd218785fbf6dabaa2fba2dca738618">&#9670;&nbsp;</a></span>GetNodeAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; HF::SpatialStructures::Graph::GetNodeAttributes </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>attribute</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the score for the given attribute of every node in the graph. Nodes that do not have a score for this attribute should return an empty string for this array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>The attribute from which a container of scores will be obtained</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container of score, each in the form of a std::string, obtained from attribute</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00550">550</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00278_source.html#l00186">GetNodeAttributes()</a>.</p>

</div>
</div>
<a id="afca147a681e4b39bc471e02d0f07eb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca147a681e4b39bc471e02d0f07eb37">&#9670;&nbsp;</a></span>getOrAssignID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getOrAssignID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>input_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique ID for this x, y, z position, assigning it an new one if it doesn't already exist </p>
<p>If the node has not yet been seen by the graph, next_id will be assigned to it and incremented, then the node node will and its new id will be added to idmap. If the node has already been assigned an ID, then the ID will be returned directly from idmap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_node</td><td><a class="el" href="a01224.html" title="A point in space with an ID.">Node</a> to retrieve and potentially assign a new ID for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of input_node.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// definition of Graph::addEdge(const Node&amp; parent, const Node&amp; child, float score)</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">        <a class="code" href="a01220.html#a1cbd600663187d7cf985e9b6e7cea73f">needs_compression</a> = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> parent_id = <a class="code" href="a01220.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a>(parent);</div>
<div class="line">        <span class="keywordtype">int</span> child_id = <a class="code" href="a01220.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a>(child);</div>
<div class="line">        <a class="code" href="a01220.html#a1cf07c256da74c2a03f81b4977364e85">triplets</a>.emplace_back(</div>
<div class="line">            Eigen::Triplet&lt;float&gt;(parent_id, child_id, score)</div>
<div class="line">        );</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00290">290</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a133b6f44ac90ed6135752e32482b70f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133b6f44ac90ed6135752e32482b70f5">&#9670;&nbsp;</a></span>getOrAssignID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getOrAssignID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an ID to the graph if it doesn't exist already. </p>
<div class="fragment"><div class="line"><span class="comment">// definition of Graph::addEdge(int parent_id, int child_id, float score)</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"> </div>
<div class="line">        <span class="comment">// This will require that the graph is recompressed</span></div>
<div class="line">        <a class="code" href="a01220.html#a1cbd600663187d7cf985e9b6e7cea73f">needs_compression</a> = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If the parent or child id is larger than next_id, set next_id to parent or child ID.</span></div>
<div class="line">        <a class="code" href="a01220.html#aaab13304c641df6fdcd3662d5c54dc78">next_id</a> = std::max(child_id, std::max(parent_id, <a class="code" href="a01220.html#aaab13304c641df6fdcd3662d5c54dc78">next_id</a>));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Store these Ids in the hashmap if they don&#39;t exist already.</span></div>
<div class="line">        <a class="code" href="a01220.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a>(child_id);</div>
<div class="line">        <a class="code" href="a01220.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a>(parent_id);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Add this to the list of triplets.</span></div>
<div class="line">        <a class="code" href="a01220.html#a1cf07c256da74c2a03f81b4977364e85">triplets</a>.emplace_back(Eigen::Triplet&lt;float&gt;(parent_id, child_id, score));</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00315">315</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a9f521e01db7e3c038ab2c1fac09b67df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f521e01db7e3c038ab2c1fac09b67df">&#9670;&nbsp;</a></span>GetUndirectedEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="a01204.html">Edge</a> &gt; HF::SpatialStructures::Graph::GetUndirectedEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of all edges to and from node N. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The <a class="el" href="a01224.html" title="A point in space with an ID.">Node</a> to get edges from and to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of edges to and from node N or an empty array if is not in the graph. </dd></dl>
<dl class="section user"><dt>Time Complexity</dt><dd><code>O(k)</code> where k is the number of edges in the graph since it needs to iterate through every edge in the graph to find the edges to this node.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>operator[] to get a list of directed edges only containing edges from N.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);    </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of</span></div>
<div class="line"><span class="comment">// std::vector&lt;HF::SpatialStructures::Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.<a class="code" href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to</span></div>
<div class="line"><span class="comment">// GetUndirectedEdges. Any node that exists with graph can be passed to this</span></div>
<div class="line"><span class="comment">// member function to retrieve a vector of undirected edges.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;</div>
<div class="line">std::vector&lt;HF::SpatialStructures::Edge&gt; undirected_edges = graph.<a class="code" href="a01220.html#a9f521e01db7e3c038ab2c1fac09b67df">GetUndirectedEdges</a>(get_nodes[index]);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00061">61</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="affca013028fca6ac730f3f313744500b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affca013028fca6ac730f3f313744500b">&#9670;&nbsp;</a></span>HasEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge from parent to child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of the edge to check for. </td></tr>
    <tr><td class="paramname">child</td><td>Child of the edge to check for. </td></tr>
    <tr><td class="paramname">undirected</td><td>If true, look for an edge from child to parent as well. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an edge between parentand child exists (also child and parent if undirected is true).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Gets the IDs of both nodes, then calls the integer overload.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the graph is uncompressed. <div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// last argument can be true/false for undirected/directed graph respectively</span></div>
<div class="line"><span class="keywordtype">bool</span> has_edge = graph.<a class="code" href="a01220.html#af00121404a647b0d619f201cf9ebc797">HasEdge</a>(node_1, node_2, <span class="keyword">true</span>);</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00274">274</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="af00121404a647b0d619f201cf9ebc797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00121404a647b0d619f201cf9ebc797">&#9670;&nbsp;</a></span>HasEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; float, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; float, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge from parent to child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of the edge to check for. </td></tr>
    <tr><td class="paramname">child</td><td>Child of the edge to check for. </td></tr>
    <tr><td class="paramname">undirected</td><td>If true, look for an edge from child to parent as well. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an edge between parent and child exists (also child and parent if undirected is true).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Converts parent and child to <a class="el" href="a01224.html" title="A point in space with an ID.">Node</a> then calls the node overload.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the matrix is uncompressed. <div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);                                      </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare {x, y, z} coordinates (positions)</span></div>
<div class="line"><span class="keyword">auto</span> parent_pos = node_1.getArray();        <span class="comment">// (2.0, 3.0, 4.0)</span></div>
<div class="line"><span class="keyword">auto</span> child_pos = node_2.getArray();         <span class="comment">// (11.0, 22.0, 140.0)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// last argument can be true/false for undirected/directed graph respectively</span></div>
<div class="line"><span class="keywordtype">bool</span> has_edge = graph.<a class="code" href="a01220.html#af00121404a647b0d619f201cf9ebc797">HasEdge</a>(parent_pos, child_pos, <span class="keyword">true</span>);</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00369">369</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="aae29b0f69f0fff53113b7f968a128796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae29b0f69f0fff53113b7f968a128796">&#9670;&nbsp;</a></span>HasEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00270">270</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a4de020064d58c4ab376a26c30be863a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de020064d58c4ab376a26c30be863a3">&#9670;&nbsp;</a></span>hasKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::hasKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if n exists in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="a01224.html" title="A point in space with an ID.">Node</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node exists, false otherwise. </dd></dl>
<p>Performs a single hash to check if n exists in the hashmap.</p>
<dl class="section user"><dt>Time Complexity</dt><dd>O(1) since it's a single hash function.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> other_node(55.0f, 66.1f, 15.5f, 9510);  <span class="comment">// Let&#39;s construct a Node we know is not in graph.</span></div>
<div class="line"><span class="keywordtype">bool</span> has_key = graph.<a class="code" href="a01220.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a>(other_node);    <span class="comment">// other_node does not exist in graph, so has_key == false;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Likewise, if we pass a Node instance that indeed exists...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of</span></div>
<div class="line"><span class="comment">// std::vector&lt;Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.<a class="code" href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to hasKey. Any node</span></div>
<div class="line"><span class="comment">// that exists with graph can be passed to this member function to determine if</span></div>
<div class="line"><span class="comment">// the graph has the node&#39;s key, or not.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> good_node = get_nodes[index];</div>
<div class="line"> </div>
<div class="line">has_key = graph.<a class="code" href="a01220.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a>(good_node);      <span class="comment">// now has_key is true</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00376">376</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a794c342603cefb342fdc698ba539b25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794c342603cefb342fdc698ba539b25f">&#9670;&nbsp;</a></span>NodeFromID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01224.html">Node</a> HF::SpatialStructures::Graph::NodeFromID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the node that corresponds to id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the node to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node corresponding to id, by value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>id didn't belong to any node in the graph. <div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let&#39;s retrieve node_1.</span></div>
<div class="line"><span class="keywordtype">int</span> desired_node_id = 2;</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_from_id = graph.<a class="code" href="a01220.html#a794c342603cefb342fdc698ba539b25f">NodeFromID</a>(desired_node_id);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note that NodeFromID ceases to work if the id argument provided does not</span></div>
<div class="line"><span class="comment">// exist as an ID among the nodes within graph</span></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00055">55</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="aa70347b8a33b57c6f0a72d6eca4248d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70347b8a33b57c6f0a72d6eca4248d7">&#9670;&nbsp;</a></span>Nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01224.html">Node</a> &gt; HF::SpatialStructures::Graph::Nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of nodes from the graph sorted by ID. </p>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of nodes. </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);    </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nodes() returns a copy of the ordered_nodes field</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes_from_graph = graph.<a class="code" href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00057">57</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00122_source.html#l00020">HF::Pathfinding::BoostGraph::BoostGraph()</a>, <a class="el" href="a00248_source.html#l00015">GenerateGraph()</a>, and <a class="el" href="a00278_source.html#l00016">GetAllNodesFromGraph()</a>.</p>

</div>
</div>
<a id="aeddbbec01c6354b7076f47f71fc1a220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddbbec01c6354b7076f47f71fc1a220">&#9670;&nbsp;</a></span>NodesAsFloat3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; float, 3 &gt; &gt; HF::SpatialStructures::Graph::NodesAsFloat3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of nodes as float arrays. </p>
<dl class="section return"><dt>Returns</dt><dd>An array of float arrays containing the position of every node in the graph in order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>May be useful for to functions that take arrays instead of nodes.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A container of std::array&lt;float, 3&gt; is constructed and populated within</span></div>
<div class="line"><span class="comment">// NodesAsFloat3, and returned. Each array of 3 floats represents a Node&#39;s</span></div>
<div class="line"><span class="comment">// position within the Cartesian coordinate system. { x, y, z }</span></div>
<div class="line">std::vector&lt;std::array&lt;float, 3&gt;&gt; nodes_as_floats = graph.<a class="code" href="a01220.html#aeddbbec01c6354b7076f47f71fc1a220">NodesAsFloat3</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The two loops below will yield the same output</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> n : graph.<a class="code" href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; n.x &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; n.y &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; n.z &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> a : nodes_as_floats) {</div>
<div class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00378">378</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a7c2ea4fda7d310b500456ff14527bab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2ea4fda7d310b500456ff14527bab9">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="a01204.html">Edge</a> &gt; HF::SpatialStructures::Graph::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of all edges from <a class="el" href="a01224.html" title="A point in space with an ID.">Node</a> n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Parent of all edges to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of edges from node n. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::outofrange</td><td>n does not exist in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="a00296.html#_todo000034">Todo:</a></b></dt><dd>Should this just return an empty list instead of throwing? </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of</span></div>
<div class="line"><span class="comment">// std::vector&lt;Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.<a class="code" href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to</span></div>
<div class="line"><span class="comment">// GetUndirectedEdges. Any node that exists with graph can be passed to this</span></div>
<div class="line"><span class="comment">// member function to retrieve a vector of edges.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node = get_nodes[index];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note that if node does not exist within graph, that an exception will be thrown.</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Edge&gt; undirected_edges = graph[node];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// See a (node)-&gt;(child_node_0, child_node_1, ... child_node_n)</span></div>
<div class="line">std::cout &lt;&lt; node.<a class="code" href="a01224.html#a51c4642674d54d02b8600f7ffeb45670">getArray</a>() &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> e : undirected_edges) {</div>
<div class="line">    std::cout &lt;&lt; e.child.getArray() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00209">209</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a2710af2a75976862d7a235793567d2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2710af2a75976862d7a235793567d2f3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how many nodes are in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes in the graph. </dd></dl>
<p>Size is directly returned from <code>id_to_nodes.size()</code>. </p><div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01224.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed</span></div>
<div class="line"><span class="comment">// by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> id_count = graph.<a class="code" href="a01220.html#a2710af2a75976862d7a235793567d2f3">size</a>();          <span class="comment">// We retrieve the size of the node id count within graph (3)</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00170_source.html#l00024">24</a> of file <a class="el" href="a00170_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00122_source.html#l00020">HF::Pathfinding::BoostGraph::BoostGraph()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a77d4522c02692328c767ff439ca6511a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d4522c02692328c767ff439ca6511a">&#9670;&nbsp;</a></span>edge_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt;float, 1&gt; HF::SpatialStructures::Graph::edge_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The underlying CSR containing edge nformation. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00275">275</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<a id="ab6515ac2323a16e27adab7b20561a649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6515ac2323a16e27adab7b20561a649">&#9670;&nbsp;</a></span>id_to_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; HF::SpatialStructures::Graph::id_to_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps ids to indexes in ordered_nodes. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00273">273</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a4da5e288f03773d18053c82731369b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da5e288f03773d18053c82731369b2a">&#9670;&nbsp;</a></span>idmap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">robin_hood::unordered_map&lt;<a class="el" href="a01224.html">Node</a>, int&gt; HF::SpatialStructures::Graph::idmap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list of X,Y,Z positions to ids. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00274">274</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a1cbd600663187d7cf985e9b6e7cea73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbd600663187d7cf985e9b6e7cea73f">&#9670;&nbsp;</a></span>needs_compression</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::needs_compression = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, the CSR is inaccurate and requires compression. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00278">278</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<a id="aaab13304c641df6fdcd3662d5c54dc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab13304c641df6fdcd3662d5c54dc78">&#9670;&nbsp;</a></span>next_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::next_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The id for the next unique node. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00276">276</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a9c573322aa34d24211cdfe29033cdae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c573322aa34d24211cdfe29033cdae8">&#9670;&nbsp;</a></span>node_attr_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, <a class="el" href="a01220.html#a459ae9952e205951060473d2ade3078e">NodeAttributeValueMap</a>&gt; HF::SpatialStructures::Graph::node_attr_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="a01224.html" title="A point in space with an ID.">Node</a> attribute type : Map of node id to node attribute. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00280">280</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<a id="ad59ab7164b64e3d78b7032b28c2c6663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59ab7164b64e3d78b7032b28c2c6663">&#9670;&nbsp;</a></span>ordered_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a01224.html">Node</a>&gt; HF::SpatialStructures::Graph::ordered_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of nodes contained by the graph. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00272">272</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a1cf07c256da74c2a03f81b4977364e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf07c256da74c2a03f81b4977364e85">&#9670;&nbsp;</a></span>triplets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Triplet&lt;float&gt; &gt; HF::SpatialStructures::Graph::triplets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Edges to be converted to a CSR when <a class="el" href="a01220.html#a41cece77d0eee98df39ecc6d3a366ec8" title="Compress the graph to a CSR and enable the usage of several functions.">Graph::Compress()</a> is called. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00277">277</a> of file <a class="el" href="a00173_source.html">graph.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Cpp/spatialstructures/src/<a class="el" href="a00173_source.html">graph.h</a></li>
<li>Cpp/spatialstructures/src/<a class="el" href="a00170_source.html">graph.cpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aa00308_html_a6b23c0b2531c78f6d5049873c184f4f9a16de38737a9f8366e9b2042b4e9b6290"><div class="ttname"><a href="a00308.html#a6b23c0b2531c78f6d5049873c184f4f9a16de38737a9f8366e9b2042b4e9b6290">HF::SpatialStructures::COST_AGGREGATE::AVERAGE</a></div><div class="ttdeci">@ AVERAGE</div><div class="ttdoc">Average the cost of all edges.</div></div>
<div class="ttc" id="aa01220_html_aa70347b8a33b57c6f0a72d6eca4248d7"><div class="ttname"><a href="a01220.html#aa70347b8a33b57c6f0a72d6eca4248d7">HF::SpatialStructures::Graph::Nodes</a></div><div class="ttdeci">std::vector&lt; Node &gt; Nodes() const</div><div class="ttdoc">Get a list of nodes from the graph sorted by ID.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00057">graph.cpp:57</a></div></div>
<div class="ttc" id="aa01220_html_a3285be5da987692e0b3671f49d67d21b"><div class="ttname"><a href="a01220.html#a3285be5da987692e0b3671f49d67d21b">HF::SpatialStructures::Graph::AggregateGraph</a></div><div class="ttdeci">std::vector&lt; float &gt; AggregateGraph(COST_AGGREGATE agg_type, bool directed=true) const</div><div class="ttdoc">Summarize the costs of every outgoing edge for every node in the graph.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00158">graph.cpp:158</a></div></div>
<div class="ttc" id="aa01220_html_aeddbbec01c6354b7076f47f71fc1a220"><div class="ttname"><a href="a01220.html#aeddbbec01c6354b7076f47f71fc1a220">HF::SpatialStructures::Graph::NodesAsFloat3</a></div><div class="ttdeci">std::vector&lt; std::array&lt; float, 3 &gt; &gt; NodesAsFloat3() const</div><div class="ttdoc">Get a list of nodes as float arrays.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00378">graph.cpp:378</a></div></div>
<div class="ttc" id="aa01220_html_a4de020064d58c4ab376a26c30be863a3"><div class="ttname"><a href="a01220.html#a4de020064d58c4ab376a26c30be863a3">HF::SpatialStructures::Graph::hasKey</a></div><div class="ttdeci">bool hasKey(const Node &amp;n) const</div><div class="ttdoc">Determine if n exists in the graph.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00376">graph.cpp:376</a></div></div>
<div class="ttc" id="aa01220_html_aaab13304c641df6fdcd3662d5c54dc78"><div class="ttname"><a href="a01220.html#aaab13304c641df6fdcd3662d5c54dc78">HF::SpatialStructures::Graph::next_id</a></div><div class="ttdeci">int next_id</div><div class="ttdoc">The id for the next unique node.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00276">graph.h:276</a></div></div>
<div class="ttc" id="aa01220_html_a1cbd600663187d7cf985e9b6e7cea73f"><div class="ttname"><a href="a01220.html#a1cbd600663187d7cf985e9b6e7cea73f">HF::SpatialStructures::Graph::needs_compression</a></div><div class="ttdeci">bool needs_compression</div><div class="ttdoc">If true, the CSR is inaccurate and requires compression.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00278">graph.h:278</a></div></div>
<div class="ttc" id="aa01220_html_afccd105c93a826bde0457449f774fd04"><div class="ttname"><a href="a01220.html#afccd105c93a826bde0457449f774fd04">HF::SpatialStructures::Graph::GetCSRPointers</a></div><div class="ttdeci">CSRPtrs GetCSRPointers()</div><div class="ttdoc">Obtain the size of and pointers to the 3 arrays that comprise this graph's CSR. graph if it isn't com...</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00034">graph.cpp:34</a></div></div>
<div class="ttc" id="aa01220_html_a1cf07c256da74c2a03f81b4977364e85"><div class="ttname"><a href="a01220.html#a1cf07c256da74c2a03f81b4977364e85">HF::SpatialStructures::Graph::triplets</a></div><div class="ttdeci">std::vector&lt; Eigen::Triplet&lt; float &gt; &gt; triplets</div><div class="ttdoc">Edges to be converted to a CSR when Graph::Compress() is called.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00277">graph.h:277</a></div></div>
<div class="ttc" id="aa01220_html_a41cece77d0eee98df39ecc6d3a366ec8"><div class="ttname"><a href="a01220.html#a41cece77d0eee98df39ecc6d3a366ec8">HF::SpatialStructures::Graph::Compress</a></div><div class="ttdeci">void Compress()</div><div class="ttdoc">Compress the graph to a CSR and enable the usage of several functions.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00397">graph.cpp:397</a></div></div>
<div class="ttc" id="aa01220_html_a9f521e01db7e3c038ab2c1fac09b67df"><div class="ttname"><a href="a01220.html#a9f521e01db7e3c038ab2c1fac09b67df">HF::SpatialStructures::Graph::GetUndirectedEdges</a></div><div class="ttdeci">std::vector&lt; Edge &gt; GetUndirectedEdges(const Node &amp;N) const</div><div class="ttdoc">Get a list of all edges to and from node N.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00061">graph.cpp:61</a></div></div>
<div class="ttc" id="aa01224_html"><div class="ttname"><a href="a01224.html">HF::SpatialStructures::Node</a></div><div class="ttdoc">A point in space with an ID.</div><div class="ttdef"><b>Definition:</b> <a href="a00176_source.html#l00038">node.h:38</a></div></div>
<div class="ttc" id="aa01220_html_a1a26ebb794b444e2214cf0b0fed5a529"><div class="ttname"><a href="a01220.html#a1a26ebb794b444e2214cf0b0fed5a529">HF::SpatialStructures::Graph::GetEdges</a></div><div class="ttdeci">std::vector&lt; EdgeSet &gt; GetEdges() const</div><div class="ttdoc">Get every in the given graph as IDs.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00089">graph.cpp:89</a></div></div>
<div class="ttc" id="aa01220_html_a77d4522c02692328c767ff439ca6511a"><div class="ttname"><a href="a01220.html#a77d4522c02692328c767ff439ca6511a">HF::SpatialStructures::Graph::edge_matrix</a></div><div class="ttdeci">Eigen::SparseMatrix&lt; float, 1 &gt; edge_matrix</div><div class="ttdoc">The underlying CSR containing edge nformation.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00275">graph.h:275</a></div></div>
<div class="ttc" id="aa01220_html_af00121404a647b0d619f201cf9ebc797"><div class="ttname"><a href="a01220.html#af00121404a647b0d619f201cf9ebc797">HF::SpatialStructures::Graph::HasEdge</a></div><div class="ttdeci">bool HasEdge(const std::array&lt; float, 3 &gt; &amp;parent, const std::array&lt; float, 3 &gt; &amp;child, bool undirected=false) const</div><div class="ttdoc">Determine if the graph has an edge from parent to child.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00369">graph.cpp:369</a></div></div>
<div class="ttc" id="aa01224_html_a51c4642674d54d02b8600f7ffeb45670"><div class="ttname"><a href="a01224.html#a51c4642674d54d02b8600f7ffeb45670">HF::SpatialStructures::Node::getArray</a></div><div class="ttdeci">std::array&lt; float, 3 &gt; getArray() const</div><div class="ttdoc">Returns the x,y,z of this node as an array of 3 floats.</div><div class="ttdef"><b>Definition:</b> <a href="a01521_source.html#l00141">node.cpp:141</a></div></div>
<div class="ttc" id="aa00308_html_a6b23c0b2531c78f6d5049873c184f4f9"><div class="ttname"><a href="a00308.html#a6b23c0b2531c78f6d5049873c184f4f9">HF::SpatialStructures::COST_AGGREGATE</a></div><div class="ttdeci">COST_AGGREGATE</div><div class="ttdoc">Methods of aggregating the costs for edges for each node in the graph.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00023">graph.h:23</a></div></div>
<div class="ttc" id="aa01220_html_af59beedafb4af0ee99d54761e1c681fc"><div class="ttname"><a href="a01220.html#af59beedafb4af0ee99d54761e1c681fc">HF::SpatialStructures::Graph::getID</a></div><div class="ttdeci">int getID(const Node &amp;node) const</div><div class="ttdoc">Retrieve the ID for node in this graph.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00026">graph.cpp:26</a></div></div>
<div class="ttc" id="aa01220_html_afca147a681e4b39bc471e02d0f07eb37"><div class="ttname"><a href="a01220.html#afca147a681e4b39bc471e02d0f07eb37">HF::SpatialStructures::Graph::getOrAssignID</a></div><div class="ttdeci">int getOrAssignID(const Node &amp;input_node)</div><div class="ttdoc">Get the unique ID for this x, y, z position, assigning it an new one if it doesn't already exist</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00290">graph.cpp:290</a></div></div>
<div class="ttc" id="aa01220_html_a994dbd15119eb6548d2e15f4de4b88a6"><div class="ttname"><a href="a01220.html#a994dbd15119eb6548d2e15f4de4b88a6">HF::SpatialStructures::Graph::Clear</a></div><div class="ttdeci">void Clear()</div><div class="ttdoc">Clear all nodes and edges from the graph.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00417">graph.cpp:417</a></div></div>
<div class="ttc" id="aa01220_html_a794c342603cefb342fdc698ba539b25f"><div class="ttname"><a href="a01220.html#a794c342603cefb342fdc698ba539b25f">HF::SpatialStructures::Graph::NodeFromID</a></div><div class="ttdeci">Node NodeFromID(int id) const</div><div class="ttdoc">Retrieve the node that corresponds to id.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00055">graph.cpp:55</a></div></div>
<div class="ttc" id="aa01220_html"><div class="ttname"><a href="a01220.html">HF::SpatialStructures::Graph</a></div><div class="ttdoc">A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00268">graph.h:268</a></div></div>
<div class="ttc" id="aa01220_html_a2710af2a75976862d7a235793567d2f3"><div class="ttname"><a href="a01220.html#a2710af2a75976862d7a235793567d2f3">HF::SpatialStructures::Graph::size</a></div><div class="ttdeci">int size() const</div><div class="ttdoc">Determine how many nodes are in the graph.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00024">graph.cpp:24</a></div></div>
<div class="ttc" id="aa01220_html_a604a648f1f73d687ad4544d2ac163212"><div class="ttname"><a href="a01220.html#a604a648f1f73d687ad4544d2ac163212">HF::SpatialStructures::Graph::addEdge</a></div><div class="ttdeci">void addEdge(const Node &amp;parent, const Node &amp;child, float score=1.0f)</div><div class="ttdoc">Add a new edge to the graph from parent to child.</div><div class="ttdef"><b>Definition:</b> <a href="a00170_source.html#l00226">graph.cpp:226</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
