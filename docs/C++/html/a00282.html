<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Analysis: HF::Pathfinding Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00273.html">HF</a></li><li class="navelem"><a class="el" href="a00282.html">Pathfinding</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HF::Pathfinding Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Algorithms to find the shortest path between nodes in a <a class="el" href="a01199.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">HF::SpatialStructures::Graph</a>.  
<a href="a00282.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01139.html">BoostGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A graph usable with the BoostGraphLibrary.  <a href="a01139.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01147.html">BoostGraphDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleter for the <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a>.  <a href="a01147.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01143.html">DistPred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single row of a distance and predecessor matrix.  <a href="a01143.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01131"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a01131">Edge_Cost</a></td></tr>
<tr class="memdesc:a01131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data stored for every edge in the <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a>.  <a href="a00282.html#a01131">More...</a><br /></td></tr>
<tr class="separator:a01131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01135"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a01135">vertex_data</a></td></tr>
<tr class="memdesc:a01135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data stored for every vertex in the <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a>.  <a href="a00282.html#a01135">More...</a><br /></td></tr>
<tr class="separator:a01135"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9314d552e0a8092644fa080c9945bd25"><td class="memItemLeft" align="right" valign="top">typedef boost::compressed_sparse_row_graph&lt; boost::directedS, <a class="el" href="a00282.html#a01135">vertex_data</a>, <a class="el" href="a00282.html#a01131">Edge_Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a9314d552e0a8092644fa080c9945bd25">graph_t</a></td></tr>
<tr class="memdesc:a9314d552e0a8092644fa080c9945bd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of graph held by the <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a>.  <a href="a00282.html#a9314d552e0a8092644fa080c9945bd25">More...</a><br /></td></tr>
<tr class="separator:a9314d552e0a8092644fa080c9945bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4215affd9d683505478f5b7dcc1804"><td class="memItemLeft" align="right" valign="top">typedef boost::graph_traits&lt; <a class="el" href="a00282.html#a9314d552e0a8092644fa080c9945bd25">graph_t</a> &gt;::<a class="el" href="a00282.html#aff4215affd9d683505478f5b7dcc1804">vertex_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#aff4215affd9d683505478f5b7dcc1804">vertex_descriptor</a></td></tr>
<tr class="memdesc:aff4215affd9d683505478f5b7dcc1804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick alias to shorten the typename of vertex descriptors for our graph_t type. /summary&gt;  <a href="a00282.html#aff4215affd9d683505478f5b7dcc1804">More...</a><br /></td></tr>
<tr class="separator:aff4215affd9d683505478f5b7dcc1804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc378c1e475802d96758aaef12d33dbc"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#acc378c1e475802d96758aaef12d33dbc">pair</a></td></tr>
<tr class="memdesc:acc378c1e475802d96758aaef12d33dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorten std::pair to simplify graph construction.  <a href="a00282.html#acc378c1e475802d96758aaef12d33dbc">More...</a><br /></td></tr>
<tr class="separator:acc378c1e475802d96758aaef12d33dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a977e4c93a977ab4e9e784d1e6fec79f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01215.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a977e4c93a977ab4e9e784d1e6fec79f4">ConstructShortestPathFromPred</a> (int start, int end, const std::vector&lt; size_t &gt; &amp;pred, const std::vector&lt; float &gt; &amp;distances)</td></tr>
<tr class="memdesc:a977e4c93a977ab4e9e784d1e6fec79f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the shortest path from start to end using the given predecessor and distance vectors.  <a href="a00282.html#a977e4c93a977ab4e9e784d1e6fec79f4">More...</a><br /></td></tr>
<tr class="separator:a977e4c93a977ab4e9e784d1e6fec79f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322ac32effd41c99359b82df0890e34a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01215.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a322ac32effd41c99359b82df0890e34a">ConstructShortestPathFromPred</a> (int start, int end, const <a class="el" href="a01143.html">DistPred</a> &amp;dist_pred)</td></tr>
<tr class="memdesc:a322ac32effd41c99359b82df0890e34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to call this with a distPred instead of the raw arrays.  <a href="a00282.html#a322ac32effd41c99359b82df0890e34a">More...</a><br /></td></tr>
<tr class="separator:a322ac32effd41c99359b82df0890e34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6490539108da057db2486295458886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01143.html">DistPred</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a9f6490539108da057db2486295458886">BuildDistanceAndPredecessor</a> (const <a class="el" href="a00282.html#a9314d552e0a8092644fa080c9945bd25">graph_t</a> &amp;g, int id)</td></tr>
<tr class="memdesc:a9f6490539108da057db2486295458886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a row of the distance and predecessor matrices for the node at id.  <a href="a00282.html#a9f6490539108da057db2486295458886">More...</a><br /></td></tr>
<tr class="separator:a9f6490539108da057db2486295458886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d06b1c4bd84f4d0a7519ea0e96ff02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01215.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a47d06b1c4bd84f4d0a7519ea0e96ff02">FindPath</a> (<a class="el" href="a01139.html">BoostGraph</a> *bg, int start_id, int end_id)</td></tr>
<tr class="memdesc:a47d06b1c4bd84f4d0a7519ea0e96ff02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a path between points A and B using Dijkstra's Shortest Path algorithm.  <a href="a00282.html#a47d06b1c4bd84f4d0a7519ea0e96ff02">More...</a><br /></td></tr>
<tr class="separator:a47d06b1c4bd84f4d0a7519ea0e96ff02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15badb9d0a17849de7b21105605c9c91"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="a01215.html">Path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a15badb9d0a17849de7b21105605c9c91">FindPaths</a> (<a class="el" href="a01139.html">BoostGraph</a> *bg, const std::vector&lt; int &gt; &amp;start_points, const std::vector&lt; int &gt; &amp;end_points)</td></tr>
<tr class="memdesc:a15badb9d0a17849de7b21105605c9c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a path from every id in start_ids to the matching end node in end_ids.  <a href="a00282.html#a15badb9d0a17849de7b21105605c9c91">More...</a><br /></td></tr>
<tr class="separator:a15badb9d0a17849de7b21105605c9c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417084c97d0672af2da7739157a9d8c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a417084c97d0672af2da7739157a9d8c0">InsertPathsIntoArray</a> (const <a class="el" href="a01139.html">BoostGraph</a> *bg, const std::vector&lt; int &gt; &amp;start_points, const std::vector&lt; int &gt; &amp;end_points, <a class="el" href="a01215.html">HF::SpatialStructures::Path</a> **out_paths, <a class="el" href="a01211.html">HF::SpatialStructures::PathMember</a> **out_path_members, int *out_sizes)</td></tr>
<tr class="memdesc:a417084c97d0672af2da7739157a9d8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special version of FindPaths optimized for the C_Interface.  <a href="a00282.html#a417084c97d0672af2da7739157a9d8c0">More...</a><br /></td></tr>
<tr class="separator:a417084c97d0672af2da7739157a9d8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee466bf2324daa4b600cc59c90e78977"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="a01139.html">BoostGraph</a>, <a class="el" href="a01147.html">BoostGraphDeleter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#aee466bf2324daa4b600cc59c90e78977">CreateBoostGraph</a> (const <a class="el" href="a01199.html">HF::SpatialStructures::Graph</a> &amp;g)</td></tr>
<tr class="memdesc:aee466bf2324daa4b600cc59c90e78977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new boost graph from a <a class="el" href="a00276.html" title="Contains standard fundamental data structures for representing space used throughout HumanFactors.">HF::SpatialStructures</a>:Graph.  <a href="a00282.html#aee466bf2324daa4b600cc59c90e78977">More...</a><br /></td></tr>
<tr class="separator:aee466bf2324daa4b600cc59c90e78977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336118692fd29dd27f8825ec5bb16b56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01215.html">HF::SpatialStructures::Path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html#a336118692fd29dd27f8825ec5bb16b56">FindAllPaths</a> (<a class="el" href="a01139.html">BoostGraph</a> *bg)</td></tr>
<tr class="memdesc:a336118692fd29dd27f8825ec5bb16b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a path from every node to every node (NOTE: Not implemented yet.)  <a href="a00282.html#a336118692fd29dd27f8825ec5bb16b56">More...</a><br /></td></tr>
<tr class="separator:a336118692fd29dd27f8825ec5bb16b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Algorithms to find the shortest path between nodes in a <a class="el" href="a01199.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">HF::SpatialStructures::Graph</a>. </p>
<p>This namespace utilizes pathfinding algorithms from Boost internally.To make use of the algorithms in this namespace, first you must create a <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a> from the <a class="el" href="a01199.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">HF::SpatialStructures::Graph</a> you want to find paths in. <br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01215.html" title="A collection of nodes that form a path.">HF::SpatialStructures::Path</a> for a description of the path datatype. </dd>
<dd>
<a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a> for details on generating a <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a> from a <a class="el" href="a01199.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">HF::SpatialStructures::Graph</a>. </dd></dl>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="a01131" id="a01131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01131">&#9670;&nbsp;</a></span>HF::Pathfinding::Edge_Cost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct HF::Pathfinding::Edge_Cost</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data stored for every edge in the <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a>. </p>
<p>Each edge in the graph only stores its weight as a float. </p>

<p class="definition">Definition at line <a class="el" href="a00110_source.html#l00099">99</a> of file <a class="el" href="a00110_source.html">boost_graph.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aefea62ffa2c7078ac7d9f2eefaa96e07"></a>float</td>
<td class="fieldname">
weight</td>
<td class="fielddoc">
Cost of traversing this edge. </td></tr>
</table>

</div>
</div>
<a name="a01135" id="a01135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01135">&#9670;&nbsp;</a></span>HF::Pathfinding::vertex_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct HF::Pathfinding::vertex_data</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data stored for every vertex in the <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a>. </p>
<p>Every vertex stores in the graph stores it's index p and a unique double d.</p>
<dl class="todo"><dt><b><a class="el" href="a00264.html#_todo000014">Todo:</a></b></dt><dd>Is the double d needed?</dd></dl>

<p class="definition">Definition at line <a class="el" href="a00110_source.html#l00111">111</a> of file <a class="el" href="a00110_source.html">boost_graph.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a3f23d92f8d538033cf4096201083944e"></a>double</td>
<td class="fieldname">
d</td>
<td class="fielddoc">
Unknown may have been used for the colormap. </td></tr>
<tr><td class="fieldtype">
<a id="a77df9b09cb03d4029237496b485d77e3"></a>graph_traits&lt; compressed_sparse_row_graph&lt; directedS &gt; &gt;::<a class="el" href="a00282.html#aff4215affd9d683505478f5b7dcc1804">vertex_descriptor</a></td>
<td class="fieldname">
p</td>
<td class="fielddoc">
The index of a vertex in the CSR. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9314d552e0a8092644fa080c9945bd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9314d552e0a8092644fa080c9945bd25">&#9670;&nbsp;</a></span>graph_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::compressed_sparse_row_graph&lt; boost::directedS, <a class="el" href="a00282.html#a01135">vertex_data</a>, <a class="el" href="a00282.html#a01131">Edge_Cost</a> &gt; <a class="el" href="a00282.html#a9314d552e0a8092644fa080c9945bd25">HF::Pathfinding::graph_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of graph held by the <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a>. </p>
<p>Set the graph as directed, store <a class="el" href="a00282.html#a01135" title="Data stored for every vertex in the BoostGraph.">vertex_data</a> for each vertex store <a class="el" href="a00282.html#a01131" title="Data stored for every edge in the BoostGraph.">Edge_Cost</a> for each edge.</p>
<dl class="section remark"><dt>Remarks</dt><dd>By changing the contents of this typedef, you can change the type of graph that the <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a> holds, and the the type of data stored for each vertex or edge.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00282.html#a01135" title="Data stored for every vertex in the BoostGraph.">vertex_data</a> for info on what every vertex in the graph holds. </dd>
<dd>
<a class="el" href="a00282.html#a01131" title="Data stored for every edge in the BoostGraph.">Edge_Cost</a> for info on what every edge in the graph holds. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00110_source.html#l00135">135</a> of file <a class="el" href="a00110_source.html">boost_graph.h</a>.</p>

</div>
</div>
<a id="acc378c1e475802d96758aaef12d33dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc378c1e475802d96758aaef12d33dbc">&#9670;&nbsp;</a></span>pair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;int, int&gt; <a class="el" href="a00282.html#acc378c1e475802d96758aaef12d33dbc">HF::Pathfinding::pair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorten std::pair to simplify graph construction. </p>

<p class="definition">Definition at line <a class="el" href="a00110_source.html#l00142">142</a> of file <a class="el" href="a00110_source.html">boost_graph.h</a>.</p>

</div>
</div>
<a id="aff4215affd9d683505478f5b7dcc1804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4215affd9d683505478f5b7dcc1804">&#9670;&nbsp;</a></span>vertex_descriptor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::graph_traits&lt; <a class="el" href="a00282.html#a9314d552e0a8092644fa080c9945bd25">graph_t</a> &gt;::<a class="el" href="a00282.html#aff4215affd9d683505478f5b7dcc1804">vertex_descriptor</a> <a class="el" href="a00282.html#aff4215affd9d683505478f5b7dcc1804">HF::Pathfinding::vertex_descriptor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quick alias to shorten the typename of vertex descriptors for our graph_t type. /summary&gt; </p>

<p class="definition">Definition at line <a class="el" href="a00110_source.html#l00139">139</a> of file <a class="el" href="a00110_source.html">boost_graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9f6490539108da057db2486295458886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6490539108da057db2486295458886">&#9670;&nbsp;</a></span>BuildDistanceAndPredecessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01143.html">DistPred</a> HF::Pathfinding::BuildDistanceAndPredecessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00282.html#a9314d552e0a8092644fa080c9945bd25">graph_t</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a row of the distance and predecessor matrices for the node at id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Graph to build the predecessor and distance matrices for. </td></tr>
    <tr><td class="paramname">id</td><td>The node to generate the predecessor and distance matrix for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="a01143.html" title="A single row of a distance and predecessor matrix.">DistPred</a> containing the distance and predecessor arrays for ID in g. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00113_source.html#l00145">145</a> of file <a class="el" href="a00113_source.html">path_finder.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00113_source.html#l00048">HF::Pathfinding::DistPred::distance</a>, and <a class="el" href="a00113_source.html#l00049">HF::Pathfinding::DistPred::predecessor</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00113_source.html#l00165">FindPath()</a>, <a class="el" href="a00113_source.html#l00177">FindPaths()</a>, and <a class="el" href="a00113_source.html#l00200">InsertPathsIntoArray()</a>.</p>

</div>
</div>
<a id="a322ac32effd41c99359b82df0890e34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322ac32effd41c99359b82df0890e34a">&#9670;&nbsp;</a></span>ConstructShortestPathFromPred() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01215.html">Path</a> HF::Pathfinding::ConstructShortestPathFromPred </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01143.html">DistPred</a> &amp;&#160;</td>
          <td class="paramname"><em>dist_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload to call this with a distPred instead of the raw arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Starting point of the path to generate. </td></tr>
    <tr><td class="paramname">end</td><td>End point of the path to generate. </td></tr>
    <tr><td class="paramname">dist_pred</td><td><a class="el" href="a01143.html" title="A single row of a distance and predecessor matrix.">DistPred</a> containing the predecessor and distance matricies start. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00113_source.html#l00132">132</a> of file <a class="el" href="a00113_source.html">path_finder.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00113_source.html#l00048">HF::Pathfinding::DistPred::distance</a>, and <a class="el" href="a00113_source.html#l00049">HF::Pathfinding::DistPred::predecessor</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00113_source.html#l00165">FindPath()</a>, <a class="el" href="a00113_source.html#l00177">FindPaths()</a>, and <a class="el" href="a00113_source.html#l00200">InsertPathsIntoArray()</a>.</p>

</div>
</div>
<a id="a977e4c93a977ab4e9e784d1e6fec79f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977e4c93a977ab4e9e784d1e6fec79f4">&#9670;&nbsp;</a></span>ConstructShortestPathFromPred() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01215.html">Path</a> HF::Pathfinding::ConstructShortestPathFromPred </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the shortest path from start to end using the given predecessor and distance vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>ID of the starting point. </td></tr>
    <tr><td class="paramname">end</td><td>ID of the end point. </td></tr>
    <tr><td class="paramname">pred</td><td>Predecessor matrix for the start node. </td></tr>
    <tr><td class="paramname">distances</td><td>Distance matrix for pred</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="a00264.html#_todo000015">Todo:</a></b></dt><dd>Replace exception with an assert statment. It shouldn't be triggered unless there's a problem with this algorithm? </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00113_source.html#l00077">77</a> of file <a class="el" href="a00113_source.html">path_finder.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00158_source.html#l00012">HF::SpatialStructures::Path::AddNode()</a>, <a class="el" href="a00158_source.html#l00024">HF::SpatialStructures::Path::Reverse()</a>, and <a class="el" href="a00158_source.html#l00020">HF::SpatialStructures::Path::size()</a>.</p>

</div>
</div>
<a id="aee466bf2324daa4b600cc59c90e78977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee466bf2324daa4b600cc59c90e78977">&#9670;&nbsp;</a></span>CreateBoostGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="a01139.html">BoostGraph</a>, <a class="el" href="a01147.html">BoostGraphDeleter</a> &gt; HF::Pathfinding::CreateBoostGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01199.html">HF::SpatialStructures::Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new boost graph from a <a class="el" href="a00276.html" title="Contains standard fundamental data structures for representing space used throughout HumanFactors.">HF::SpatialStructures</a>:Graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph to create a <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a> from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to point to the new <a class="el" href="a01139.html" title="A graph usable with the BoostGraphLibrary.">BoostGraph</a> created from the HFGraph.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This returns a pointer since it insulates the caller from needing to import Boost, which is extremely useful for the C_Interface since its clients will not need to use boost at all and it doesn't need to go through the trouble of compiling all of the boost library (again). A unique pointer was chosen here so the caller doesn't need to worry about manually deleting the returned boost graph at a later point.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;path_finder.h&quot;, #include &quot;boost_graph.h&quot;, #include &quot;node.h&quot;,</span></div>
<div class="line"><span class="comment">// #include &quot;graph.h&quot;, and #include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// For this example, we must have a BoostGraph instance to use with</span></div>
<div class="line"><span class="comment">// BoostGraphDeleter. In order to create a BoostGraph, we must first create a Graph</span></div>
<div class="line"><span class="comment">// instance first. We must prepare the nodes, their edges, and the weights</span></div>
<div class="line"><span class="comment">// (distances) of each edge.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01203.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01203.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01203.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code" href="a01199.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now we can create a smart pointer to a BoostGraph Note the type of boostGraph -</span></div>
<div class="line"><span class="comment">// it is a std::unique_ptr&lt;HF::Pathfinding::BoostGraph,</span></div>
<div class="line"><span class="comment">// HF::Pathfinding::BoostGraphDeleter&gt;. Use the auto keyword for type inference, or</span></div>
<div class="line"><span class="comment">// your choice of using statements/typedef to make the use of the type described</span></div>
<div class="line"><span class="comment">// above easier.</span></div>
<div class="line"><span class="keyword">auto</span> boostGraph = <a class="code" href="a00282.html#aee466bf2324daa4b600cc59c90e78977">CreateBoostGraph</a>(graph);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00113_source.html#l00267">267</a> of file <a class="el" href="a00113_source.html">path_finder.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00233_source.html#l00020">CreatePath()</a>, and <a class="el" href="a00233_source.html#l00046">CreatePaths()</a>.</p>

</div>
</div>
<a id="a336118692fd29dd27f8825ec5bb16b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336118692fd29dd27f8825ec5bb16b56">&#9670;&nbsp;</a></span>FindAllPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a01215.html">HF::SpatialStructures::Path</a>&gt; HF::Pathfinding::FindAllPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01139.html">BoostGraph</a> *&#160;</td>
          <td class="paramname"><em>bg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a path from every node to every node (NOTE: Not implemented yet.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bg</td><td>Graph to generate all paths for. traversal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of every path that could be generated from this graph. </dd></dl>
<p>Calculate a permutation for every combination of nodes in the graph, then call FindPaths, OR Write a unique function inspired by FindPaths that just runs through a range of paths.</p>
<dl class="section remark"><dt>Remarks</dt><dd>May benefit from using an algorithm optimized for this like <a href="https://www.boost.org/doc/libs/1_73_0/libs/graph/doc/floyd_warshall_shortest.html">https://www.boost.org/doc/libs/1_73_0/libs/graph/doc/floyd_warshall_shortest.html</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_memory</td><td>if the memory required is too large.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This will allocate a large amount of memory. Ensure that this won't run out of memory when called, or be prepared to catch an out of memory exception. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00264.html#_todo000017">Todo:</a></b></dt><dd>Implement this function to the specifications outlined here. </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// NOTE: HF::Pathfinding::FindAllPaths is not implemented yet.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// be sure to #include &quot;path_finder.h&quot;, #include &quot;boost_graph.h&quot;, and #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a Graph g, and compress it.</span></div>
<div class="line"><a class="code" href="a01199.html">HF::SpatialStructures::Graph</a> g;</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(0, 1, 1);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(0, 2, 2);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(1, 3, 3);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(2, 4, 1);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(3, 4, 5);</div>
<div class="line">g.<a class="code" href="a01199.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a boostGraph from g</span></div>
<div class="line"><span class="keyword">auto</span> boostGraph = <a class="code" href="a00282.html#aee466bf2324daa4b600cc59c90e78977">HF::Pathfinding::CreateBoostGraph</a>(g);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the path from node (id 0) to node (id 4)</span></div>
<div class="line"><span class="keyword">auto</span> all_paths = <a class="code" href="a00282.html#a336118692fd29dd27f8825ec5bb16b56">HF::Pathfinding::FindAllPaths</a>(boostGraph.get(), 0, 4);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// all_paths will contain all shortest paths for [node 0, node 4]</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a47d06b1c4bd84f4d0a7519ea0e96ff02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d06b1c4bd84f4d0a7519ea0e96ff02">&#9670;&nbsp;</a></span>FindPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01215.html">HF::SpatialStructures::Path</a> HF::Pathfinding::FindPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01139.html">BoostGraph</a> *&#160;</td>
          <td class="paramname"><em>bg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a path between points A and B using Dijkstra's Shortest Path algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bg</td><td>The boost graph containing edges/nodes. </td></tr>
    <tr><td class="paramname">start_id</td><td>ID of the starting node. </td></tr>
    <tr><td class="paramname">end_id</td><td>ID of the ending node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shortest path between A and B. </dd></dl>
<p>To find the path, A row of the predecessor matrix is generated for node a, then followed until node B is reached. This algorithm is implemented using dijkstra_shortest_path from the BoostGraphLibrary <a href="https://www.boost.org/doc/libs/1_73_0/libs/graph/doc/dijkstra_shortest_paths_no_color_map.html">https://www.boost.org/doc/libs/1_73_0/libs/graph/doc/dijkstra_shortest_paths_no_color_map.html</a></p>
<dl class="section note"><dt>Note</dt><dd>Use FindPaths for multiple paths as it's able to reuse a lot of work compared to running this in a loop.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;path_finder.h&quot;, #include &quot;boost_graph.h&quot;, and #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a Graph g, and compress it.</span></div>
<div class="line"><a class="code" href="a01199.html">HF::SpatialStructures::Graph</a> g;</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(0, 1, 1);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(0, 2, 2);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(1, 3, 3);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(2, 4, 1);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(3, 4, 5);</div>
<div class="line">g.<a class="code" href="a01199.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a boostGraph from g</span></div>
<div class="line"><span class="keyword">auto</span> boostGraph = <a class="code" href="a00282.html#aee466bf2324daa4b600cc59c90e78977">HF::Pathfinding::CreateBoostGraph</a>(g);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the path from node (id 0) to node (id 3)</span></div>
<div class="line"><a class="code" href="a01215.html">HF::SpatialStructures::Path</a> path = <a class="code" href="a00282.html#a47d06b1c4bd84f4d0a7519ea0e96ff02">HF::Pathfinding::FindPath</a>(boostGraph.get(), 0, 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Print the nodes along the shortest path</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Shortest path from node id 0 to node id 3:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> p : path.<a class="code" href="a01215.html#a864cebbf4e5d7c135c501a63d42f8708">members</a>) {</div>
<div class="line">    std::cout &lt;&lt; p.node &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00113_source.html#l00165">165</a> of file <a class="el" href="a00113_source.html">path_finder.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00113_source.html#l00145">BuildDistanceAndPredecessor()</a>, <a class="el" href="a00113_source.html#l00132">ConstructShortestPathFromPred()</a>, and <a class="el" href="a00110_source.html#l00167">HF::Pathfinding::BoostGraph::g</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00233_source.html#l00020">CreatePath()</a>.</p>

</div>
</div>
<a id="a15badb9d0a17849de7b21105605c9c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15badb9d0a17849de7b21105605c9c91">&#9670;&nbsp;</a></span>FindPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01215.html">HF::SpatialStructures::Path</a> &gt; HF::Pathfinding::FindPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01139.html">BoostGraph</a> *&#160;</td>
          <td class="paramname"><em>bg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>end_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a path from every id in start_ids to the matching end node in end_ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bg</td><td>The boost graph containing edges/nodes. </td></tr>
    <tr><td class="paramname">start_points</td><td>Ordered list of starting points. </td></tr>
    <tr><td class="paramname">end_points</td><td>Ordered list of ending points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ordered array of paths matching the order of the pairs of start_id and end_id. Paths that could not be generated will be returned as paths with no nodes.</dd></dl>
<p>More efficient than calling FindPath manually in a loop. Sorts paths by starting point, calculates only one predecessor matrix per unique starting point, then finds a path for every pair.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Length of start_points must match that of end_points.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00264.html#_todo000016">Todo:</a></b></dt><dd>This isn't in parallel! Can be implemented using a similar approach to InsertPathsIntoArray. </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;path_finder.h&quot;, #include &quot;boost_graph.h&quot;, and #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a Graph g, and compress it.</span></div>
<div class="line"><a class="code" href="a01199.html">HF::SpatialStructures::Graph</a> g;</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(0, 1, 1);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(0, 2, 2);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(1, 3, 3);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(2, 4, 1);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(3, 4, 5);</div>
<div class="line">g.<a class="code" href="a01199.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a boostGraph from g</span></div>
<div class="line"><span class="keyword">auto</span> boostGraph = <a class="code" href="a00282.html#aee466bf2324daa4b600cc59c90e78977">HF::Pathfinding::CreateBoostGraph</a>(g);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare the parents and children vectors -- We will be searching for the shortest</span></div>
<div class="line"><span class="comment">// path from node 0 to node 3, as well as the shortest path from node 0 to node 4.</span></div>
<div class="line">std::vector&lt;int&gt; parents = { 0, 0 };</div>
<div class="line">std::vector&lt;int&gt; children = { 3, 4 };</div>
<div class="line"> </div>
<div class="line">std::vector&lt;HF::SpatialStructures::Path&gt; paths</div>
<div class="line">    = <a class="code" href="a00282.html#a15badb9d0a17849de7b21105605c9c91">HF::Pathfinding::FindPaths</a>(boostGraph.get(), parents, children);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the shortest paths, which are already stored in paths</span></div>
<div class="line"><span class="keyword">auto</span> path_0_3 = paths[0];</div>
<div class="line"><span class="keyword">auto</span> path_0_4 = paths[1];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Print the shortest path from node 0 to node 3</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Shortest path from node id 0 to node id 3:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> p : path_0_3.members) {</div>
<div class="line">    std::cout &lt;&lt; p.node &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Print the shortest path from node 0 to node 4</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Shortest path from node id 0 to node id 4:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> p : path_0_4.members) {</div>
<div class="line">    std::cout &lt;&lt; p.node &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00113_source.html#l00177">177</a> of file <a class="el" href="a00113_source.html">path_finder.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00113_source.html#l00145">BuildDistanceAndPredecessor()</a>, <a class="el" href="a00113_source.html#l00132">ConstructShortestPathFromPred()</a>, and <a class="el" href="a00110_source.html#l00167">HF::Pathfinding::BoostGraph::g</a>.</p>

</div>
</div>
<a id="a417084c97d0672af2da7739157a9d8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417084c97d0672af2da7739157a9d8c0">&#9670;&nbsp;</a></span>InsertPathsIntoArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::Pathfinding::InsertPathsIntoArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01139.html">BoostGraph</a> *&#160;</td>
          <td class="paramname"><em>bg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>end_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01215.html">HF::SpatialStructures::Path</a> **&#160;</td>
          <td class="paramname"><em>out_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01211.html">HF::SpatialStructures::PathMember</a> **&#160;</td>
          <td class="paramname"><em>out_path_members</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A special version of FindPaths optimized for the C_Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bg</td><td>Boost graph to generate paths in </td></tr>
    <tr><td class="paramname">start_points</td><td>An ordered list of start points to generate paths from. </td></tr>
    <tr><td class="paramname">end_points</td><td>An ordered list of end points to generate paths to. </td></tr>
    <tr><td class="paramname">out_paths</td><td>Location for the the path pointer array to be created. Paths that could not be generated will be left as null pointers. </td></tr>
    <tr><td class="paramname">out_path_members</td><td>Location for the pathmember pointer array will be created. All path member pointers will point to the PathMembers of the Path in paths at the same location. Paths that could not be generated will be left as null pointers. </td></tr>
    <tr><td class="paramname">out_sizes</td><td>Output raw_array of integers that will cntain the length of every path in path_members. Paths that could not be generated will be left with a length of zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The length of start_ids must match the length of end_ids.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) out_path_members will point to a vector of pointers to vectors of PathMembers with an element for every path. </dd>
<dd>
2) out_paths will point to a vector of pointers to paths with an element for every path. </dd>
<dd>
3) out_sizes will point to an array of integers containing the size of every path in out_paths</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Usually the C-Interface is able to simply wrap existing functions with minimal code to make them accessible to exernal callers, however in this specific situation there were real performance gains to be found by implementing this function directly in HF::PathFinding itself. It's efficent and safe for that purpose, but <a class="el" href="a00282.html#a15badb9d0a17849de7b21105605c9c91">FindPaths</a> should be preferred outside of that context since this function can be quite dangerous if not handled properly.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The caller is responsible for freeing all of the memory allocated in out_paths and out_sizes. The contents of out_path_members will automatically be deleted when the path they belong to is deleted. Do not try to manually delete out_path_members or the path that owns it will throw a null pointer exception when it is deleted.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;path_finder.h&quot;, #include &quot;boost_graph.h&quot;, and #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a Graph g, and compress it.</span></div>
<div class="line"><a class="code" href="a01199.html">HF::SpatialStructures::Graph</a> g;</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(0, 1, 1);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(0, 2, 2);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(1, 3, 3);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(2, 4, 1);</div>
<div class="line">g.<a class="code" href="a01199.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(3, 4, 5);</div>
<div class="line">g.<a class="code" href="a01199.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a boostGraph from g</span></div>
<div class="line"><span class="keyword">auto</span> boostGraph = <a class="code" href="a00282.html#aee466bf2324daa4b600cc59c90e78977">HF::Pathfinding::CreateBoostGraph</a>(g);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare the parents and children vectors -- We will be searching for the shortest</span></div>
<div class="line"><span class="comment">// path from node 0 to node 3, as well as the shortest path from node 0 to node 4.</span></div>
<div class="line">std::vector&lt;int&gt; parents = { 0, 0 };</div>
<div class="line">std::vector&lt;int&gt; children = { 3, 4 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create smart pointers to hold Path, PathMember and sizes</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> MAX_SIZE = 4;</div>
<div class="line">std::unique_ptr&lt;HF::SpatialStructures::Path[]&gt; result_paths(<span class="keyword">new</span> Path[MAX_SIZE]);</div>
<div class="line">std::unique_ptr&lt;HF::SpatialStructures::PathMember[]&gt; result_path_members(<span class="keyword">new</span> PathMember[MAX_SIZE]);</div>
<div class="line">std::unique_ptr&lt;int[]&gt; result_sizes(<span class="keyword">new</span> <span class="keywordtype">int</span>[MAX_SIZE]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve raw pointers so their addresses can be passed to InsertPathsIntoArray</span></div>
<div class="line"><a class="code" href="a01215.html">HF::SpatialStructures::Path</a>* ppath = result_paths.get();</div>
<div class="line"><a class="code" href="a01211.html">HF::SpatialStructures::PathMember</a>* pmembers = result_path_members.get();</div>
<div class="line"><span class="keywordtype">int</span>* psizes = result_sizes.get();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use InsertPathsIntoArray</span></div>
<div class="line"><a class="code" href="a00282.html#a417084c97d0672af2da7739157a9d8c0">HF::Pathfinding::InsertPathsIntoArray</a>(boostGraph.get(), parents, children, &amp;ppath, &amp;pmembers, psizes);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00113_source.html#l00200">200</a> of file <a class="el" href="a00113_source.html">path_finder.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00113_source.html#l00145">BuildDistanceAndPredecessor()</a>, <a class="el" href="a00113_source.html#l00132">ConstructShortestPathFromPred()</a>, <a class="el" href="a00110_source.html#l00167">HF::Pathfinding::BoostGraph::g</a>, <a class="el" href="a00158_source.html#l00056">HF::SpatialStructures::Path::GetPMPointer()</a>, and <a class="el" href="a00158_source.html#l00020">HF::SpatialStructures::Path::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00233_source.html#l00046">CreatePaths()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aa01203_html"><div class="ttname"><a href="a01203.html">HF::SpatialStructures::Node</a></div><div class="ttdoc">A point in space with an ID.</div><div class="ttdef"><b>Definition:</b> <a href="a00155_source.html#l00038">node.h:38</a></div></div>
<div class="ttc" id="aa00282_html_a15badb9d0a17849de7b21105605c9c91"><div class="ttname"><a href="a00282.html#a15badb9d0a17849de7b21105605c9c91">HF::Pathfinding::FindPaths</a></div><div class="ttdeci">vector&lt; Path &gt; FindPaths(BoostGraph *bg, const vector&lt; int &gt; &amp;start_points, const vector&lt; int &gt; &amp;end_points)</div><div class="ttdoc">Find a path from every id in start_ids to the matching end node in end_ids.</div><div class="ttdef"><b>Definition:</b> <a href="a00113_source.html#l00177">path_finder.cpp:177</a></div></div>
<div class="ttc" id="aa01199_html"><div class="ttname"><a href="a01199.html">HF::SpatialStructures::Graph</a></div><div class="ttdoc">A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.</div><div class="ttdef"><b>Definition:</b> <a href="a00152_source.html#l00096">graph.h:96</a></div></div>
<div class="ttc" id="aa00282_html_a336118692fd29dd27f8825ec5bb16b56"><div class="ttname"><a href="a00282.html#a336118692fd29dd27f8825ec5bb16b56">HF::Pathfinding::FindAllPaths</a></div><div class="ttdeci">std::vector&lt; HF::SpatialStructures::Path &gt; FindAllPaths(BoostGraph *bg)</div><div class="ttdoc">Find a path from every node to every node (NOTE: Not implemented yet.)</div></div>
<div class="ttc" id="aa00282_html_a417084c97d0672af2da7739157a9d8c0"><div class="ttname"><a href="a00282.html#a417084c97d0672af2da7739157a9d8c0">HF::Pathfinding::InsertPathsIntoArray</a></div><div class="ttdeci">void InsertPathsIntoArray(const BoostGraph *bg, const std::vector&lt; int &gt; &amp;start_points, const std::vector&lt; int &gt; &amp;end_points, HF::SpatialStructures::Path **out_paths, HF::SpatialStructures::PathMember **out_path_members, int *out_sizes)</div><div class="ttdoc">A special version of FindPaths optimized for the C_Interface.</div><div class="ttdef"><b>Definition:</b> <a href="a00113_source.html#l00200">path_finder.cpp:200</a></div></div>
<div class="ttc" id="aa01215_html_a864cebbf4e5d7c135c501a63d42f8708"><div class="ttname"><a href="a01215.html#a864cebbf4e5d7c135c501a63d42f8708">HF::SpatialStructures::Path::members</a></div><div class="ttdeci">std::vector&lt; PathMember &gt; members</div><div class="ttdoc">Ordered array of PathMembers that comprise the path.</div><div class="ttdef"><b>Definition:</b> <a href="a00161_source.html#l00078">path.h:78</a></div></div>
<div class="ttc" id="aa01211_html"><div class="ttname"><a href="a01211.html">HF::SpatialStructures::PathMember</a></div><div class="ttdoc">The ID of a node, and the cost cost to the node after it.</div><div class="ttdef"><b>Definition:</b> <a href="a00161_source.html#l00019">path.h:19</a></div></div>
<div class="ttc" id="aa00282_html_a47d06b1c4bd84f4d0a7519ea0e96ff02"><div class="ttname"><a href="a00282.html#a47d06b1c4bd84f4d0a7519ea0e96ff02">HF::Pathfinding::FindPath</a></div><div class="ttdeci">Path FindPath(BoostGraph *bg, int start_id, int end_id)</div><div class="ttdoc">Find a path between points A and B using Dijkstra's Shortest Path algorithm.</div><div class="ttdef"><b>Definition:</b> <a href="a00113_source.html#l00165">path_finder.cpp:165</a></div></div>
<div class="ttc" id="aa01199_html_a604a648f1f73d687ad4544d2ac163212"><div class="ttname"><a href="a01199.html#a604a648f1f73d687ad4544d2ac163212">HF::SpatialStructures::Graph::addEdge</a></div><div class="ttdeci">void addEdge(const Node &amp;parent, const Node &amp;child, float score=1.0f)</div><div class="ttdoc">Add a new edge to the graph from parent to child.</div><div class="ttdef"><b>Definition:</b> <a href="a00149_source.html#l00224">graph.cpp:224</a></div></div>
<div class="ttc" id="aa00282_html_aee466bf2324daa4b600cc59c90e78977"><div class="ttname"><a href="a00282.html#aee466bf2324daa4b600cc59c90e78977">HF::Pathfinding::CreateBoostGraph</a></div><div class="ttdeci">std::unique_ptr&lt; BoostGraph, BoostGraphDeleter &gt; CreateBoostGraph(const HF::SpatialStructures::Graph &amp;g)</div><div class="ttdoc">Create a new boost graph from a HF::SpatialStructures:Graph.</div><div class="ttdef"><b>Definition:</b> <a href="a00113_source.html#l00267">path_finder.cpp:267</a></div></div>
<div class="ttc" id="aa01215_html"><div class="ttname"><a href="a01215.html">HF::SpatialStructures::Path</a></div><div class="ttdoc">A collection of nodes that form a path.</div><div class="ttdef"><b>Definition:</b> <a href="a00161_source.html#l00076">path.h:76</a></div></div>
<div class="ttc" id="aa01199_html_a41cece77d0eee98df39ecc6d3a366ec8"><div class="ttname"><a href="a01199.html#a41cece77d0eee98df39ecc6d3a366ec8">HF::SpatialStructures::Graph::Compress</a></div><div class="ttdeci">void Compress()</div><div class="ttdoc">Compress the graph to a CSR and enable the usage of several functions.</div><div class="ttdef"><b>Definition:</b> <a href="a00149_source.html#l00395">graph.cpp:395</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
