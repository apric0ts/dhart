<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Analysis: HF::SpatialStructures::Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_h_f.html">HF</a></li><li class="navelem"><b>SpatialStructures</b></li><li class="navelem"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_h_f_1_1_spatial_structures_1_1_graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HF::SpatialStructures::Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="namespace_h_f.html" title="Output CSR for interop with other languages">HF</a> <a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html" title="A HF Graph similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every no...">Graph</a> similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every node added will be assigned a unique ID  
 <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="graph_8h_source.html">graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8225b5596508853ec637e72873a45cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#af8225b5596508853ec637e72873a45cb">Graph</a> (const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;edges, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;distances, const std::vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &gt; &amp;<a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>)</td></tr>
<tr class="memdesc:af8225b5596508853ec637e72873a45cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graph from a list of nodes and edges. This is faster than just using the addedge method  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#af8225b5596508853ec637e72873a45cb">More...</a><br /></td></tr>
<tr class="separator:af8225b5596508853ec637e72873a45cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00121404a647b0d619f201cf9ebc797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#af00121404a647b0d619f201cf9ebc797">HasEdge</a> (const std::array&lt; float, 3 &gt; &amp;parent, const std::array&lt; float, 3 &gt; &amp;child, bool undirected=false) const</td></tr>
<tr class="separator:af00121404a647b0d619f201cf9ebc797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affca013028fca6ac730f3f313744500b"><td class="memItemLeft" align="right" valign="top"><a id="affca013028fca6ac730f3f313744500b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasEdge</b> (const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;parent, const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;child, const bool undirected=false) const</td></tr>
<tr class="separator:affca013028fca6ac730f3f313744500b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae29b0f69f0fff53113b7f968a128796"><td class="memItemLeft" align="right" valign="top"><a id="aae29b0f69f0fff53113b7f968a128796"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasEdge</b> (int parent, int child, bool undirected=false) const</td></tr>
<tr class="separator:aae29b0f69f0fff53113b7f968a128796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a> () const</td></tr>
<tr class="memdesc:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of nodes from the graph sorted by ID  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#aa70347b8a33b57c6f0a72d6eca4248d7">More...</a><br /></td></tr>
<tr class="separator:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f521e01db7e3c038ab2c1fac09b67df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a9f521e01db7e3c038ab2c1fac09b67df">GetUndirectedEdges</a> (const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;N) const</td></tr>
<tr class="memdesc:a9f521e01db7e3c038ab2c1fac09b67df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of edges to and from node N  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a9f521e01db7e3c038ab2c1fac09b67df">More...</a><br /></td></tr>
<tr class="separator:a9f521e01db7e3c038ab2c1fac09b67df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26ebb794b444e2214cf0b0fed5a529"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_edge_set.html">EdgeSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a1a26ebb794b444e2214cf0b0fed5a529">GetEdges</a> () const</td></tr>
<tr class="memdesc:a1a26ebb794b444e2214cf0b0fed5a529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get every edge/node in the given graph as IDs  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a1a26ebb794b444e2214cf0b0fed5a529">More...</a><br /></td></tr>
<tr class="separator:a1a26ebb794b444e2214cf0b0fed5a529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3285be5da987692e0b3671f49d67d21b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a3285be5da987692e0b3671f49d67d21b">AggregateGraph</a> (COST_AGGREGATE agg_type, bool directed=true) const</td></tr>
<tr class="memdesc:a3285be5da987692e0b3671f49d67d21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an ordered list of scores for the graph  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a3285be5da987692e0b3671f49d67d21b">More...</a><br /></td></tr>
<tr class="separator:a3285be5da987692e0b3671f49d67d21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ea4fda7d310b500456ff14527bab9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a7c2ea4fda7d310b500456ff14527bab9">operator[]</a> (const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;n) const</td></tr>
<tr class="memdesc:a7c2ea4fda7d310b500456ff14527bab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of edges for the given node  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a7c2ea4fda7d310b500456ff14527bab9">More...</a><br /></td></tr>
<tr class="separator:a7c2ea4fda7d310b500456ff14527bab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604a648f1f73d687ad4544d2ac163212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a> (const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;parent, const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;child, float score=1.0f)</td></tr>
<tr class="memdesc:a604a648f1f73d687ad4544d2ac163212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new edge for the graph from parent and child pair. If the parent is not in the graph as a key then it will be added  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a604a648f1f73d687ad4544d2ac163212">More...</a><br /></td></tr>
<tr class="separator:a604a648f1f73d687ad4544d2ac163212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa04fa06b0802acd9eebe46a8c7a1787"><td class="memItemLeft" align="right" valign="top"><a id="afa04fa06b0802acd9eebe46a8c7a1787"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (int parent_id, int child_id, float score)</td></tr>
<tr class="separator:afa04fa06b0802acd9eebe46a8c7a1787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de020064d58c4ab376a26c30be863a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a> (const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;n) const</td></tr>
<tr class="memdesc:a4de020064d58c4ab376a26c30be863a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether or not the graph has the given node in it as a parent  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a4de020064d58c4ab376a26c30be863a3">More...</a><br /></td></tr>
<tr class="separator:a4de020064d58c4ab376a26c30be863a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddbbec01c6354b7076f47f71fc1a220"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; float, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#aeddbbec01c6354b7076f47f71fc1a220">NodesAsFloat3</a> () const</td></tr>
<tr class="memdesc:aeddbbec01c6354b7076f47f71fc1a220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of nodes as arrays of floats  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#aeddbbec01c6354b7076f47f71fc1a220">More...</a><br /></td></tr>
<tr class="separator:aeddbbec01c6354b7076f47f71fc1a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2710af2a75976862d7a235793567d2f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a2710af2a75976862d7a235793567d2f3">size</a> () const</td></tr>
<tr class="memdesc:a2710af2a75976862d7a235793567d2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate how many nodes are in the graph  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a2710af2a75976862d7a235793567d2f3">More...</a><br /></td></tr>
<tr class="separator:a2710af2a75976862d7a235793567d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59beedafb4af0ee99d54761e1c681fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#af59beedafb4af0ee99d54761e1c681fc">getID</a> (const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;node) const</td></tr>
<tr class="memdesc:af59beedafb4af0ee99d54761e1c681fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID for the given node.  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#af59beedafb4af0ee99d54761e1c681fc">More...</a><br /></td></tr>
<tr class="separator:af59beedafb4af0ee99d54761e1c681fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cece77d0eee98df39ecc6d3a366ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a> ()</td></tr>
<tr class="memdesc:a41cece77d0eee98df39ecc6d3a366ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress the graph, significantly reducing memory usage, but disabling insertion.  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a41cece77d0eee98df39ecc6d3a366ec8">More...</a><br /></td></tr>
<tr class="separator:a41cece77d0eee98df39ecc6d3a366ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccd105c93a826bde0457449f774fd04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_h_f_1_1_spatial_structures_1_1_c_s_r_ptrs.html">CSRPtrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#afccd105c93a826bde0457449f774fd04">GetCSRPointers</a> ()</td></tr>
<tr class="memdesc:afccd105c93a826bde0457449f774fd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain poitners to the 3 arrays of the CSR, as well as any extra info that may be necesary to use the CSR in another language. This will automatically compress the graph if it isn't compressed already  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#afccd105c93a826bde0457449f774fd04">More...</a><br /></td></tr>
<tr class="separator:afccd105c93a826bde0457449f774fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794c342603cefb342fdc698ba539b25f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a794c342603cefb342fdc698ba539b25f">NodeFromID</a> (int id) const</td></tr>
<tr class="memdesc:a794c342603cefb342fdc698ba539b25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node belonging to that id  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a794c342603cefb342fdc698ba539b25f">More...</a><br /></td></tr>
<tr class="separator:a794c342603cefb342fdc698ba539b25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994dbd15119eb6548d2e15f4de4b88a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a994dbd15119eb6548d2e15f4de4b88a6">Clear</a> ()</td></tr>
<tr class="memdesc:a994dbd15119eb6548d2e15f4de4b88a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all nodes and edges in the graph.  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a994dbd15119eb6548d2e15f4de4b88a6">More...</a><br /></td></tr>
<tr class="separator:a994dbd15119eb6548d2e15f4de4b88a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313eb2f8a0f5edcb2bd4b6f6b03af428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html#a313eb2f8a0f5edcb2bd4b6f6b03af428">GenerateCrossSlope</a> ()</td></tr>
<tr class="memdesc:a313eb2f8a0f5edcb2bd4b6f6b03af428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate cross slope for the given graph  <a href="class_h_f_1_1_spatial_structures_1_1_graph.html#a313eb2f8a0f5edcb2bd4b6f6b03af428">More...</a><br /></td></tr>
<tr class="separator:a313eb2f8a0f5edcb2bd4b6f6b03af428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890e0f6603eca56c4c70772d5b559d53"><td class="memItemLeft" align="right" valign="top"><a id="a890e0f6603eca56c4c70772d5b559d53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GenerateEnergy</b> ()</td></tr>
<tr class="separator:a890e0f6603eca56c4c70772d5b559d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="namespace_h_f.html" title="Output CSR for interop with other languages">HF</a> <a class="el" href="class_h_f_1_1_spatial_structures_1_1_graph.html" title="A HF Graph similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every no...">Graph</a> similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every node added will be assigned a unique ID </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af8225b5596508853ec637e72873a45cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8225b5596508853ec637e72873a45cb">&#9670;&nbsp;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HF::SpatialStructures::Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a graph from a list of nodes and edges. This is faster than just using the addedge method </p>
<p><br  />
 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a604a648f1f73d687ad4544d2ac163212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604a648f1f73d687ad4544d2ac163212">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new edge for the graph from parent and child pair. If the parent is not in the graph as a key then it will be added </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent node to add to</td></tr>
    <tr><td class="paramname">child</td><td>The child node to add as an edge</td></tr>
    <tr><td class="paramname">score</td><td>The score for the given edge</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3285be5da987692e0b3671f49d67d21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3285be5da987692e0b3671f49d67d21b">&#9670;&nbsp;</a></span>AggregateGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; HF::SpatialStructures::Graph::AggregateGraph </td>
          <td>(</td>
          <td class="paramtype">COST_AGGREGATE&#160;</td>
          <td class="paramname"><em>agg_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an ordered list of scores for the graph </p>

</div>
</div>
<a id="a994dbd15119eb6548d2e15f4de4b88a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994dbd15119eb6548d2e15f4de4b88a6">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all nodes and edges in the graph. </p>

</div>
</div>
<a id="a41cece77d0eee98df39ecc6d3a366ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cece77d0eee98df39ecc6d3a366ec8">&#9670;&nbsp;</a></span>Compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::Compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress the graph, significantly reducing memory usage, but disabling insertion. </p>

</div>
</div>
<a id="a313eb2f8a0f5edcb2bd4b6f6b03af428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313eb2f8a0f5edcb2bd4b6f6b03af428">&#9670;&nbsp;</a></span>GenerateCrossSlope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::GenerateCrossSlope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate cross slope for the given graph </p>

</div>
</div>
<a id="afccd105c93a826bde0457449f774fd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccd105c93a826bde0457449f774fd04">&#9670;&nbsp;</a></span>GetCSRPointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_h_f_1_1_spatial_structures_1_1_c_s_r_ptrs.html">CSRPtrs</a> HF::SpatialStructures::Graph::GetCSRPointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain poitners to the 3 arrays of the CSR, as well as any extra info that may be necesary to use the CSR in another language. This will automatically compress the graph if it isn't compressed already </p>

</div>
</div>
<a id="a1a26ebb794b444e2214cf0b0fed5a529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a26ebb794b444e2214cf0b0fed5a529">&#9670;&nbsp;</a></span>GetEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_edge_set.html">EdgeSet</a> &gt; HF::SpatialStructures::Graph::GetEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get every edge/node in the given graph as IDs </p>

</div>
</div>
<a id="af59beedafb4af0ee99d54761e1c681fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59beedafb4af0ee99d54761e1c681fc">&#9670;&nbsp;</a></span>getID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ID for the given node. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID assigned to this node. -1 if it was not yet added to the graph</dd></dl>

</div>
</div>
<a id="a9f521e01db7e3c038ab2c1fac09b67df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f521e01db7e3c038ab2c1fac09b67df">&#9670;&nbsp;</a></span>GetUndirectedEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_edge.html">Edge</a> &gt; HF::SpatialStructures::Graph::GetUndirectedEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of edges to and from node N </p>

</div>
</div>
<a id="af00121404a647b0d619f201cf9ebc797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00121404a647b0d619f201cf9ebc797">&#9670;&nbsp;</a></span>HasEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; float, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; float, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>summary&gt; Determine if the graph has an edge with this parent and child /summary&gt; </p>

</div>
</div>
<a id="a4de020064d58c4ab376a26c30be863a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de020064d58c4ab376a26c30be863a3">&#9670;&nbsp;</a></span>hasKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::hasKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell whether or not the graph has the given node in it as a parent </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html" title="A point in space with an ID">Node</a> to check for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node exists, false otherwise</dd></dl>

</div>
</div>
<a id="a794c342603cefb342fdc698ba539b25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794c342603cefb342fdc698ba539b25f">&#9670;&nbsp;</a></span>NodeFromID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> HF::SpatialStructures::Graph::NodeFromID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node belonging to that id </p>

</div>
</div>
<a id="aa70347b8a33b57c6f0a72d6eca4248d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70347b8a33b57c6f0a72d6eca4248d7">&#9670;&nbsp;</a></span>Nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &gt; HF::SpatialStructures::Graph::Nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of nodes from the graph sorted by ID </p>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of nodes</dd></dl>

</div>
</div>
<a id="aeddbbec01c6354b7076f47f71fc1a220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddbbec01c6354b7076f47f71fc1a220">&#9670;&nbsp;</a></span>NodesAsFloat3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; float, 3 &gt; &gt; HF::SpatialStructures::Graph::NodesAsFloat3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of nodes as arrays of floats </p>
<dl class="section return"><dt>Returns</dt><dd>A list of float3s for each position of every node in the graph </dd></dl>

</div>
</div>
<a id="a7c2ea4fda7d310b500456ff14527bab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2ea4fda7d310b500456ff14527bab9">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_edge.html">Edge</a> &gt; HF::SpatialStructures::Graph::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_h_f_1_1_spatial_structures_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of edges for the given node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the graph's list</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::outofrange</td><td>Thrown if the requested object is not in the dictionary</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2710af2a75976862d7a235793567d2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2710af2a75976862d7a235793567d2f3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate how many nodes are in the graph </p>
<dl class="section return"><dt>Returns</dt><dd>An int displaying how many nodes are in the graph</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Cpp/spatialstructures/src/<a class="el" href="graph_8h_source.html">graph.h</a></li>
<li>Cpp/spatialstructures/src/graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
