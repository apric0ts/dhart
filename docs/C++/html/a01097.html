<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Analysis: HF::SpatialStructures::Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00171.html">HF</a></li><li class="navelem"><a class="el" href="a00174.html">SpatialStructures</a></li><li class="navelem"><a class="el" href="a01097.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="a01094.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HF::SpatialStructures::Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="a00171.html" title="Output CSR for interop with other languages">HF</a> <a class="el" href="a01097.html" title="A HF Graph similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every no...">Graph</a> similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every node added will be assigned a unique ID  
 <a href="a01097.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00101_source.html">graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8225b5596508853ec637e72873a45cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#af8225b5596508853ec637e72873a45cb">Graph</a> (const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;edges, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;distances, const std::vector&lt; <a class="el" href="a01101.html">Node</a> &gt; &amp;<a class="el" href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>)</td></tr>
<tr class="memdesc:af8225b5596508853ec637e72873a45cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graph from a list of nodes and edges. This is faster than just using the addEdge method  <a href="a01097.html#af8225b5596508853ec637e72873a45cb">More...</a><br /></td></tr>
<tr class="separator:af8225b5596508853ec637e72873a45cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5456486f43b49867082946106542f09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#ad5456486f43b49867082946106542f09">Graph</a> ()</td></tr>
<tr class="separator:ad5456486f43b49867082946106542f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00121404a647b0d619f201cf9ebc797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#af00121404a647b0d619f201cf9ebc797">HasEdge</a> (const std::array&lt; float, 3 &gt; &amp;parent, const std::array&lt; float, 3 &gt; &amp;child, bool undirected=false) const</td></tr>
<tr class="memdesc:af00121404a647b0d619f201cf9ebc797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge with this parent and child, by constructing temporary <a class="el" href="a01101.html" title="A point in space with an ID">Node</a> (using the params parent and child) and calling the member function overload of HasEdge that accepts (const <a class="el" href="a01101.html" title="A point in space with an ID">Node</a> &amp;).  <a href="a01097.html#af00121404a647b0d619f201cf9ebc797">More...</a><br /></td></tr>
<tr class="separator:af00121404a647b0d619f201cf9ebc797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affca013028fca6ac730f3f313744500b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#affca013028fca6ac730f3f313744500b">HasEdge</a> (const <a class="el" href="a01101.html">Node</a> &amp;parent, const <a class="el" href="a01101.html">Node</a> &amp;child, const bool undirected=false) const</td></tr>
<tr class="memdesc:affca013028fca6ac730f3f313744500b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge with this parent and child, using references to <a class="el" href="a01101.html" title="A point in space with an ID">Node</a>  <a href="a01097.html#affca013028fca6ac730f3f313744500b">More...</a><br /></td></tr>
<tr class="separator:affca013028fca6ac730f3f313744500b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae29b0f69f0fff53113b7f968a128796"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#aae29b0f69f0fff53113b7f968a128796">HasEdge</a> (int parent, int child, bool undirected=false) const</td></tr>
<tr class="memdesc:aae29b0f69f0fff53113b7f968a128796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge with this parent and child, using the integer identifiers for nodes  <a href="a01097.html#aae29b0f69f0fff53113b7f968a128796">More...</a><br /></td></tr>
<tr class="separator:aae29b0f69f0fff53113b7f968a128796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01101.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a> () const</td></tr>
<tr class="memdesc:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of nodes from the graph sorted by ID  <a href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">More...</a><br /></td></tr>
<tr class="separator:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f521e01db7e3c038ab2c1fac09b67df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01081.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a9f521e01db7e3c038ab2c1fac09b67df">GetUndirectedEdges</a> (const <a class="el" href="a01101.html">Node</a> &amp;N) const</td></tr>
<tr class="memdesc:a9f521e01db7e3c038ab2c1fac09b67df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of edges to and from node N  <a href="a01097.html#a9f521e01db7e3c038ab2c1fac09b67df">More...</a><br /></td></tr>
<tr class="separator:a9f521e01db7e3c038ab2c1fac09b67df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26ebb794b444e2214cf0b0fed5a529"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00174.html#a01089">EdgeSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a1a26ebb794b444e2214cf0b0fed5a529">GetEdges</a> () const</td></tr>
<tr class="memdesc:a1a26ebb794b444e2214cf0b0fed5a529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get every edge/node in the given graph as IDs  <a href="a01097.html#a1a26ebb794b444e2214cf0b0fed5a529">More...</a><br /></td></tr>
<tr class="separator:a1a26ebb794b444e2214cf0b0fed5a529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3285be5da987692e0b3671f49d67d21b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a3285be5da987692e0b3671f49d67d21b">AggregateGraph</a> (<a class="el" href="a00174.html#a6b23c0b2531c78f6d5049873c184f4f9">COST_AGGREGATE</a> agg_type, bool directed=true) const</td></tr>
<tr class="memdesc:a3285be5da987692e0b3671f49d67d21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an ordered list of scores for the graph  <a href="a01097.html#a3285be5da987692e0b3671f49d67d21b">More...</a><br /></td></tr>
<tr class="separator:a3285be5da987692e0b3671f49d67d21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ea4fda7d310b500456ff14527bab9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a01081.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a7c2ea4fda7d310b500456ff14527bab9">operator[]</a> (const <a class="el" href="a01101.html">Node</a> &amp;n) const</td></tr>
<tr class="memdesc:a7c2ea4fda7d310b500456ff14527bab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of edges for the given node  <a href="a01097.html#a7c2ea4fda7d310b500456ff14527bab9">More...</a><br /></td></tr>
<tr class="separator:a7c2ea4fda7d310b500456ff14527bab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604a648f1f73d687ad4544d2ac163212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a> (const <a class="el" href="a01101.html">Node</a> &amp;parent, const <a class="el" href="a01101.html">Node</a> &amp;child, float score=1.0f)</td></tr>
<tr class="memdesc:a604a648f1f73d687ad4544d2ac163212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new edge for the graph from parent and child pair. If the parent is not in the graph as a key then it will be added  <a href="a01097.html#a604a648f1f73d687ad4544d2ac163212">More...</a><br /></td></tr>
<tr class="separator:a604a648f1f73d687ad4544d2ac163212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa04fa06b0802acd9eebe46a8c7a1787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#afa04fa06b0802acd9eebe46a8c7a1787">addEdge</a> (int parent_id, int child_id, float score)</td></tr>
<tr class="memdesc:afa04fa06b0802acd9eebe46a8c7a1787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new edge for the graph using parent and child IDs. If the parent_id is not in the graph as a key, it will be added  <a href="a01097.html#afa04fa06b0802acd9eebe46a8c7a1787">More...</a><br /></td></tr>
<tr class="separator:afa04fa06b0802acd9eebe46a8c7a1787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de020064d58c4ab376a26c30be863a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a> (const <a class="el" href="a01101.html">Node</a> &amp;n) const</td></tr>
<tr class="memdesc:a4de020064d58c4ab376a26c30be863a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether or not the graph has the given node in it as a parent  <a href="a01097.html#a4de020064d58c4ab376a26c30be863a3">More...</a><br /></td></tr>
<tr class="separator:a4de020064d58c4ab376a26c30be863a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddbbec01c6354b7076f47f71fc1a220"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; float, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#aeddbbec01c6354b7076f47f71fc1a220">NodesAsFloat3</a> () const</td></tr>
<tr class="memdesc:aeddbbec01c6354b7076f47f71fc1a220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of nodes as arrays of floats  <a href="a01097.html#aeddbbec01c6354b7076f47f71fc1a220">More...</a><br /></td></tr>
<tr class="separator:aeddbbec01c6354b7076f47f71fc1a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2710af2a75976862d7a235793567d2f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a2710af2a75976862d7a235793567d2f3">size</a> () const</td></tr>
<tr class="memdesc:a2710af2a75976862d7a235793567d2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how many nodes are in the graph  <a href="a01097.html#a2710af2a75976862d7a235793567d2f3">More...</a><br /></td></tr>
<tr class="separator:a2710af2a75976862d7a235793567d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59beedafb4af0ee99d54761e1c681fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#af59beedafb4af0ee99d54761e1c681fc">getID</a> (const <a class="el" href="a01101.html">Node</a> &amp;node) const</td></tr>
<tr class="memdesc:af59beedafb4af0ee99d54761e1c681fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the ID for the given node.  <a href="a01097.html#af59beedafb4af0ee99d54761e1c681fc">More...</a><br /></td></tr>
<tr class="separator:af59beedafb4af0ee99d54761e1c681fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cece77d0eee98df39ecc6d3a366ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a> ()</td></tr>
<tr class="memdesc:a41cece77d0eee98df39ecc6d3a366ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress the graph, significantly reducing memory usage, but disabling insertion.  <a href="a01097.html#a41cece77d0eee98df39ecc6d3a366ec8">More...</a><br /></td></tr>
<tr class="separator:a41cece77d0eee98df39ecc6d3a366ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccd105c93a826bde0457449f774fd04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01093.html">CSRPtrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#afccd105c93a826bde0457449f774fd04">GetCSRPointers</a> ()</td></tr>
<tr class="memdesc:afccd105c93a826bde0457449f774fd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain pointers to the 3 arrays of the CSR, as well as any extra info that may be necesary to use the CSR in another language. This will automatically compress the graph if it isn't compressed already  <a href="a01097.html#afccd105c93a826bde0457449f774fd04">More...</a><br /></td></tr>
<tr class="separator:afccd105c93a826bde0457449f774fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794c342603cefb342fdc698ba539b25f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01101.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a794c342603cefb342fdc698ba539b25f">NodeFromID</a> (int id) const</td></tr>
<tr class="memdesc:a794c342603cefb342fdc698ba539b25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the node that corresponds to id  <a href="a01097.html#a794c342603cefb342fdc698ba539b25f">More...</a><br /></td></tr>
<tr class="separator:a794c342603cefb342fdc698ba539b25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994dbd15119eb6548d2e15f4de4b88a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a994dbd15119eb6548d2e15f4de4b88a6">Clear</a> ()</td></tr>
<tr class="memdesc:a994dbd15119eb6548d2e15f4de4b88a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all nodes and edges in the graph.  <a href="a01097.html#a994dbd15119eb6548d2e15f4de4b88a6">More...</a><br /></td></tr>
<tr class="separator:a994dbd15119eb6548d2e15f4de4b88a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313eb2f8a0f5edcb2bd4b6f6b03af428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a313eb2f8a0f5edcb2bd4b6f6b03af428">GenerateCrossSlope</a> ()</td></tr>
<tr class="memdesc:a313eb2f8a0f5edcb2bd4b6f6b03af428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate cross slope for the given graph  <a href="a01097.html#a313eb2f8a0f5edcb2bd4b6f6b03af428">More...</a><br /></td></tr>
<tr class="separator:a313eb2f8a0f5edcb2bd4b6f6b03af428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890e0f6603eca56c4c70772d5b559d53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a890e0f6603eca56c4c70772d5b559d53">GenerateEnergy</a> ()</td></tr>
<tr class="memdesc:a890e0f6603eca56c4c70772d5b559d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate energy for the given graph  <a href="a01097.html#a890e0f6603eca56c4c70772d5b559d53">More...</a><br /></td></tr>
<tr class="separator:a890e0f6603eca56c4c70772d5b559d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afca147a681e4b39bc471e02d0f07eb37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a> (const <a class="el" href="a01101.html">Node</a> &amp;input_node)</td></tr>
<tr class="memdesc:afca147a681e4b39bc471e02d0f07eb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique ID for this x, y, z position. If one does not exist yet for this node then assign it one.  <a href="a01097.html#afca147a681e4b39bc471e02d0f07eb37">More...</a><br /></td></tr>
<tr class="separator:afca147a681e4b39bc471e02d0f07eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133b6f44ac90ed6135752e32482b70f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a133b6f44ac90ed6135752e32482b70f5">getOrAssignID</a> (int input_int)</td></tr>
<tr class="memdesc:a133b6f44ac90ed6135752e32482b70f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique ID for this x, y, z position. If one does not exist yet for this node then assign it one.  <a href="a01097.html#a133b6f44ac90ed6135752e32482b70f5">More...</a><br /></td></tr>
<tr class="separator:a133b6f44ac90ed6135752e32482b70f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902d654a1c1b6d391c27c6c2bd618bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a902d654a1c1b6d391c27c6c2bd618bbc">checkForEdge</a> (int parent, int child) const</td></tr>
<tr class="memdesc:a902d654a1c1b6d391c27c6c2bd618bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through every edge in parent to find child. Returns when child is found  <a href="a01097.html#a902d654a1c1b6d391c27c6c2bd618bbc">More...</a><br /></td></tr>
<tr class="separator:a902d654a1c1b6d391c27c6c2bd618bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3640461d4c1d1ff55dd200fd5670bf9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a3640461d4c1d1ff55dd200fd5670bf9c">UpdateIDs</a> (int new_id)</td></tr>
<tr class="memdesc:a3640461d4c1d1ff55dd200fd5670bf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an empty node for this new id  <a href="a01097.html#a3640461d4c1d1ff55dd200fd5670bf9c">More...</a><br /></td></tr>
<tr class="separator:a3640461d4c1d1ff55dd200fd5670bf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad59ab7164b64e3d78b7032b28c2c6663"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01101.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#ad59ab7164b64e3d78b7032b28c2c6663">ordered_nodes</a></td></tr>
<tr class="memdesc:ad59ab7164b64e3d78b7032b28c2c6663"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ordered list of nodes with ids.  <a href="a01097.html#ad59ab7164b64e3d78b7032b28c2c6663">More...</a><br /></td></tr>
<tr class="separator:ad59ab7164b64e3d78b7032b28c2c6663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6515ac2323a16e27adab7b20561a649"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#ab6515ac2323a16e27adab7b20561a649">id_to_nodes</a></td></tr>
<tr class="memdesc:ab6515ac2323a16e27adab7b20561a649"><td class="mdescLeft">&#160;</td><td class="mdescRight">a list that indexes ordered_nodes with ids  <a href="a01097.html#ab6515ac2323a16e27adab7b20561a649">More...</a><br /></td></tr>
<tr class="separator:ab6515ac2323a16e27adab7b20561a649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da5e288f03773d18053c82731369b2a"><td class="memItemLeft" align="right" valign="top">robin_hood::unordered_map&lt; <a class="el" href="a01101.html">Node</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a4da5e288f03773d18053c82731369b2a">idmap</a></td></tr>
<tr class="memdesc:a4da5e288f03773d18053c82731369b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list of X,Y,Z positions to ids.  <a href="a01097.html#a4da5e288f03773d18053c82731369b2a">More...</a><br /></td></tr>
<tr class="separator:a4da5e288f03773d18053c82731369b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d4522c02692328c767ff439ca6511a"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; float, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a77d4522c02692328c767ff439ca6511a">edge_matrix</a></td></tr>
<tr class="memdesc:a77d4522c02692328c767ff439ca6511a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all edges between nodes.  <a href="a01097.html#a77d4522c02692328c767ff439ca6511a">More...</a><br /></td></tr>
<tr class="separator:a77d4522c02692328c767ff439ca6511a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab13304c641df6fdcd3662d5c54dc78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#aaab13304c641df6fdcd3662d5c54dc78">next_id</a> = 0</td></tr>
<tr class="memdesc:aaab13304c641df6fdcd3662d5c54dc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of the next unique node.  <a href="a01097.html#aaab13304c641df6fdcd3662d5c54dc78">More...</a><br /></td></tr>
<tr class="separator:aaab13304c641df6fdcd3662d5c54dc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf07c256da74c2a03f81b4977364e85"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Triplet&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a1cf07c256da74c2a03f81b4977364e85">triplets</a></td></tr>
<tr class="memdesc:a1cf07c256da74c2a03f81b4977364e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of Triplet, type float  <a href="a01097.html#a1cf07c256da74c2a03f81b4977364e85">More...</a><br /></td></tr>
<tr class="separator:a1cf07c256da74c2a03f81b4977364e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbd600663187d7cf985e9b6e7cea73f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01097.html#a1cbd600663187d7cf985e9b6e7cea73f">needs_compression</a> = true</td></tr>
<tr class="memdesc:a1cbd600663187d7cf985e9b6e7cea73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CSR is inaccurate and requires compression.  <a href="a01097.html#a1cbd600663187d7cf985e9b6e7cea73f">More...</a><br /></td></tr>
<tr class="separator:a1cbd600663187d7cf985e9b6e7cea73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="a00171.html" title="Output CSR for interop with other languages">HF</a> <a class="el" href="a01097.html" title="A HF Graph similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every no...">Graph</a> similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every node added will be assigned a unique ID </p>

<p class="definition">Definition at line <a class="el" href="a00101_source.html#l00080">80</a> of file <a class="el" href="a00101_source.html">graph.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af8225b5596508853ec637e72873a45cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8225b5596508853ec637e72873a45cb">&#9670;&nbsp;</a></span>Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HF::SpatialStructures::Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a01101.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a graph from a list of nodes and edges. This is faster than just using the addEdge method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The desired edges for <a class="el" href="a01097.html" title="A HF Graph similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every no...">Graph</a>, in the form of an adjacency matrix (reference)</td></tr>
    <tr><td class="paramname">distances</td><td>The desired distances for <a class="el" href="a01097.html" title="A HF Graph similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every no...">Graph</a>, following the form of param edges (reference)</td></tr>
    <tr><td class="paramname">Nodes</td><td>A vector of <a class="el" href="a01101.html" title="A point in space with an ID">Node</a> for <a class="el" href="a01097.html" title="A HF Graph similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every no...">Graph</a> (reference)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00230">230</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="ad5456486f43b49867082946106542f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5456486f43b49867082946106542f09">&#9670;&nbsp;</a></span>Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HF::SpatialStructures::Graph::Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph;     <span class="comment">// This represents an order-zero graph (null graph)</span></div>
<div class="line">                                        <span class="comment">// It lacks vertices and edges.</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00101_source.html#l00173">173</a> of file <a class="el" href="a00101_source.html">graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a604a648f1f73d687ad4544d2ac163212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604a648f1f73d687ad4544d2ac163212">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01101.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01101.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new edge for the graph from parent and child pair. If the parent is not in the graph as a key then it will be added </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent node to add to</td></tr>
    <tr><td class="paramname">child</td><td>The child node to add as an edge</td></tr>
    <tr><td class="paramname">score</td><td>The score for the given edge</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a pair of nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> n_parent(4.0f, 5.0f, 6.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> n_child(7.0f, 8.0f, 9.0f);</div>
<div class="line"> </div>
<div class="line">graph.<a class="code" href="a01097.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(n_parent, n_child);   <span class="comment">// default score is 1.0f</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00158">158</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00143_source.html#l00098">AddEdgeFromNodeIDs()</a>, <a class="el" href="a00143_source.html#l00078">AddEdgeFromNodes()</a>, <a class="el" href="a00011_source.html#l00213">HF::AnalysisMethods::GraphGeneratorPrivate::CrawlGeom()</a>, and <a class="el" href="a00011_source.html#l00245">HF::AnalysisMethods::GraphGeneratorPrivate::CrawlGeomParallel()</a>.</p>

</div>
</div>
<a id="afa04fa06b0802acd9eebe46a8c7a1787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa04fa06b0802acd9eebe46a8c7a1787">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new edge for the graph using parent and child IDs. If the parent_id is not in the graph as a key, it will be added </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td>The ID of the parent node for the edge to construct</td></tr>
    <tr><td class="paramname">child_id</td><td>The ID of the child node for the edge to construct</td></tr>
    <tr><td class="paramname">score</td><td>The score for the given edge</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> parent = 1;</div>
<div class="line"><span class="keywordtype">int</span> child = 2;</div>
<div class="line"> </div>
<div class="line">graph.<a class="code" href="a01097.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(parent, child, 1.0f);</div>
<div class="line">graph.<a class="code" href="a01097.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a>();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00169">169</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a3285be5da987692e0b3671f49d67d21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3285be5da987692e0b3671f49d67d21b">&#9670;&nbsp;</a></span>AggregateGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; HF::SpatialStructures::Graph::AggregateGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#a6b23c0b2531c78f6d5049873c184f4f9">COST_AGGREGATE</a>&#160;</td>
          <td class="paramname"><em>agg_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an ordered list of scores for the graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agg_type</td><td>0 for SUM, 1 for AVERAGE, 2 for COUNT</td></tr>
    <tr><td class="paramname">directed</td><td>if graph is directed or not, default is true</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of type float of the edge costs</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// graph must be compressed, or a exception will be thrown</span></div>
<div class="line"><a class="code" href="a00174.html#a6b23c0b2531c78f6d5049873c184f4f9">HF::SpatialStructures::COST_AGGREGATE</a> aggregate = <a class="code" href="a00174.html#a6b23c0b2531c78f6d5049873c184f4f9a16de38737a9f8366e9b2042b4e9b6290">HF::SpatialStructures::COST_AGGREGATE::AVERAGE</a>;       <span class="comment">// aggregate == 1 in this case</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// directed parameter may be true or false</span></div>
<div class="line">std::vector&lt;float&gt; aggregate_graph = graph.<a class="code" href="a01097.html#a3285be5da987692e0b3671f49d67d21b">AggregateGraph</a>(aggregate, <span class="keyword">true</span>); </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00115">115</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00098_source.html#l00091">HF::SpatialStructures::Aggregate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00143_source.html#l00049">AggregateCosts()</a>.</p>

</div>
</div>
<a id="a902d654a1c1b6d391c27c6c2bd618bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902d654a1c1b6d391c27c6c2bd618bbc">&#9670;&nbsp;</a></span>checkForEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::checkForEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate through every edge in parent to find child. Returns when child is found </p>
<div class="fragment"><div class="line">TODO example</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00178">178</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a994dbd15119eb6548d2e15f4de4b88a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994dbd15119eb6548d2e15f4de4b88a6">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all nodes and edges in the graph. </p>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If we want to remove all nodes and edges from graph, we may do so with Clear:</span></div>
<div class="line">graph.<a class="code" href="a01097.html#a994dbd15119eb6548d2e15f4de4b88a6">Clear</a>();                      <span class="comment">// edge_matrix is zeroed out, buffer is squeezed,</span></div>
<div class="line">                                    <span class="comment">// triplets are also cleared, and needs_compression == true</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00305">305</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00143_source.html#l00142">ClearGraph()</a>.</p>

</div>
</div>
<a id="a41cece77d0eee98df39ecc6d3a366ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cece77d0eee98df39ecc6d3a366ec8">&#9670;&nbsp;</a></span>Compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::Compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress the graph, significantly reducing memory usage, but disabling insertion. </p>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a pair of nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> n_parent(4.0f, 5.0f, 6.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> n_child(7.0f, 8.0f, 9.0f);</div>
<div class="line"> </div>
<div class="line">graph.<a class="code" href="a01097.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(n_parent, n_child);   <span class="comment">// default score is 1.0f</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// In order to use GetEdges, or AggregateGraph, we must compress our graph instance</span></div>
<div class="line">graph.<a class="code" href="a01097.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a>();                       <span class="comment">// GetEdges and AggregateGraph are now usable</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00295">295</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00143_source.html#l00136">Compress()</a>.</p>

</div>
</div>
<a id="a313eb2f8a0f5edcb2bd4b6f6b03af428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313eb2f8a0f5edcb2bd4b6f6b03af428">&#9670;&nbsp;</a></span>GenerateCrossSlope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::GenerateCrossSlope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate cross slope for the given graph </p>
<div class="fragment"><div class="line"><span class="comment">// TODO example - code commented out in graph.cpp</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a890e0f6603eca56c4c70772d5b559d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890e0f6603eca56c4c70772d5b559d53">&#9670;&nbsp;</a></span>GenerateEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::GenerateEnergy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate energy for the given graph </p>
<div class="fragment"><div class="line"><span class="comment">// TODO example - code commented out in graph.cpp</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afccd105c93a826bde0457449f774fd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccd105c93a826bde0457449f774fd04">&#9670;&nbsp;</a></span>GetCSRPointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01093.html">CSRPtrs</a> HF::SpatialStructures::Graph::GetCSRPointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain pointers to the 3 arrays of the CSR, as well as any extra info that may be necesary to use the CSR in another language. This will automatically compress the graph if it isn't compressed already </p>
<dl class="section return"><dt>Returns</dt><dd>An instance of a struct <a class="el" href="a01093.html" title="TODO summary">CSRPtrs</a>, using the member field edge_matrix</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a pair of nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> n_parent(4.0f, 5.0f, 6.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> n_child(7.0f, 8.0f, 9.0f);</div>
<div class="line"> </div>
<div class="line">graph.<a class="code" href="a01097.html#a604a648f1f73d687ad4544d2ac163212">addEdge</a>(n_parent, n_child);   <span class="comment">// default score is 1.0f</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Graph will be compressed automatically be GetCSRPointers</span></div>
<div class="line">CSRPtrs returned_csr = graph.<a class="code" href="a01097.html#afccd105c93a826bde0457449f774fd04">GetCSRPointers</a>();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00030">30</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00143_source.html#l00136">Compress()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00143_source.html#l00103">GetCSRPointers()</a>.</p>

</div>
</div>
<a id="a1a26ebb794b444e2214cf0b0fed5a529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a26ebb794b444e2214cf0b0fed5a529">&#9670;&nbsp;</a></span>GetEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a00174.html#a01089">EdgeSet</a> &gt; HF::SpatialStructures::Graph::GetEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get every edge/node in the given graph as IDs </p>
<dl class="section return"><dt>Returns</dt><dd>A list of <a class="el" href="a00174.html#a01089" title="A collection of edges for a specific node">EdgeSet</a> (<a class="el" href="a01097.html" title="A HF Graph similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every no...">Graph</a> in the form of IDs)</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);    </div>
<div class="line"> </div>
<div class="line"><span class="comment">// graph must be compressed, or a exception will be thrown</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// To brief, an EdgeSet has the following layout:</span></div>
<div class="line"><span class="comment">//      struct EdgeSet {</span></div>
<div class="line"><span class="comment">//          int parent;</span></div>
<div class="line"><span class="comment">//          std::vector&lt;IntEdge&gt; children;</span></div>
<div class="line"><span class="comment">//      };</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  An IntEdge has the following layout:</span></div>
<div class="line"><span class="comment">//      struct IntEdge {</span></div>
<div class="line"><span class="comment">//          int child;</span></div>
<div class="line"><span class="comment">//          float weight;</span></div>
<div class="line"><span class="comment">//      };</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A std::vector&lt;EdgeSet&gt; is a Graph, in the form of IDs.</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::EdgeSet&gt; edge_set = graph.<a class="code" href="a01097.html#a1a26ebb794b444e2214cf0b0fed5a529">GetEdges</a>();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00073">73</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00056_source.html#l00020">HF::Pathfinding::BoostGraph::BoostGraph()</a>.</p>

</div>
</div>
<a id="af59beedafb4af0ee99d54761e1c681fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59beedafb4af0ee99d54761e1c681fc">&#9670;&nbsp;</a></span>getID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01101.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the ID for the given node. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID assigned to this node. -1 if it was not yet added to the graph</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> other_node(55.0f, 66.1f, 15.5f, 9510);  <span class="comment">// Let&#39;s construct a Node we know is not in graph.</span></div>
<div class="line"><span class="keywordtype">bool</span> has_key = graph.<a class="code" href="a01097.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a>(other_node);                            <span class="comment">// other_node does not exist in graph, so has_key == false;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> ID = graph.<a class="code" href="a01097.html#af59beedafb4af0ee99d54761e1c681fc">getID</a>(other_node);                                   <span class="comment">// ID will assigned -1, because other_node is not a part of graph.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Likewise, if we pass a Node instance that indeed exists...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of </span></div>
<div class="line"><span class="comment">// std::vector&lt;Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.<a class="code" href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to hasKey.</span></div>
<div class="line"><span class="comment">// Any node that exists with graph can be passed to this member function</span></div>
<div class="line"><span class="comment">// to determine if the graph has the node&#39;s key, or not.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;                  <span class="comment">// we assume for this example that index 2 is valid.</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> good_node = get_nodes[index];</div>
<div class="line"> </div>
<div class="line">ID = graph.<a class="code" href="a01097.html#af59beedafb4af0ee99d54761e1c681fc">getID</a>(good_node);    <span class="comment">// ID &gt; -1, i.e. it is a Node instance that exists within this Graph.</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00022">22</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00143_source.html#l00125">GetNodeID()</a>.</p>

</div>
</div>
<a id="afca147a681e4b39bc471e02d0f07eb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca147a681e4b39bc471e02d0f07eb37">&#9670;&nbsp;</a></span>getOrAssignID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getOrAssignID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01101.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>input_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique ID for this x, y, z position. If one does not exist yet for this node then assign it one. </p>
<div class="fragment"><div class="line">TODO example</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00203">203</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a133b6f44ac90ed6135752e32482b70f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133b6f44ac90ed6135752e32482b70f5">&#9670;&nbsp;</a></span>getOrAssignID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getOrAssignID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique ID for this x, y, z position. If one does not exist yet for this node then assign it one. </p>
<div class="fragment"><div class="line">TODO example</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00217">217</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a9f521e01db7e3c038ab2c1fac09b67df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f521e01db7e3c038ab2c1fac09b67df">&#9670;&nbsp;</a></span>GetUndirectedEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="a01081.html">Edge</a> &gt; HF::SpatialStructures::Graph::GetUndirectedEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01101.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of edges to and from node N </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The <a class="el" href="a01101.html" title="A point in space with an ID">Node</a> from which the list of edges will be derived</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of edges to and from node N</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);    </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of </span></div>
<div class="line"><span class="comment">// std::vector&lt;HF::SpatialStructures::Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.<a class="code" href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to GetUndirectedEdges.</span></div>
<div class="line"><span class="comment">// Any node that exists with graph can be passed to this member function</span></div>
<div class="line"><span class="comment">// to retrieve a vector of undirected edges.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;</div>
<div class="line">std::vector&lt;HF::SpatialStructures::Edge&gt; undirected_edges = graph.<a class="code" href="a01097.html#a9f521e01db7e3c038ab2c1fac09b67df">GetUndirectedEdges</a>(get_nodes[index]);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00054">54</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="affca013028fca6ac730f3f313744500b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affca013028fca6ac730f3f313744500b">&#9670;&nbsp;</a></span>HasEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01101.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01101.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge with this parent and child, using references to <a class="el" href="a01101.html" title="A point in space with an ID">Node</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent node of edge; u to v, parent is u</td></tr>
    <tr><td class="paramname">child</td><td>Child node of edge; u to v, child is v</td></tr>
    <tr><td class="paramname">undirected</td><td>true if undirected, false otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if edge exists with parent and child (<a class="el" href="a01101.html" title="A point in space with an ID">Node</a> &amp;), false otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// last argument can be true/false for undirected/directed graph respectively</span></div>
<div class="line"><span class="keywordtype">bool</span> has_edge = graph.<a class="code" href="a01097.html#af00121404a647b0d619f201cf9ebc797">HasEdge</a>(node_1, node_2, <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00189">189</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="af00121404a647b0d619f201cf9ebc797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00121404a647b0d619f201cf9ebc797">&#9670;&nbsp;</a></span>HasEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; float, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; float, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge with this parent and child, by constructing temporary <a class="el" href="a01101.html" title="A point in space with an ID">Node</a> (using the params parent and child) and calling the member function overload of HasEdge that accepts (const <a class="el" href="a01101.html" title="A point in space with an ID">Node</a> &amp;). </p>
<dl class="section return"><dt>Returns</dt><dd>See return for member function overload that accepts (const <a class="el" href="a01101.html" title="A point in space with an ID">Node</a> &amp;)</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);                                      </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare {x, y, z} coordinates (positions)</span></div>
<div class="line"><span class="keyword">auto</span> parent_pos = node_1.getArray();        <span class="comment">// (2.0, 3.0, 4.0)</span></div>
<div class="line"><span class="keyword">auto</span> child_pos = node_2.getArray();         <span class="comment">// (11.0, 22.0, 140.0)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// last argument can be true/false for undirected/directed graph respectively</span></div>
<div class="line"><span class="keywordtype">bool</span> has_edge = graph.<a class="code" href="a01097.html#af00121404a647b0d619f201cf9ebc797">HasEdge</a>(parent_pos, child_pos, <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00260">260</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="aae29b0f69f0fff53113b7f968a128796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae29b0f69f0fff53113b7f968a128796">&#9670;&nbsp;</a></span>HasEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge with this parent and child, using the integer identifiers for nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Identifier for parent node (integer)</td></tr>
    <tr><td class="paramname">child</td><td>Identifier for child node (integer)</td></tr>
    <tr><td class="paramname">undirected</td><td>True if undirected graph, false otherwise. False by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if checkForEdge(parent, child), or undirected &amp;&amp; checkForEdge(child, parent), false otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// last argument can be true/false for undirected/directed graph respectively</span></div>
<div class="line"><span class="keywordtype">bool</span> has_edge = graph.<a class="code" href="a01097.html#af00121404a647b0d619f201cf9ebc797">HasEdge</a>(0, 1, <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00185">185</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a4de020064d58c4ab376a26c30be863a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de020064d58c4ab376a26c30be863a3">&#9670;&nbsp;</a></span>hasKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::hasKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01101.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell whether or not the graph has the given node in it as a parent </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="a01101.html" title="A point in space with an ID">Node</a> to check for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node exists, false otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> other_node(55.0f, 66.1f, 15.5f, 9510);  <span class="comment">// Let&#39;s construct a Node we know is not in graph.</span></div>
<div class="line"><span class="keywordtype">bool</span> has_key = graph.<a class="code" href="a01097.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a>(other_node);    <span class="comment">// other_node does not exist in graph, so has_key == false;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Likewise, if we pass a Node instance that indeed exists...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of </span></div>
<div class="line"><span class="comment">// std::vector&lt;Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.<a class="code" href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to hasKey.</span></div>
<div class="line"><span class="comment">// Any node that exists with graph can be passed to this member function</span></div>
<div class="line"><span class="comment">// to determine if the graph has the node&#39;s key, or not.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> good_node = get_nodes[index];</div>
<div class="line"> </div>
<div class="line">has_key = graph.<a class="code" href="a01097.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a>(good_node);      <span class="comment">// now has_key is true</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00267">267</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a794c342603cefb342fdc698ba539b25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794c342603cefb342fdc698ba539b25f">&#9670;&nbsp;</a></span>NodeFromID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01101.html">Node</a> HF::SpatialStructures::Graph::NodeFromID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the node that corresponds to id </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id for the desired node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node corresponding to id, by value</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let&#39;s retrieve node_1.</span></div>
<div class="line"><span class="keywordtype">int</span> desired_node_id = 2;</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_from_id = graph.<a class="code" href="a01097.html#a794c342603cefb342fdc698ba539b25f">NodeFromID</a>(desired_node_id);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note that NodeFromID ceases to work if the id argument provided does not exist as an ID among</span></div>
<div class="line"><span class="comment">// the nodes within graph</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00048">48</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="aa70347b8a33b57c6f0a72d6eca4248d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70347b8a33b57c6f0a72d6eca4248d7">&#9670;&nbsp;</a></span>Nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01101.html">Node</a> &gt; HF::SpatialStructures::Graph::Nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of nodes from the graph sorted by ID </p>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of nodes</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);    </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nodes() returns a copy of the ordered_nodes field</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes_from_graph = graph.<a class="code" href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00050">50</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00056_source.html#l00020">HF::Pathfinding::BoostGraph::BoostGraph()</a>, <a class="el" href="a00113_source.html#l00015">GenerateGraph()</a>, and <a class="el" href="a00143_source.html#l00015">GetAllNodesFromGraph()</a>.</p>

</div>
</div>
<a id="aeddbbec01c6354b7076f47f71fc1a220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddbbec01c6354b7076f47f71fc1a220">&#9670;&nbsp;</a></span>NodesAsFloat3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; float, 3 &gt; &gt; HF::SpatialStructures::Graph::NodesAsFloat3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of nodes as arrays of floats </p>
<dl class="section return"><dt>Returns</dt><dd>A list of floats for each position of every node in the graph </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A container of std::array&lt;float, 3&gt; is constructed and populated within</span></div>
<div class="line"><span class="comment">// NodesAsFloat3, and returned. Each array of 3 floats represents a Node&#39;s position</span></div>
<div class="line"><span class="comment">// within the Cartesian coordinate system. { x, y, z }</span></div>
<div class="line">std::vector&lt;std::array&lt;float, 3&gt;&gt; nodes_as_floats = graph.<a class="code" href="a01097.html#aeddbbec01c6354b7076f47f71fc1a220">NodesAsFloat3</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The two loops below will yield the same output</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> n : graph.<a class="code" href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; n.x &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; n.y &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; n.z &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> a : nodes_as_floats) {</div>
<div class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <p>This yields the intended output</p>

<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00269">269</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a7c2ea4fda7d310b500456ff14527bab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2ea4fda7d310b500456ff14527bab9">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="a01081.html">Edge</a> &gt; HF::SpatialStructures::Graph::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01101.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of edges for the given node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="a01101.html" title="A point in space with an ID">Node</a> from which a list of edges will be derived</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the graph's list</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::outofrange</td><td>Thrown if the requested object is not in the dictionary</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of </span></div>
<div class="line"><span class="comment">// std::vector&lt;Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.<a class="code" href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to GetUndirectedEdges.</span></div>
<div class="line"><span class="comment">// Any node that exists with graph can be passed to this member function</span></div>
<div class="line"><span class="comment">// to retrieve a vector of edges.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node = get_nodes[index];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note that if node does not exist within graph, that an exception will be thrown.</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Edge&gt; undirected_edges = graph[node];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// See a (node)-&gt;(child_node_0, child_node_1, ... child_node_n)</span></div>
<div class="line">std::cout &lt;&lt; node.<a class="code" href="a01101.html#a51c4642674d54d02b8600f7ffeb45670">getArray</a>() &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> e : undirected_edges) {</div>
<div class="line">    std::cout &lt;&lt; e.child.getArray() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00143">143</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

</div>
</div>
<a id="a2710af2a75976862d7a235793567d2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2710af2a75976862d7a235793567d2f3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how many nodes are in the graph </p>
<dl class="section return"><dt>Returns</dt><dd>An int displaying how many nodes are in the graph (id_to_nodes.size())</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code" href="a01101.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code" href="a01097.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> id_count = graph.<a class="code" href="a01097.html#a2710af2a75976862d7a235793567d2f3">size</a>();          <span class="comment">// We retrieve the size of the node id count within graph (3)</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00098_source.html#l00020">20</a> of file <a class="el" href="a00098_source.html">graph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00056_source.html#l00020">HF::Pathfinding::BoostGraph::BoostGraph()</a>.</p>

</div>
</div>
<a id="a3640461d4c1d1ff55dd200fd5670bf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3640461d4c1d1ff55dd200fd5670bf9c">&#9670;&nbsp;</a></span>UpdateIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::UpdateIDs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an empty node for this new id </p>
<div class="fragment"><div class="line">TODO example</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a77d4522c02692328c767ff439ca6511a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d4522c02692328c767ff439ca6511a">&#9670;&nbsp;</a></span>edge_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt;float, 1&gt; HF::SpatialStructures::Graph::edge_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains all edges between nodes. </p>

<p class="definition">Definition at line <a class="el" href="a00101_source.html#l00086">86</a> of file <a class="el" href="a00101_source.html">graph.h</a>.</p>

</div>
</div>
<a id="ab6515ac2323a16e27adab7b20561a649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6515ac2323a16e27adab7b20561a649">&#9670;&nbsp;</a></span>id_to_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; HF::SpatialStructures::Graph::id_to_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a list that indexes ordered_nodes with ids </p>

<p class="definition">Definition at line <a class="el" href="a00101_source.html#l00084">84</a> of file <a class="el" href="a00101_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a4da5e288f03773d18053c82731369b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da5e288f03773d18053c82731369b2a">&#9670;&nbsp;</a></span>idmap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">robin_hood::unordered_map&lt;<a class="el" href="a01101.html">Node</a>, int&gt; HF::SpatialStructures::Graph::idmap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list of X,Y,Z positions to ids. </p>

<p class="definition">Definition at line <a class="el" href="a00101_source.html#l00085">85</a> of file <a class="el" href="a00101_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a1cbd600663187d7cf985e9b6e7cea73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbd600663187d7cf985e9b6e7cea73f">&#9670;&nbsp;</a></span>needs_compression</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::needs_compression = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The CSR is inaccurate and requires compression. </p>

<p class="definition">Definition at line <a class="el" href="a00101_source.html#l00089">89</a> of file <a class="el" href="a00101_source.html">graph.h</a>.</p>

</div>
</div>
<a id="aaab13304c641df6fdcd3662d5c54dc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab13304c641df6fdcd3662d5c54dc78">&#9670;&nbsp;</a></span>next_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::next_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ID of the next unique node. </p>

<p class="definition">Definition at line <a class="el" href="a00101_source.html#l00087">87</a> of file <a class="el" href="a00101_source.html">graph.h</a>.</p>

</div>
</div>
<a id="ad59ab7164b64e3d78b7032b28c2c6663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59ab7164b64e3d78b7032b28c2c6663">&#9670;&nbsp;</a></span>ordered_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a01101.html">Node</a>&gt; HF::SpatialStructures::Graph::ordered_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A ordered list of nodes with ids. </p>

<p class="definition">Definition at line <a class="el" href="a00101_source.html#l00083">83</a> of file <a class="el" href="a00101_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a1cf07c256da74c2a03f81b4977364e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf07c256da74c2a03f81b4977364e85">&#9670;&nbsp;</a></span>triplets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Triplet&lt;float&gt; &gt; HF::SpatialStructures::Graph::triplets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector of Triplet, type float </p>

<p class="definition">Definition at line <a class="el" href="a00101_source.html#l00088">88</a> of file <a class="el" href="a00101_source.html">graph.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Cpp/spatialstructures/src/<a class="el" href="a00101_source.html">graph.h</a></li>
<li>Cpp/spatialstructures/src/<a class="el" href="a00098_source.html">graph.cpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aa01097_html_afccd105c93a826bde0457449f774fd04"><div class="ttname"><a href="a01097.html#afccd105c93a826bde0457449f774fd04">HF::SpatialStructures::Graph::GetCSRPointers</a></div><div class="ttdeci">CSRPtrs GetCSRPointers()</div><div class="ttdoc">Obtain pointers to the 3 arrays of the CSR, as well as any extra info that may be necesary to use the...</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00030">graph.cpp:30</a></div></div>
<div class="ttc" id="aa01097_html_aeddbbec01c6354b7076f47f71fc1a220"><div class="ttname"><a href="a01097.html#aeddbbec01c6354b7076f47f71fc1a220">HF::SpatialStructures::Graph::NodesAsFloat3</a></div><div class="ttdeci">std::vector&lt; std::array&lt; float, 3 &gt; &gt; NodesAsFloat3() const</div><div class="ttdoc">Get a list of nodes as arrays of floats</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00269">graph.cpp:269</a></div></div>
<div class="ttc" id="aa01101_html"><div class="ttname"><a href="a01101.html">HF::SpatialStructures::Node</a></div><div class="ttdoc">A point in space with an ID</div><div class="ttdef"><b>Definition:</b> <a href="a00104_source.html#l00028">node.h:28</a></div></div>
<div class="ttc" id="aa01097_html_a1a26ebb794b444e2214cf0b0fed5a529"><div class="ttname"><a href="a01097.html#a1a26ebb794b444e2214cf0b0fed5a529">HF::SpatialStructures::Graph::GetEdges</a></div><div class="ttdeci">std::vector&lt; EdgeSet &gt; GetEdges() const</div><div class="ttdoc">Get every edge/node in the given graph as IDs</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00073">graph.cpp:73</a></div></div>
<div class="ttc" id="aa01097_html_a994dbd15119eb6548d2e15f4de4b88a6"><div class="ttname"><a href="a01097.html#a994dbd15119eb6548d2e15f4de4b88a6">HF::SpatialStructures::Graph::Clear</a></div><div class="ttdeci">void Clear()</div><div class="ttdoc">Clear all nodes and edges in the graph.</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00305">graph.cpp:305</a></div></div>
<div class="ttc" id="aa01101_html_a51c4642674d54d02b8600f7ffeb45670"><div class="ttname"><a href="a01101.html#a51c4642674d54d02b8600f7ffeb45670">HF::SpatialStructures::Node::getArray</a></div><div class="ttdeci">std::array&lt; float, 3 &gt; getArray() const</div><div class="ttdoc">Returns the x,y,z of this node as an array of 3 floats</div><div class="ttdef"><b>Definition:</b> <a href="a01396_source.html#l00140">node.cpp:140</a></div></div>
<div class="ttc" id="aa01097_html_af59beedafb4af0ee99d54761e1c681fc"><div class="ttname"><a href="a01097.html#af59beedafb4af0ee99d54761e1c681fc">HF::SpatialStructures::Graph::getID</a></div><div class="ttdeci">int getID(const Node &amp;node) const</div><div class="ttdoc">Retrieve the ID for the given node.</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00022">graph.cpp:22</a></div></div>
<div class="ttc" id="aa01097_html_a604a648f1f73d687ad4544d2ac163212"><div class="ttname"><a href="a01097.html#a604a648f1f73d687ad4544d2ac163212">HF::SpatialStructures::Graph::addEdge</a></div><div class="ttdeci">void addEdge(const Node &amp;parent, const Node &amp;child, float score=1.0f)</div><div class="ttdoc">Construct a new edge for the graph from parent and child pair. If the parent is not in the graph as a...</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00158">graph.cpp:158</a></div></div>
<div class="ttc" id="aa01097_html_a794c342603cefb342fdc698ba539b25f"><div class="ttname"><a href="a01097.html#a794c342603cefb342fdc698ba539b25f">HF::SpatialStructures::Graph::NodeFromID</a></div><div class="ttdeci">Node NodeFromID(int id) const</div><div class="ttdoc">Retrieve the node that corresponds to id</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00048">graph.cpp:48</a></div></div>
<div class="ttc" id="aa01097_html_a9f521e01db7e3c038ab2c1fac09b67df"><div class="ttname"><a href="a01097.html#a9f521e01db7e3c038ab2c1fac09b67df">HF::SpatialStructures::Graph::GetUndirectedEdges</a></div><div class="ttdeci">std::vector&lt; Edge &gt; GetUndirectedEdges(const Node &amp;N) const</div><div class="ttdoc">Get a list of edges to and from node N</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00054">graph.cpp:54</a></div></div>
<div class="ttc" id="aa00174_html_a6b23c0b2531c78f6d5049873c184f4f9"><div class="ttname"><a href="a00174.html#a6b23c0b2531c78f6d5049873c184f4f9">HF::SpatialStructures::COST_AGGREGATE</a></div><div class="ttdeci">COST_AGGREGATE</div><div class="ttdoc">TODO summary</div><div class="ttdef"><b>Definition:</b> <a href="a00101_source.html#l00029">graph.h:29</a></div></div>
<div class="ttc" id="aa01097_html_a41cece77d0eee98df39ecc6d3a366ec8"><div class="ttname"><a href="a01097.html#a41cece77d0eee98df39ecc6d3a366ec8">HF::SpatialStructures::Graph::Compress</a></div><div class="ttdeci">void Compress()</div><div class="ttdoc">Compress the graph, significantly reducing memory usage, but disabling insertion.</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00295">graph.cpp:295</a></div></div>
<div class="ttc" id="aa01097_html_aa70347b8a33b57c6f0a72d6eca4248d7"><div class="ttname"><a href="a01097.html#aa70347b8a33b57c6f0a72d6eca4248d7">HF::SpatialStructures::Graph::Nodes</a></div><div class="ttdeci">std::vector&lt; Node &gt; Nodes() const</div><div class="ttdoc">Get a list of nodes from the graph sorted by ID</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00050">graph.cpp:50</a></div></div>
<div class="ttc" id="aa01097_html_a4de020064d58c4ab376a26c30be863a3"><div class="ttname"><a href="a01097.html#a4de020064d58c4ab376a26c30be863a3">HF::SpatialStructures::Graph::hasKey</a></div><div class="ttdeci">bool hasKey(const Node &amp;n) const</div><div class="ttdoc">Tell whether or not the graph has the given node in it as a parent</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00267">graph.cpp:267</a></div></div>
<div class="ttc" id="aa01097_html"><div class="ttname"><a href="a01097.html">HF::SpatialStructures::Graph</a></div><div class="ttdoc">A HF Graph similar to the one stored in python Invariants: 1) Always stores a valid graph 2) Every no...</div><div class="ttdef"><b>Definition:</b> <a href="a00101_source.html#l00080">graph.h:80</a></div></div>
<div class="ttc" id="aa01097_html_a3285be5da987692e0b3671f49d67d21b"><div class="ttname"><a href="a01097.html#a3285be5da987692e0b3671f49d67d21b">HF::SpatialStructures::Graph::AggregateGraph</a></div><div class="ttdeci">std::vector&lt; float &gt; AggregateGraph(COST_AGGREGATE agg_type, bool directed=true) const</div><div class="ttdoc">Generate an ordered list of scores for the graph</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00115">graph.cpp:115</a></div></div>
<div class="ttc" id="aa01097_html_a2710af2a75976862d7a235793567d2f3"><div class="ttname"><a href="a01097.html#a2710af2a75976862d7a235793567d2f3">HF::SpatialStructures::Graph::size</a></div><div class="ttdeci">int size() const</div><div class="ttdoc">Determine how many nodes are in the graph</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00020">graph.cpp:20</a></div></div>
<div class="ttc" id="aa01097_html_af00121404a647b0d619f201cf9ebc797"><div class="ttname"><a href="a01097.html#af00121404a647b0d619f201cf9ebc797">HF::SpatialStructures::Graph::HasEdge</a></div><div class="ttdeci">bool HasEdge(const std::array&lt; float, 3 &gt; &amp;parent, const std::array&lt; float, 3 &gt; &amp;child, bool undirected=false) const</div><div class="ttdoc">Determine if the graph has an edge with this parent and child, by constructing temporary Node (using ...</div><div class="ttdef"><b>Definition:</b> <a href="a00098_source.html#l00260">graph.cpp:260</a></div></div>
<div class="ttc" id="aa00174_html_a6b23c0b2531c78f6d5049873c184f4f9a16de38737a9f8366e9b2042b4e9b6290"><div class="ttname"><a href="a00174.html#a6b23c0b2531c78f6d5049873c184f4f9a16de38737a9f8366e9b2042b4e9b6290">HF::SpatialStructures::COST_AGGREGATE::AVERAGE</a></div><div class="ttdeci">@ AVERAGE</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
