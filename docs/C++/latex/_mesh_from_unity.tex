Previous Tutorial\+: \mbox{\hyperlink{_generating_a_graph}{The Graph Generator}}


\begin{DoxyItemize}
\item \href{\#reading-a-mesh-from-unity-meshfromunity}{\texttt{ Reading a Mesh From Unity \{\#\+Mesh\+From\+Unity\}}}
\begin{DoxyItemize}
\item \href{\#intro}{\texttt{ Intro}}
\item \href{\#scene-setup}{\texttt{ Scene Setup}}
\begin{DoxyItemize}
\item \href{\#creating-the-plane}{\texttt{ Creating the Plane}}
\item \href{\#resetting-the-planes-position}{\texttt{ Resetting the Plane\textquotesingle{}s Position}}
\end{DoxyItemize}
\item \href{\#writing-the-script}{\texttt{ Writing the Script}}
\begin{DoxyItemize}
\item \href{\#set-usings}{\texttt{ Set Usings}}
\item \href{\#setup-for-adding-references-through-the-unity-inspector}{\texttt{ Setup for adding references through the unity inspector}}
\item \href{\#passing-meshes-from-gameobjects-to-humanfactors}{\texttt{ Passing Meshes from Game\+Objects to Human\+Factors}}
\begin{DoxyItemize}
\item \href{\#getting-a-reference-to-the-mesh-held-by-a-specific-game-object}{\texttt{ Getting a reference to the mesh held by a specific Game Object}}
\item \href{\#getting-the-vertices-and-triangles-from-a-unity-mesh}{\texttt{ Getting the vertices and triangles from a Unity Mesh}}
\item \href{\#transforming-the-mesh-from-y-up-to-z-up}{\texttt{ Transforming the Mesh from Y-\/\+Up to Z-\/\+Up}}
\end{DoxyItemize}
\end{DoxyItemize}
\item \href{\#executing-the-script}{\texttt{ Executing the Script}}
\begin{DoxyItemize}
\item \href{\#adding-references-through-the-unity-inspector}{\texttt{ Adding References Through the Unity Inspector}}
\item \href{\#comparing-output}{\texttt{ Comparing Output}}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{_mesh_from_unity_autotoc_md28}{}\doxysection{Intro}\label{_mesh_from_unity_autotoc_md28}
This tutorial will demonstrate how to pass geometry from the scene in Unity to Human Factors. We\textquotesingle{}ll be using the project created in the previous guide\+: H\+:/\+H\+F\+Gitlab/\+Analysis/docs/C\# Documentation/markdown/3\+\_\+graph\+\_\+generator.\+md \char`\"{}\+The Graph Generator\char`\"{}, and we\textquotesingle{}ll be using concepts covered in the previous guides.\hypertarget{_mesh_from_unity_autotoc_md29}{}\doxysection{Scene Setup}\label{_mesh_from_unity_autotoc_md29}
Up until this point, we haven\textquotesingle{}t needed to interact with the unity scene, aside script to the camera game object that\textquotesingle{}s already there. In order for us to demonstrate reading geometry from the scene, we must first create geometry in the scene. For this example, we will create a plane in unity instead of creating our own plane in code.

To begin, open up the unity project from H\+:/\+H\+F\+Gitlab/\+Analysis/docs/C\# Documentation/markdown/3\+\_\+graph\+\_\+generator.\+md \char`\"{}\+The Graph Generator\char`\"{}.



From here we will create a new plane then translate it directly to the origin.\hypertarget{_mesh_from_unity_autotoc_md30}{}\doxysubsection{Creating the Plane}\label{_mesh_from_unity_autotoc_md30}
Using the menubar at the top of the screen select Game\+Object $>$ 3D Object $>$ Plane.



Once clicked, a new 1x1 plane will be created, however it may not have been created at the origin exactly. For this tutorial we will reset the plane\textquotesingle{}s position just be be sure it\textquotesingle{}s always placed exactly in the same place.\hypertarget{_mesh_from_unity_autotoc_md31}{}\doxysubsection{Resetting the Plane\textquotesingle{}s Position}\label{_mesh_from_unity_autotoc_md31}
Left Click on the newly created plane and look at {\bfseries{Transform}} header in the Inspector located at the right sidebar.



Under {\bfseries{Transform}} you can see the plane\textquotesingle{}s position, rotation and scale within the scene. To set the plane\textquotesingle{}s position to the origin, left on the three dots to the right of the transform header, and select {\itshape Reset Position}.



After clicking that button, your plane should be moved to the origin like in the image below. Ensure the position, rotation and scale values in the transform section completely match those of the image.



Now that we have the plane ready to go, we can begin working on the script to get its vertices and triangles.\hypertarget{_mesh_from_unity_autotoc_md32}{}\doxysection{Writing the Script}\label{_mesh_from_unity_autotoc_md32}
Open up the New Behavior script we created in the H\+:/\+H\+F\+Gitlab/\+Analysis/docs/C\# Documentation/markdown/3\+\_\+graph\+\_\+generator.\+md \char`\"{}previous tutorial\char`\"{}\hypertarget{_mesh_from_unity_autotoc_md33}{}\doxysubsection{Set Usings}\label{_mesh_from_unity_autotoc_md33}
Just like last time, we\textquotesingle{}re going to declare which namespaces this script will use in the using section. Graph\+On\+Plane will require the same usings as the previous project as well as the Graph Generator Namespace


\begin{DoxyCode}{0}
\DoxyCodeLine{using HumanFactors.Geometry;}
\DoxyCodeLine{using HumanFactors.RayTracing;}
\DoxyCodeLine{using HumanFactors.GraphGenerator;}
\DoxyCodeLine{using HumanFactors.SpatialStructures;}
\end{DoxyCode}


Your usings for this script should look like this.

\hypertarget{_mesh_from_unity_autotoc_md34}{}\doxysubsection{Setup for adding references through the unity inspector}\label{_mesh_from_unity_autotoc_md34}
Before we can worry about generating the graph, first we need to get the mesh from the Plane Gameobject we created in the Unity Editor. There are many ways to reference a Game\+Object from a script code, but for this example we\textquotesingle{}ll be setting up our script so we can select the mesh to use from the scene in the Unity Inspector. For now, all we need to do is declare a Game\+Object member for our new class as shown below.


\begin{DoxyCode}{0}
\DoxyCodeLine{GameObject PlaneReference;}
\end{DoxyCode}




Later we\textquotesingle{}ll use the unity inspector to assign the plane we created in the scene to this object\hypertarget{_mesh_from_unity_autotoc_md35}{}\doxysubsection{Passing Meshes from Game\+Objects to Human\+Factors}\label{_mesh_from_unity_autotoc_md35}
Now that we have a reference to the plane game object we want to use, we need to get the raw vertices and faces of plane so we can pass it to Human\+Factors for use in the graph generator.\hypertarget{_mesh_from_unity_autotoc_md36}{}\doxysubsubsection{Getting a reference to the mesh held by a specific Game Object}\label{_mesh_from_unity_autotoc_md36}
Before we can extract the triangles and vertices from one an instance of a Unity Mesh, we first need to get a reference to the Mesh itself. Doing this requires some understanding of Unity Game\+Objects and their components. Tabbing back over to Unity for a moment, clicking on the plane, then looking at the inspector in the right reveals that the plane we see in the scene isn\textquotesingle{}t just a mesh, but is in fact a \href{https://docs.unity3d.com/Manual/class-GameObject.html}{\texttt{ {\bfseries{Game\+Object}}}} comprised of several different components.



As stated in the Unity Documentation\+:

\begin{quote}
Game\+Objects are the fundamental objects in Unity that represent characters, props and scenery. They do not accomplish much in themselves but they act as containers for Components, which implement the real functionality. For example, a Light object is created by attaching a Light component to a Game\+Object. \end{quote}


So in short, the Game\+Object for the plane won\textquotesingle{}t give us the information we need. Instead we need to get a reference to the Game\+Object\textquotesingle{}s component that carries the Mesh\+: The \href{https://docs.unity3d.com/Manual/class-MeshFilter.html}{\texttt{ {\bfseries{Mesh\+Filter}}}}. Thankfully getting a reference to a component of a Game Object is easy, all you need to do is call the \href{https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html}{\texttt{ Get\+Component}} member function of the game object you want to get a component from.

In our script we will store a reference to the plane\textquotesingle{}s mesh filter in a variable creatively named {\ttfamily Filter} at the beginning of Graph\+Of\+Plane\textquotesingle{}s Start() function like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{C\#\}}
\DoxyCodeLine{       MeshFilter Filter = PlaneReference.GetComponent<MeshFilter>();}
\end{DoxyCode}


Then we\textquotesingle{}ll access the actual mesh carried by {\ttfamily Filter} by calling its .mesh property


\begin{DoxyCode}{0}
\DoxyCodeLine{Mesh PlaneMesh = Filter.mesh;}
\end{DoxyCode}
\hypertarget{_mesh_from_unity_autotoc_md37}{}\doxysubsubsection{Getting the vertices and triangles from a Unity Mesh}\label{_mesh_from_unity_autotoc_md37}
We\textquotesingle{}re not out of the woods yet. For Human Factors to use a mesh it needs two things\+:

1) The (x,y,z) location of every vertex that comprises the mesh as an array of floats. 2) The Indexes for each triangle or \char`\"{}\+Face\char`\"{} of the mesh as an array of integers.

Fortunately, Unity provides an easy way to access the triangles of a mesh, but unfortunately the vertices only come in an array of Vector3. To simplify the process of converting the vertices to a suitable format, we will add a seperate method called \char`\"{}\+Flatten\+Vertex\+Array\char`\"{} that will transform the array of Vector3 into an array of float ready for Human Factors.

Just above Start(), add the following Method\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{private float[] FlattenVertexArray(Vector3[] vertices)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    float[] return\_array = new float[vertices.Length * 3];}
\DoxyCodeLine{    for (int i = 0; i < vertices.Length; i++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        int os = i * 3;}
\DoxyCodeLine{        return\_array[os] = vertices[i].x;}
\DoxyCodeLine{        return\_array[os + 1] = vertices[i].y;}
\DoxyCodeLine{        return\_array[os + 2] = vertices[i].z;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    return return\_array;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\hypertarget{_mesh_from_unity_autotoc_md38}{}\doxysubsubsection{Transforming the Mesh from Y-\/\+Up to Z-\/\+Up}\label{_mesh_from_unity_autotoc_md38}
But wait, there\textquotesingle{}s one more step involved when directly pulling meshes from Unity. Another quick peek at the editor in the top right corner reveals that Unity\textquotesingle{}s coordinate system is fundamentally different from the coordinate system needed by Human Factors.

 

The Graph Generator expects geometry to be stored as if the Z-\/\+Axis were up as shown in the right picture. Unity however, the Y-\/\+Axis is up as shown in the left picture, meaning that we\textquotesingle{}ll get inaccurate results if we use the meshes as is. To solve this, Mesh\+Info has a method Rotate\+Mesh that can easily rotate Mesh\+Info objects after they\textquotesingle{}ve been created. Another class in the Geometry namespace titled Common\+Rotations contains the rotation necessary to perform this conversion.

With all this in mind, here is the code to prepare the mesh.


\begin{DoxyCode}{0}
\DoxyCodeLine{\{C\#\}}
\DoxyCodeLine{       // Get Triangle Indexes and Vertices from the Mesh }
\DoxyCodeLine{       int[] tris = PlaneMesh.triangles;}
\DoxyCodeLine{       Vector3[] vertices = PlaneMesh.vertices;}
\DoxyCodeLine{}
\DoxyCodeLine{       // Send to HumanFactors}
\DoxyCodeLine{       MeshInfo PlaneMeshInfo = new MeshInfo(tris, FlattenVertexArray(vertices));}
\DoxyCodeLine{}
\DoxyCodeLine{       //Rotate to Z-\/Up}
\DoxyCodeLine{       PlaneMeshInfo.RotateMesh(CommonRotations.Yup\_To\_Zup);}
\end{DoxyCode}


Your end file should look like the following\+:



screenshot, so instead I\textquotesingle{}ll just post the full code in this document here.\hypertarget{_mesh_from_unity_autotoc_md39}{}\doxysection{Executing the Script}\label{_mesh_from_unity_autotoc_md39}
\hypertarget{_mesh_from_unity_autotoc_md40}{}\doxysubsection{Adding References Through the Unity Inspector}\label{_mesh_from_unity_autotoc_md40}
\hypertarget{_mesh_from_unity_autotoc_md41}{}\doxysubsection{Comparing Output}\label{_mesh_from_unity_autotoc_md41}
