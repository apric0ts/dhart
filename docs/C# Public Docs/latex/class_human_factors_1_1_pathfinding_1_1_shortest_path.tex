\hypertarget{class_human_factors_1_1_pathfinding_1_1_shortest_path}{}\doxysection{Human\+Factors.\+Pathfinding.\+Shortest\+Path Class Reference}
\label{class_human_factors_1_1_pathfinding_1_1_shortest_path}\index{HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}}


Functions for finding the shortest path between two nodes in a graph.  


\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}} \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_adc3fbf31af391a4ce9efd911c0c74fee}{Dijkstra\+Shortest\+Path}} (\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}} graph, int start\+\_\+id, int end\+\_\+id, string cost\+\_\+type=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Perform Dijkstra\textquotesingle{}s shortest path algorithm to find a path between two nodes. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}} \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_a394c96543ad621b2e5d98554153d74b4}{Dijkstra\+Shortest\+Path}} (\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}} graph, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} start\+\_\+node, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} end\+\_\+node, string cost\+\_\+type=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Perform Dijkstra\textquotesingle{}s shortest path algorithm to find a path between two nodes. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}}\mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_ab7f58f298125194e33d6c69ed4797442}{Dijkstra\+Shortest\+Path\+Multi}} (\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}} graph, int\mbox{[}$\,$\mbox{]} start\+\_\+ids, int\mbox{[}$\,$\mbox{]} end\+\_\+ids, string cost\+\_\+type=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Find the shortest paths between each pair of start\+\_\+id and end\+\_\+id in order. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}}\mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_a9fb6fc6aff938136f7f9de42e5d8e5bc}{Dijkstra\+Shortest\+Path\+Multi}} (\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}} graph, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ start\+\_\+nodes, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ end\+\_\+nodes, string cost\+\_\+type=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Find the shortest paths between each pair of start\+\_\+id and end\+\_\+id in order. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}}\mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_a3ede2597cc17a4f1a130741b0163bbab}{Dijkstra\+All\+To\+All}} (\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}} g, string cost\+\_\+type=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Generate a path from every node in the graph to every other node in a graph. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_abf65038bac66da2c403034c05f83bee9}{Generate\+Predecessor\+And\+Distance\+Matricies}} (\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}} g, out \mbox{\hyperlink{class_human_factors_1_1_native_utils_1_1_common_native_arrays_1_1_unmanaged_float_array2_d}{Unmanaged\+Float\+Array2D}} out\+\_\+dist, out \mbox{\hyperlink{class_human_factors_1_1_native_utils_1_1_common_native_arrays_1_1_unmanaged_int_array2_d}{Unmanaged\+Int\+Array2D}} out\+\_\+predecessor, string cost\+\_\+type=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Calculate Predecessor and Distance Matricies for a graph. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Functions for finding the shortest path between two nodes in a graph. 

\begin{DoxyRemark}{Remarks}
The shortest path functions will use Dijkstra\textquotesingle{}s algorithm to find the shortest path between one or more nodes in a Graph. Since the graph can hold multiple costs for each contained edge, the type of cost used in this calculation can be specified for each function. This allows for paths to be generated using costs generated by the Cost\+Algorithms in \mbox{\hyperlink{namespace_human_factors_1_1_spatial_structures}{Spatial\+Structures}} such as cross slope, or energy expenditure.
\end{DoxyRemark}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path}{Shortest\+Path}} for generating a single path between two nodes. 

\mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_adc3fbf31af391a4ce9efd911c0c74fee}{Dijkstra\+Shortest\+Path}} for generating multiple paths at once. 

\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Spatial\+Structures.\+Graph}} for more information on how it stores multiple costs. 
\end{DoxySeeAlso}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_human_factors_1_1_pathfinding_1_1_shortest_path_a3ede2597cc17a4f1a130741b0163bbab}\label{class_human_factors_1_1_pathfinding_1_1_shortest_path_a3ede2597cc17a4f1a130741b0163bbab}} 
\index{HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}!DijkstraAllToAll@{DijkstraAllToAll}}
\index{DijkstraAllToAll@{DijkstraAllToAll}!HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}}
\doxysubsubsection{\texorpdfstring{DijkstraAllToAll()}{DijkstraAllToAll()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}} \mbox{[}$\,$\mbox{]} Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Dijkstra\+All\+To\+All (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}}}]{g,  }\item[{string}]{cost\+\_\+type = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Generate a path from every node in the graph to every other node in a graph. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph to generate paths in. \\
\hline
{\em cost\+\_\+type} & Type of cost to use for path generation. If left blank will use the default cost of the graph\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of paths with a length equal to the number of nodes in {\ttfamily g} squared. Paths will be returned in order starting with all paths from node 0, then all paths from node 1, etc. If a path could not be generated between a set of nodes, then path at that index will be null.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
If {\ttfamily cost\+\_\+type} is not left as the default, then it must be the name of a valid cost already defined in {\ttfamily graph}.
\end{DoxyPrecond}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Not\+Found\+Exception} & {\ttfamily cost\+\_\+type} wasn\textquotesingle{}t left as blank, and didn\textquotesingle{}t refer to the name of any cost that already exists in {\ttfamily graph}.\\
\hline
\end{DoxyExceptions}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{            }
\DoxyCodeLine{            \textcolor{comment}{// Create a graph and add some edges}}
\DoxyCodeLine{            Graph g = \textcolor{keyword}{new} Graph();}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Create nodes and add edges to the graph}}
\DoxyCodeLine{            Vector3D[] Nodes =}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keyword}{new} Vector3D(0,0,1),}
\DoxyCodeLine{                \textcolor{keyword}{new} Vector3D(0,0,2),}
\DoxyCodeLine{                \textcolor{keyword}{new} Vector3D(0,0,3),}
\DoxyCodeLine{                \textcolor{keyword}{new} Vector3D(0,0,4)}
\DoxyCodeLine{            \}; }
\DoxyCodeLine{}
\DoxyCodeLine{            g.AddEdge(Nodes[0], Nodes[1], 10);}
\DoxyCodeLine{            g.AddEdge(Nodes[0], Nodes[2], 30);}
\DoxyCodeLine{            g.AddEdge(Nodes[0], Nodes[3], 30);}
\DoxyCodeLine{            g.AddEdge(Nodes[1], Nodes[2], 15);}
\DoxyCodeLine{            g.AddEdge(Nodes[3], Nodes[1], 15);}
\DoxyCodeLine{            g.AddEdge(Nodes[2], Nodes[3], 5);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Compress the graph}}
\DoxyCodeLine{            g.CompressToCSR();}
\DoxyCodeLine{            }
\DoxyCodeLine{            \textcolor{comment}{// Generate all paths for this graph}}
\DoxyCodeLine{            var paths = ShortestPath.DijkstraAllToAll(g);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordtype}{string} output = \textcolor{stringliteral}{""};}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Iterate through the return values to print the path from every node to every other node}}
\DoxyCodeLine{            \textcolor{keywordtype}{int} num\_nodes = g.NumNodes();}
\DoxyCodeLine{            \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} start\_id = 0; start\_id < num\_nodes; start\_id++)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} end\_id = 0; end\_id < num\_nodes; end\_id++)}
\DoxyCodeLine{                \{}
\DoxyCodeLine{                    \textcolor{comment}{// If this is a node to itself then continue}}
\DoxyCodeLine{                    \textcolor{keywordflow}{if} (start\_id == end\_id) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{}
\DoxyCodeLine{                    \textcolor{comment}{// get the path from parent id to child id}}
\DoxyCodeLine{                    \textcolor{keywordtype}{int} path\_index = (start\_id * num\_nodes) + end\_id;}
\DoxyCodeLine{                    Path start\_to\_end = paths[path\_index];}
\DoxyCodeLine{}
\DoxyCodeLine{                    \textcolor{comment}{// Only print the path if it was able to be found}}
\DoxyCodeLine{                    \textcolor{keywordflow}{if} (start\_to\_end != \textcolor{keyword}{null})}
\DoxyCodeLine{                        output += String.Format(\textcolor{stringliteral}{"\{0\} -\/> \{1\} : \{2\}"}, start\_id, end\_id, start\_to\_end) + \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{                    \textcolor{keywordflow}{else}}
\DoxyCodeLine{                        output += String.Format(\textcolor{stringliteral}{"\{0\} -\/> \{1\} : \{2\}"}, start\_id, end\_id, \textcolor{stringliteral}{"[None]"}) + \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{                \}}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print output}}
\DoxyCodeLine{            Debug.WriteLine(output);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{0 -\/> 1 : [(0, 10), (1, 0)]}
\DoxyCodeLine{0 -\/> 2 : [(0, 10), (1, 15), (2, 0)]}
\DoxyCodeLine{0 -\/> 3 : [(0, 30), (3, 0)]}
\DoxyCodeLine{1 -\/> 0 : [None]}
\DoxyCodeLine{1 -\/> 2 : [(1, 15), (2, 0)]}
\DoxyCodeLine{1 -\/> 3 : [(1, 15), (2, 5), (3, 0)]}
\DoxyCodeLine{2 -\/> 0 : [None]}
\DoxyCodeLine{2 -\/> 1 : [(2, 5), (3, 15), (1, 0)]}
\DoxyCodeLine{2 -\/> 3 : [(2, 5), (3, 0)]}
\DoxyCodeLine{3 -\/> 0 : [None]}
\DoxyCodeLine{3 -\/> 1 : [(3, 15), (1, 0)]}
\DoxyCodeLine{3 -\/> 2 : [(3, 15), (1, 15), (2, 0)]}
\end{DoxyCode}
 
\end{DoxyParagraph}


References Human\+Factors.\+Spatial\+Structures.\+Graph.\+Num\+Nodes().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_human_factors_1_1_pathfinding_1_1_shortest_path_a3ede2597cc17a4f1a130741b0163bbab_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_human_factors_1_1_pathfinding_1_1_shortest_path_adc3fbf31af391a4ce9efd911c0c74fee}\label{class_human_factors_1_1_pathfinding_1_1_shortest_path_adc3fbf31af391a4ce9efd911c0c74fee}} 
\index{HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}!DijkstraShortestPath@{DijkstraShortestPath}}
\index{DijkstraShortestPath@{DijkstraShortestPath}!HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}}
\doxysubsubsection{\texorpdfstring{DijkstraShortestPath()}{DijkstraShortestPath()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}} Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Dijkstra\+Shortest\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}}}]{graph,  }\item[{int}]{start\+\_\+id,  }\item[{int}]{end\+\_\+id,  }\item[{string}]{cost\+\_\+type = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Perform Dijkstra\textquotesingle{}s shortest path algorithm to find a path between two nodes. 


\begin{DoxyParams}{Parameters}
{\em graph} & The graph to conduct the search on. \\
\hline
{\em start\+\_\+id} & The ID of the node to start at. \\
\hline
{\em end\+\_\+id} & The ID of the node to find a path to. \\
\hline
{\em cost\+\_\+type} & The type of cost to use for generating the path. If left blank, will use the cost that the graph was created with. In the case of the graph generator, the default cost is distance.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The shortest path from start\+\_\+node to end\+\_\+node or null if no path could be found.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
1) {\ttfamily start\+\_\+id} and {\ttfamily end\+\_\+id} must be the X,Y,Z position of nodes that already exist in {\ttfamily graph}. 

2) If {\ttfamily cost\+\_\+type} is not left as the default, then it must be the name of a valid cost already defined in {\ttfamily graph}.
\end{DoxyPrecond}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Not\+Found\+Exception} & {\ttfamily cost\+\_\+type} wasn\textquotesingle{}t left as blank, and didn\textquotesingle{}t refer to the name of any cost that already exists in the graph.\\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_ab7f58f298125194e33d6c69ed4797442}{Dijkstra\+Shortest\+Path\+Multi}} for efficently generating multiple paths in parallel.
\end{DoxySeeAlso}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{            \textcolor{comment}{// Load the OBJ from ddisk}}
\DoxyCodeLine{            var blob = OBJLoader.LoadOBJ(\textcolor{stringliteral}{"ExampleModels/energy\_blob\_zup.obj"});}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a BVH from it }}
\DoxyCodeLine{            EmbreeBVH bvh = \textcolor{keyword}{new} EmbreeBVH(blob, \textcolor{keyword}{true});}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Setup graph variables}}
\DoxyCodeLine{            Vector3D start\_point = \textcolor{keyword}{new} Vector3D(-\/30, 0, 20);}
\DoxyCodeLine{            Vector3D spacing = \textcolor{keyword}{new} Vector3D(1, 1, 10);}
\DoxyCodeLine{            \textcolor{keywordtype}{int} max\_nodes = 10000;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} up\_step = 5.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} down\_step = 5.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} up\_slope = 60.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} down\_slope = 60.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{int} max\_step\_connections = 1;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a graph}}
\DoxyCodeLine{            var graph = \mbox{\hyperlink{namespace_human_factors}{HumanFactors}}.\mbox{\hyperlink{namespace_human_factors_1_1_graph_generator}{GraphGenerator}}.\mbox{\hyperlink{class_human_factors_1_1_graph_generator_1_1_graph_generator}{GraphGenerator}}.\mbox{\hyperlink{class_human_factors_1_1_graph_generator_1_1_graph_generator_a2672814edcde623d71233353fe6e0d2f}{GenerateGraph}}(}
\DoxyCodeLine{                bvh,}
\DoxyCodeLine{                start\_point,}
\DoxyCodeLine{                spacing,}
\DoxyCodeLine{                max\_nodes,}
\DoxyCodeLine{                up\_step,}
\DoxyCodeLine{                down\_step,}
\DoxyCodeLine{                up\_slope,}
\DoxyCodeLine{                down\_slope,}
\DoxyCodeLine{                max\_step\_connections,}
\DoxyCodeLine{                -\/1}
\DoxyCodeLine{            );}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Compress the graph so we can use it with pathfinding}}
\DoxyCodeLine{            graph.CompressToCSR();}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Calculate an alternate set of costs for the graph based on Energy Expenditure}}
\DoxyCodeLine{            CostAlgorithms.CalculateAndStoreEnergyExpenditure(graph);}
\DoxyCodeLine{            }
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Predeclare paths}}
\DoxyCodeLine{            Path energy\_path, distance\_path;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Get the unique key of this cost type. We'll use this to tell the pathfinder to generate}}
\DoxyCodeLine{            \textcolor{comment}{// a path using the cost set that we just generated.}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} energy\_key = CostAlgorithmNames.ENERGY\_EXPENDITURE;}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a graph using the alternate cost type, then generate one using the graph's}}
\DoxyCodeLine{            \textcolor{comment}{// default cost type, distance.}}
\DoxyCodeLine{            \textcolor{keywordtype}{int} start\_id = 1;}
\DoxyCodeLine{            \textcolor{keywordtype}{int} end\_id = 105;}
\DoxyCodeLine{            energy\_path = ShortestPath.DijkstraShortestPath(graph, start\_id, end\_id, energy\_key);}
\DoxyCodeLine{            distance\_path = ShortestPath.DijkstraShortestPath(graph, start\_id, end\_id);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print paths to output. }}
\DoxyCodeLine{            Debug.WriteLine(distance\_path);}
\DoxyCodeLine{            Debug.WriteLine(energy\_path);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{[(1, 1.415028), (12, 1.417536), (26, 1.417887), (39, 1.418485), (50, 1.000265), (63, 1.000128), (80, 1.000098), (105, 0)]}
\DoxyCodeLine{[(1, 4.559175), (12, 5.759251), (26, 5.889585), (39, 6.100943), (50, 2.978094), (63, 2.826927), (80, 2.784634), (105, 0)]}
\end{DoxyCode}
 
\end{DoxyParagraph}


Referenced by Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Dijkstra\+Shortest\+Path(), and String\+To\+Edge\+Cost.\+Main().

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_human_factors_1_1_pathfinding_1_1_shortest_path_adc3fbf31af391a4ce9efd911c0c74fee_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_human_factors_1_1_pathfinding_1_1_shortest_path_a394c96543ad621b2e5d98554153d74b4}\label{class_human_factors_1_1_pathfinding_1_1_shortest_path_a394c96543ad621b2e5d98554153d74b4}} 
\index{HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}!DijkstraShortestPath@{DijkstraShortestPath}}
\index{DijkstraShortestPath@{DijkstraShortestPath}!HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}}
\doxysubsubsection{\texorpdfstring{DijkstraShortestPath()}{DijkstraShortestPath()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}} Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Dijkstra\+Shortest\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}}}]{graph,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{start\+\_\+node,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{end\+\_\+node,  }\item[{string}]{cost\+\_\+type = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Perform Dijkstra\textquotesingle{}s shortest path algorithm to find a path between two nodes. 


\begin{DoxyParams}{Parameters}
{\em graph} & The graph to conduct the search on. \\
\hline
{\em start\+\_\+node} & The X,Y,Z of a node in the graph node to start at. \\
\hline
{\em end\+\_\+node} & The X,Y,Z of a node in the graph node to end at. \\
\hline
{\em cost\+\_\+type} & The type of cost to use for generating the path. If left blank, will use the cost that the graph was created with. In the case of the graph generator, the default cost is distance.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The shortest path from start\+\_\+node to end\+\_\+node or null if no path could be found.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
1) {\ttfamily start\+\_\+node} and {\ttfamily end\+\_\+node} must be the X,Y,Z position of nodes that already exist in {\ttfamily graph}. 

2) If {\ttfamily cost\+\_\+type} is not left as the default, then it must be the name of a valid cost already defined in {\ttfamily graph}.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Gets the start id and end of both nodes, then calls the ID overload.
\end{DoxyRemark}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Not\+Found\+Exception} & {\ttfamily cost\+\_\+type} wasn\textquotesingle{}t left as blank, and didn\textquotesingle{}t refer to the name of any cost that already exists in the graph.\\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_ab7f58f298125194e33d6c69ed4797442}{Dijkstra\+Shortest\+Path\+Multi}} for efficently generating multiple paths in parallel.
\end{DoxySeeAlso}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{            \textcolor{comment}{// Load the OBJ from ddisk}}
\DoxyCodeLine{            var blob = OBJLoader.LoadOBJ(\textcolor{stringliteral}{"ExampleModels/energy\_blob\_zup.obj"});}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a BVH from it }}
\DoxyCodeLine{            EmbreeBVH bvh = \textcolor{keyword}{new} EmbreeBVH(blob, \textcolor{keyword}{true});}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Setup graph variables}}
\DoxyCodeLine{            Vector3D start\_point = \textcolor{keyword}{new} Vector3D(-\/30, 0, 20);}
\DoxyCodeLine{            Vector3D spacing = \textcolor{keyword}{new} Vector3D(1, 1, 10);}
\DoxyCodeLine{            \textcolor{keywordtype}{int} max\_nodes = 10000;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} up\_step = 5.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} down\_step = 5.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} up\_slope = 60.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} down\_slope = 60.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{int} max\_step\_connections = 1;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a graph}}
\DoxyCodeLine{            var graph = \mbox{\hyperlink{namespace_human_factors}{HumanFactors}}.\mbox{\hyperlink{namespace_human_factors_1_1_graph_generator}{GraphGenerator}}.\mbox{\hyperlink{class_human_factors_1_1_graph_generator_1_1_graph_generator}{GraphGenerator}}.\mbox{\hyperlink{class_human_factors_1_1_graph_generator_1_1_graph_generator_a2672814edcde623d71233353fe6e0d2f}{GenerateGraph}}(}
\DoxyCodeLine{                bvh,}
\DoxyCodeLine{                start\_point,}
\DoxyCodeLine{                spacing,}
\DoxyCodeLine{                max\_nodes,}
\DoxyCodeLine{                up\_step,}
\DoxyCodeLine{                down\_step,}
\DoxyCodeLine{                up\_slope,}
\DoxyCodeLine{                down\_slope,}
\DoxyCodeLine{                max\_step\_connections,}
\DoxyCodeLine{                -\/1}
\DoxyCodeLine{            );}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Compress the graph so we can use it with pathfinding}}
\DoxyCodeLine{            graph.CompressToCSR();}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Calculate an alternate set of costs for the graph based on Energy Expenditure}}
\DoxyCodeLine{            CostAlgorithms.CalculateAndStoreEnergyExpenditure(graph);}
\DoxyCodeLine{            }
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Predeclare paths}}
\DoxyCodeLine{            Path energy\_path, distance\_path;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Get the unique key of this cost type. We'll use this to tell the pathfinder to generate}}
\DoxyCodeLine{            \textcolor{comment}{// a path using the cost set that we just generated.}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} energy\_key = CostAlgorithmNames.ENERGY\_EXPENDITURE;}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Get the nodes from the graph}}
\DoxyCodeLine{            var nodes = graph.getNodes();}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Convert these to Vector3D for use in pathfinding}}
\DoxyCodeLine{            var start\_node = nodes[1].ToVector3D();}
\DoxyCodeLine{            var end\_node = nodes[105].ToVector3D();}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate paths using these nodes.}}
\DoxyCodeLine{            energy\_path = ShortestPath.DijkstraShortestPath(graph, start\_node, end\_node, energy\_key);}
\DoxyCodeLine{            distance\_path = ShortestPath.DijkstraShortestPath(graph, end\_node, start\_node);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print paths to output. }}
\DoxyCodeLine{            Debug.WriteLine(distance\_path);}
\DoxyCodeLine{            Debug.WriteLine(energy\_path);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{[(1, 1.415028), (12, 1.417536), (26, 1.417887), (39, 1.418485), (50, 1.000265), (63, 1.000128), (80, 1.000098), (105, 0)]}
\DoxyCodeLine{[(1, 4.559175), (12, 5.759251), (26, 5.889585), (39, 6.100943), (50, 2.978094), (63, 2.826927), (80, 2.784634), (105, 0)]}
\end{DoxyCode}
 
\end{DoxyParagraph}


References Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Dijkstra\+Shortest\+Path(), and Human\+Factors.\+Spatial\+Structures.\+Graph.\+Get\+Node\+I\+D().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_human_factors_1_1_pathfinding_1_1_shortest_path_a394c96543ad621b2e5d98554153d74b4_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_human_factors_1_1_pathfinding_1_1_shortest_path_a9fb6fc6aff938136f7f9de42e5d8e5bc}\label{class_human_factors_1_1_pathfinding_1_1_shortest_path_a9fb6fc6aff938136f7f9de42e5d8e5bc}} 
\index{HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}!DijkstraShortestPathMulti@{DijkstraShortestPathMulti}}
\index{DijkstraShortestPathMulti@{DijkstraShortestPathMulti}!HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}}
\doxysubsubsection{\texorpdfstring{DijkstraShortestPathMulti()}{DijkstraShortestPathMulti()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}} \mbox{[}$\,$\mbox{]} Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Dijkstra\+Shortest\+Path\+Multi (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}}}]{graph,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{start\+\_\+nodes,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{end\+\_\+nodes,  }\item[{string}]{cost\+\_\+type = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Find the shortest paths between each pair of start\+\_\+id and end\+\_\+id in order. 


\begin{DoxyParams}{Parameters}
{\em graph} & The graph to generate paths in. \\
\hline
{\em start\+\_\+nodes} & Locations of the start points to generate paths from. \\
\hline
{\em end\+\_\+nodes} & Locations of the end nodes to generate paths to. \\
\hline
{\em cost\+\_\+type} & The type of cost to use for generating the path. If left blank, will use the cost that the graph was created with. In the case of the graph generator, the default cost is distance.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A list of paths in order from {\ttfamily start\+\_\+ids} to {\ttfamily end\+\_\+ids}. If a path could not be generated by a set of points, then the path at that location will be null.
\end{DoxyReturn}
Determines the I\+Ds of nodes, then calls the other overload. Uses all available cores for parallel calculation.

\begin{DoxyPrecond}{Precondition}
1) The length of {\ttfamily start\+\_\+ids} must match the length of {\ttfamily end\+\_\+ids}. 

2) Each node in {\ttfamily start\+\_\+nodes} and end\+\_\+nodes must contain the x,y,z position of an existing node in {\ttfamily graph} 

3) If {\ttfamily cost\+\_\+type} is not left as the default, then it must be the name of a valid cost already defined in {\ttfamily graph}.
\end{DoxyPrecond}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Length of {\ttfamily start\+\_\+ids} didn\textquotesingle{}t equal length of {\ttfamily end\+\_\+ids} \\
\hline
{\em Key\+Not\+Found\+Exception} & {\ttfamily cost\+\_\+type} wasn\textquotesingle{}t left as blank, and didn\textquotesingle{}t refer to the name of any cost that already exists in {\ttfamily graph}.\\
\hline
\end{DoxyExceptions}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{            \textcolor{comment}{// Load the OBJ from ddisk}}
\DoxyCodeLine{            var blob = OBJLoader.LoadOBJ(\textcolor{stringliteral}{"ExampleModels/energy\_blob\_zup.obj"});}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a BVH from it }}
\DoxyCodeLine{            EmbreeBVH bvh = \textcolor{keyword}{new} EmbreeBVH(blob, \textcolor{keyword}{true});}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Setup graph variables}}
\DoxyCodeLine{            Vector3D start\_point = \textcolor{keyword}{new} Vector3D(-\/30, 0, 20);}
\DoxyCodeLine{            Vector3D spacing = \textcolor{keyword}{new} Vector3D(1, 1, 10);}
\DoxyCodeLine{            \textcolor{keywordtype}{int} max\_nodes = 10000;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} up\_step = 5.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} down\_step = 5.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} up\_slope = 60.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} down\_slope = 60.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{int} max\_step\_connections = 1;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a graph}}
\DoxyCodeLine{            var graph = \mbox{\hyperlink{namespace_human_factors}{HumanFactors}}.\mbox{\hyperlink{namespace_human_factors_1_1_graph_generator}{GraphGenerator}}.\mbox{\hyperlink{class_human_factors_1_1_graph_generator_1_1_graph_generator}{GraphGenerator}}.\mbox{\hyperlink{class_human_factors_1_1_graph_generator_1_1_graph_generator_a2672814edcde623d71233353fe6e0d2f}{GenerateGraph}}(}
\DoxyCodeLine{                bvh,}
\DoxyCodeLine{                start\_point,}
\DoxyCodeLine{                spacing,}
\DoxyCodeLine{                max\_nodes,}
\DoxyCodeLine{                up\_step,}
\DoxyCodeLine{                down\_step,}
\DoxyCodeLine{                up\_slope,}
\DoxyCodeLine{                down\_slope,}
\DoxyCodeLine{                max\_step\_connections,}
\DoxyCodeLine{                -\/1}
\DoxyCodeLine{            );}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Compress the graph so we can use it with pathfinding}}
\DoxyCodeLine{            graph.CompressToCSR();}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Calculate an alternate set of costs for the graph based on Energy Expenditure}}
\DoxyCodeLine{            CostAlgorithms.CalculateAndStoreEnergyExpenditure(graph);}
\DoxyCodeLine{            }
\end{DoxyCodeInclude}
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Get the unique key of this cost type. We'll use this to tell the pathfinder to generate}}
\DoxyCodeLine{            \textcolor{comment}{// a path using the cost set that we just generated.}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} energy\_key = CostAlgorithmNames.ENERGY\_EXPENDITURE;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Get nodes from the graph}}
\DoxyCodeLine{            var nodes = graph.getNodes();}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a graph using the alternate cost type, then generate one using the graph's}}
\DoxyCodeLine{            \textcolor{comment}{// default cost type, distance.}}
\DoxyCodeLine{            Vector3D[] start\_nodes = \{}
\DoxyCodeLine{                nodes[0].ToVector3D(),}
\DoxyCodeLine{                nodes[1].ToVector3D(),}
\DoxyCodeLine{                nodes[2].ToVector3D(),}
\DoxyCodeLine{                nodes[3].ToVector3D()}
\DoxyCodeLine{            \};}
\DoxyCodeLine{            Vector3D[] end\_nodes = \{}
\DoxyCodeLine{                nodes[101].ToVector3D(),}
\DoxyCodeLine{                nodes[102].ToVector3D(),}
\DoxyCodeLine{                nodes[103].ToVector3D(),}
\DoxyCodeLine{                nodes[104].ToVector3D()}
\DoxyCodeLine{            \};}
\DoxyCodeLine{            Path[] energy\_path = ShortestPath.DijkstraShortestPathMulti(graph, start\_nodes, end\_nodes, energy\_key);}
\DoxyCodeLine{            Path[] distance\_path = ShortestPath.DijkstraShortestPathMulti(graph, start\_nodes, end\_nodes);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print out every pair of paths}}
\DoxyCodeLine{            \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < start\_nodes.Length; i++)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                output += String.Format(\textcolor{stringliteral}{"\{0\} to \{1\} Energy  : \{2\}"}, start\_nodes[i], end\_nodes[i], energy\_path[i]) + \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{                output +=}
\DoxyCodeLine{                    String.Format(\textcolor{stringliteral}{"\{0\} to \{1\} Distance: \{2\}"}, start\_nodes[i], end\_nodes[i], distance\_path[i]) + \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            Debug.WriteLine(output);}
\end{DoxyCodeInclude}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{(-\/30, 0, 1.068) to (-\/27, -\/8, 1.295) Energy  : [(0, 2.48), (4, 2.48), (12, 2.48), (25, 2.461), (37, 2.461), (47, 5.402), (60, 5.302), (77, 5.129), (101, 0)]}
\DoxyCodeLine{(-\/30, 0, 1.068) to (-\/27, -\/8, 1.295) Distance: [(0, 1), (4, 1), (12, 1), (25, 1), (37, 1), (47, 1.417), (60, 1.416), (77, 1.416), (101, 0)]}
\DoxyCodeLine{(-\/31, -\/1, 1.018) to (-\/26, -\/8, 1.427) Energy  : [(1, 2.461), (11, 2.5), (24, 4.536), (37, 5.528), (48, 5.452), (61, 5.605), (78, 5.837), (102, 0)]}
\DoxyCodeLine{(-\/31, -\/1, 1.018) to (-\/26, -\/8, 1.427) Distance: [(1, 1), (11, 1), (24, 1.415), (37, 1.417), (48, 1.417), (61, 1.417), (78, 1.418), (102, 0)]}
\DoxyCodeLine{(-\/31, 0, 1.018) to (-\/25, -\/8, 1.556) Energy  : [(2, 2.5), (1, 4.559), (12, 2.48), (25, 5.708), (38, 5.656), (49, 5.916), (62, 6.644), (79, 5.08), (103, 0)]}
\DoxyCodeLine{(-\/31, 0, 1.018) to (-\/25, -\/8, 1.556) Distance: [(2, 1), (1, 1.415), (12, 1), (25, 1.417), (38, 1.417), (49, 1.418), (62, 1.42), (79, 1.416), (103, 0)]}
\DoxyCodeLine{(-\/31, 1, 1.017) to (-\/25, -\/6, 1.678) Energy  : [(3, 2.52), (2, 2.5), (1, 4.559), (12, 5.759), (26, 5.89), (39, 6.101), (50, 7.008), (64, 5.863), (83, 3.827), (104, 0)]}
\DoxyCodeLine{(-\/31, 1, 1.017) to (-\/25, -\/6, 1.678) Distance: [(3, 1), (2, 1), (1, 1.415), (12, 1.418), (26, 1.418), (39, 1.418), (50, 1.421), (64, 1.418), (83, 1.002), (104, 0)]}
\end{DoxyCode}
 
\end{DoxyParagraph}


References Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Dijkstra\+Shortest\+Path\+Multi().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_human_factors_1_1_pathfinding_1_1_shortest_path_a9fb6fc6aff938136f7f9de42e5d8e5bc_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_human_factors_1_1_pathfinding_1_1_shortest_path_ab7f58f298125194e33d6c69ed4797442}\label{class_human_factors_1_1_pathfinding_1_1_shortest_path_ab7f58f298125194e33d6c69ed4797442}} 
\index{HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}!DijkstraShortestPathMulti@{DijkstraShortestPathMulti}}
\index{DijkstraShortestPathMulti@{DijkstraShortestPathMulti}!HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}}
\doxysubsubsection{\texorpdfstring{DijkstraShortestPathMulti()}{DijkstraShortestPathMulti()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_path}{Path}} \mbox{[}$\,$\mbox{]} Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Dijkstra\+Shortest\+Path\+Multi (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}}}]{graph,  }\item[{int\mbox{[}$\,$\mbox{]}}]{start\+\_\+ids,  }\item[{int\mbox{[}$\,$\mbox{]}}]{end\+\_\+ids,  }\item[{string}]{cost\+\_\+type = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Find the shortest paths between each pair of start\+\_\+id and end\+\_\+id in order. 


\begin{DoxyParams}{Parameters}
{\em graph} & The graph to generate paths in. \\
\hline
{\em start\+\_\+ids} & Ids for the start points to generate paths from. \\
\hline
{\em end\+\_\+ids} & Ids for the end points to generate paths to \\
\hline
{\em cost\+\_\+type} & The type of cost to use for generating the path. If left blank, will use the cost that the graph was created with. In the case of the graph generator, the default cost is distance.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A list of paths in order from start\+\_\+ids to end\+\_\+ids. If a path could not be generated by a set of points, then the path at that location will be null.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
1) The length of start\+\_\+ids must match the length of end\+\_\+ids. 

2) Every ID in {\ttfamily start\+\_\+ids} and {\ttfamily end\+\_\+ids} must be the ID of some node in {\ttfamily graph}. 

3) If {\ttfamily cost\+\_\+type} is not left as the default, then it must be the name of a valid cost already defined in {\ttfamily graph}.
\end{DoxyPrecond}
Uses all available cores for parallel calculation.

\begin{DoxyPrecond}{Precondition}
The length of start\+\_\+ids must match the length of end\+\_\+ids.
\end{DoxyPrecond}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Length of start\+\_\+ids didn\textquotesingle{}t equal length of end\+\_\+ids \\
\hline
{\em Key\+Not\+Found\+Exception} & {\ttfamily cost\+\_\+type} wasn\textquotesingle{}t left as blank, and didn\textquotesingle{}t refer to the name of any cost that already exists in the graph.\\
\hline
\end{DoxyExceptions}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{            \textcolor{comment}{// Load the OBJ from ddisk}}
\DoxyCodeLine{            var blob = OBJLoader.LoadOBJ(\textcolor{stringliteral}{"ExampleModels/energy\_blob\_zup.obj"});}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a BVH from it }}
\DoxyCodeLine{            EmbreeBVH bvh = \textcolor{keyword}{new} EmbreeBVH(blob, \textcolor{keyword}{true});}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Setup graph variables}}
\DoxyCodeLine{            Vector3D start\_point = \textcolor{keyword}{new} Vector3D(-\/30, 0, 20);}
\DoxyCodeLine{            Vector3D spacing = \textcolor{keyword}{new} Vector3D(1, 1, 10);}
\DoxyCodeLine{            \textcolor{keywordtype}{int} max\_nodes = 10000;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} up\_step = 5.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} down\_step = 5.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} up\_slope = 60.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} down\_slope = 60.0f;}
\DoxyCodeLine{            \textcolor{keywordtype}{int} max\_step\_connections = 1;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a graph}}
\DoxyCodeLine{            var graph = \mbox{\hyperlink{namespace_human_factors}{HumanFactors}}.\mbox{\hyperlink{namespace_human_factors_1_1_graph_generator}{GraphGenerator}}.\mbox{\hyperlink{class_human_factors_1_1_graph_generator_1_1_graph_generator}{GraphGenerator}}.\mbox{\hyperlink{class_human_factors_1_1_graph_generator_1_1_graph_generator_a2672814edcde623d71233353fe6e0d2f}{GenerateGraph}}(}
\DoxyCodeLine{                bvh,}
\DoxyCodeLine{                start\_point,}
\DoxyCodeLine{                spacing,}
\DoxyCodeLine{                max\_nodes,}
\DoxyCodeLine{                up\_step,}
\DoxyCodeLine{                down\_step,}
\DoxyCodeLine{                up\_slope,}
\DoxyCodeLine{                down\_slope,}
\DoxyCodeLine{                max\_step\_connections,}
\DoxyCodeLine{                -\/1}
\DoxyCodeLine{            );}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Compress the graph so we can use it with pathfinding}}
\DoxyCodeLine{            graph.CompressToCSR();}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Calculate an alternate set of costs for the graph based on Energy Expenditure}}
\DoxyCodeLine{            CostAlgorithms.CalculateAndStoreEnergyExpenditure(graph);}
\DoxyCodeLine{            }
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Get the unique key of this cost type. We'll use this to tell the pathfinder to generate}}
\DoxyCodeLine{            \textcolor{comment}{// a path using the cost set that we just generated.}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} energy\_key = CostAlgorithmNames.ENERGY\_EXPENDITURE;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Generate a graph using the alternate cost type, then generate one using the graph's}}
\DoxyCodeLine{            \textcolor{comment}{// default cost type, distance.}}
\DoxyCodeLine{            \textcolor{keywordtype}{int}[] start\_ids = \{1, 2, 3, 4\};}
\DoxyCodeLine{            \textcolor{keywordtype}{int}[] end\_ids = \{101, 102, 103, 104\};}
\DoxyCodeLine{            Path[] energy\_path = ShortestPath.DijkstraShortestPathMulti(graph, start\_ids, end\_ids, energy\_key);}
\DoxyCodeLine{            Path[] distance\_path = ShortestPath.DijkstraShortestPathMulti(graph, start\_ids, end\_ids);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordtype}{string} output = \textcolor{stringliteral}{""};}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print out every pair of paths}}
\DoxyCodeLine{            \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < start\_ids.Length; i++)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                output += String.Format(\textcolor{stringliteral}{"\{0\} to \{1\} Energy  : \{2\}"}, start\_ids[i], end\_ids[i], energy\_path[i]) + \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{                output += String.Format(\textcolor{stringliteral}{"\{0\} to \{1\} Distance: \{2\}"}, start\_ids[i], end\_ids[i], distance\_path[i]) + \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            Debug.WriteLine(output);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1 to 101 Energy  : [(1, 2.461), (11, 2.5), (24, 2.5), (36, 4.491), (47, 5.402), (60, 5.302), (77, 5.129), (101, 0)]}
\DoxyCodeLine{1 to 101 Distance: [(1, 1), (11, 1), (24, 1), (36, 1.415), (47, 1.417), (60, 1.416), (77, 1.416), (101, 0)]}
\DoxyCodeLine{2 to 102 Energy  : [(2, 2.5), (1, 2.461), (11, 2.5), (24, 4.536), (37, 5.528), (48, 5.452), (61, 5.605), (78, 5.837), (102, 0)]}
\DoxyCodeLine{2 to 102 Distance: [(2, 1), (1, 1), (11, 1), (24, 1.415), (37, 1.417), (48, 1.417), (61, 1.417), (78, 1.418), (102, 0)]}
\DoxyCodeLine{3 to 103 Energy  : [(3, 2.52), (2, 2.5), (1, 4.559), (12, 2.48), (25, 5.708), (38, 5.656), (49, 5.916), (62, 6.644), (79, 5.08), (103, 0)]}
\DoxyCodeLine{3 to 103 Distance: [(3, 1), (2, 1), (1, 1.415), (12, 1), (25, 1.417), (38, 1.417), (49, 1.418), (62, 1.42), (79, 1.416), (103, 0)]}
\DoxyCodeLine{4 to 104 Energy  : [(4, 2.48), (12, 5.759), (26, 5.89), (39, 6.101), (50, 7.008), (64, 5.863), (83, 3.827), (104, 0)]}
\DoxyCodeLine{4 to 104 Distance: [(4, 1), (12, 1.418), (26, 1.418), (39, 1.418), (50, 1.421), (64, 1.418), (83, 1.002), (104, 0)]}
\end{DoxyCode}
 
\end{DoxyParagraph}


Referenced by Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Dijkstra\+Shortest\+Path\+Multi().

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_human_factors_1_1_pathfinding_1_1_shortest_path_ab7f58f298125194e33d6c69ed4797442_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_human_factors_1_1_pathfinding_1_1_shortest_path_abf65038bac66da2c403034c05f83bee9}\label{class_human_factors_1_1_pathfinding_1_1_shortest_path_abf65038bac66da2c403034c05f83bee9}} 
\index{HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}!GeneratePredecessorAndDistanceMatricies@{GeneratePredecessorAndDistanceMatricies}}
\index{GeneratePredecessorAndDistanceMatricies@{GeneratePredecessorAndDistanceMatricies}!HumanFactors.Pathfinding.ShortestPath@{HumanFactors.Pathfinding.ShortestPath}}
\doxysubsubsection{\texorpdfstring{GeneratePredecessorAndDistanceMatricies()}{GeneratePredecessorAndDistanceMatricies()}}
{\footnotesize\ttfamily static void Human\+Factors.\+Pathfinding.\+Shortest\+Path.\+Generate\+Predecessor\+And\+Distance\+Matricies (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_spatial_structures_1_1_graph}{Graph}}}]{g,  }\item[{out \mbox{\hyperlink{class_human_factors_1_1_native_utils_1_1_common_native_arrays_1_1_unmanaged_float_array2_d}{Unmanaged\+Float\+Array2D}}}]{out\+\_\+dist,  }\item[{out \mbox{\hyperlink{class_human_factors_1_1_native_utils_1_1_common_native_arrays_1_1_unmanaged_int_array2_d}{Unmanaged\+Int\+Array2D}}}]{out\+\_\+predecessor,  }\item[{string}]{cost\+\_\+type = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculate Predecessor and Distance Matricies for a graph. 


\begin{DoxyParams}{Parameters}
{\em g} & Graph to calculate predeessor and distance matricies for \\
\hline
{\em out\+\_\+dist} & Output parameter for the distance matrix \\
\hline
{\em out\+\_\+predecessor} & Output parameter for the predecessor matrix. \\
\hline
{\em cost\+\_\+type} & Type of cost to use for the distance and predecessor matricies. If left blank will use the default cost of the graph.\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Not\+Found\+Exception} & If cost\+\_\+type isn\textquotesingle{}t left to the default, and does not match the key of any cost that already exists in the graph.\\
\hline
\end{DoxyExceptions}
\begin{DoxyPostcond}{Postcondition}
out\+\_\+dist and out\+\_\+predecessor are updated to contain the distance and predecessor matricies for {\ttfamily g}.
\end{DoxyPostcond}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{            \textcolor{comment}{// Create a graph, add some edges and nodes}}
\DoxyCodeLine{            Graph g = \textcolor{keyword}{new} Graph();}
\DoxyCodeLine{            Vector3D[] nodes =}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keyword}{new} Vector3D(1,2,3),}
\DoxyCodeLine{                \textcolor{keyword}{new} Vector3D(4, 5, 6),}
\DoxyCodeLine{                \textcolor{keyword}{new} Vector3D(7, 8, 9),}
\DoxyCodeLine{                \textcolor{keyword}{new} Vector3D(10, 1, 2)}
\DoxyCodeLine{            \};}
\DoxyCodeLine{            g.AddEdge(nodes[1], nodes[2], 20);}
\DoxyCodeLine{            g.AddEdge(nodes[0], nodes[2], 5);}
\DoxyCodeLine{            g.AddEdge(nodes[1], nodes[0], 10);}
\DoxyCodeLine{            \_ = g.CompressToCSR();}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Get the predecessor and distance matricies}}
\DoxyCodeLine{            \textcolor{comment}{// back from native code}}
\DoxyCodeLine{            UnmanagedFloatArray2D dist\_matrix = \textcolor{keyword}{null};}
\DoxyCodeLine{            UnmanagedIntArray2D pred\_matrix = \textcolor{keyword}{null};}
\DoxyCodeLine{            \mbox{\hyperlink{namespace_human_factors}{HumanFactors}}.\mbox{\hyperlink{namespace_human_factors_1_1_pathfinding}{Pathfinding}}.\mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path}{ShortestPath}}.\mbox{\hyperlink{class_human_factors_1_1_pathfinding_1_1_shortest_path_abf65038bac66da2c403034c05f83bee9}{GeneratePredecessorAndDistanceMatricies}}(}
\DoxyCodeLine{                g,}
\DoxyCodeLine{                out dist\_matrix,}
\DoxyCodeLine{                out pred\_matrix}
\DoxyCodeLine{            );}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print to console}}
\DoxyCodeLine{            Debug.WriteLine(dist\_matrix);}
\DoxyCodeLine{            Debug.WriteLine(pred\_matrix);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}
{\ttfamily \mbox{[}0, 15, 10, NaN, 0, NaN, NaN, 5, 0\mbox{]}}~\newline
{\ttfamily \mbox{[}0, 2, 0, -\/1, 1, -\/1, -\/1, 2, 2\mbox{]}} 
\end{DoxyParagraph}


References Human\+Factors.\+Spatial\+Structures.\+Graph.\+Num\+Nodes().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_human_factors_1_1_pathfinding_1_1_shortest_path_abf65038bac66da2c403034c05f83bee9_cgraph}
\end{center}
\end{figure}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\+Csharp/packages/pathfinding/src/Shortest\+Path.\+cs\end{DoxyCompactItemize}
