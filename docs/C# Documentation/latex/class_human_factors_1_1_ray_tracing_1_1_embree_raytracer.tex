\hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer}{}\doxysection{Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer Class Reference}
\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer}\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}


Cast rays with Intel\textquotesingle{}s Embree raytracing library.  


\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}{Intersect\+For\+Point}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, float x, float y, float z, float dx, float dy, float dz, float max\+\_\+distance=-\/1)
\begin{DoxyCompactList}\small\item\em Cast a single ray, and get a point in return if it intersects any geometry. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a2d6fd1eb3e172c59014d6b1b24a2c1c9}{Intersect\+For\+Point}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} origin, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} direction, float max\+\_\+distance=-\/1)
\begin{DoxyCompactList}\small\item\em Cast a single ray, and get a point in return if it intersects any geometry. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}\mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_ae3364703368c059a9e5bda35ca41492a}{Intersect\+For\+Points}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ origins, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ directions, float max\+\_\+distance)
\begin{DoxyCompactList}\small\item\em Cast multiple rays and recieve hitpoints in return. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_human_factors_1_1_ray_tracing_1_1_ray_result}{Ray\+Result}} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a2bd31afa0ffb40b98a81ea47fc876be6}{Intersect\+For\+Distance}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} origin, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} direction, float max\+\_\+distance)
\begin{DoxyCompactList}\small\item\em Cast a single ray and get the distance to its hit and the mesh\+ID if it hit anything. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_ray_results}{Ray\+Results}} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a9b28c2746d7859db1ce70a87ab935063}{Intersect\+For\+Distances}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ origins, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ directions, float max\+\_\+distance)
\begin{DoxyCompactList}\small\item\em Cast multiple rays and recieve the distance and meshid of geometry intersected by each in return. \end{DoxyCompactList}\item 
static bool\mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a910e0b4ba8e99cdc45a0df115c89ff15}{Intersect\+Occluded}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ origin, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ direction, float max\+\_\+distance)
\begin{DoxyCompactList}\small\item\em Determine if any geometry occludes a point from a direction. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Cast rays with Intel\textquotesingle{}s Embree raytracing library. 

\begin{DoxyRemark}{Remarks}
All functions in this class first require the creation of an \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} with valid mesh geometry.
\end{DoxyRemark}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_human_factors_1_1_geometry_1_1_mesh_info}{Geometry.\+Mesh\+Info}} for details on converting a mesh to a format that \mbox{\hyperlink{namespace_human_factors}{Human\+Factors}} can interpret 

\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} for details on generating a B\+VH from geometry. 
\end{DoxySeeAlso}


Definition at line 39 of file Embree\+Ray\+Tracer.\+cs.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a2bd31afa0ffb40b98a81ea47fc876be6}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a2bd31afa0ffb40b98a81ea47fc876be6}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForDistance@{IntersectForDistance}}
\index{IntersectForDistance@{IntersectForDistance}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForDistance()}{IntersectForDistance()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_human_factors_1_1_ray_tracing_1_1_ray_result}{Ray\+Result}} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Distance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{origin,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{direction,  }\item[{float}]{max\+\_\+distance }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast a single ray and get the distance to its hit and the mesh\+ID if it hit anything. 


\begin{DoxyParams}{Parameters}
{\em bvh} & A valid B\+VH containing the geometry to intersect with. \\
\hline
{\em origin} & x,y,z coordinates for the ray\textquotesingle{}s origin point. \\
\hline
{\em direction} & x,y,z coordinates for the direction for the ray to be casted in. \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersection. Set to -\/1 for infinite.\\
\hline
\end{DoxyParams}
\begin{DoxyRemark}{Remarks}
This can be faster than \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_ae3364703368c059a9e5bda35ca41492a}{Intersect\+For\+Points}}, as the data returned is lighter. If you only need the distance or mesh\+ID, this function is recommended.
\end{DoxyRemark}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{struct_human_factors_1_1_ray_tracing_1_1_ray_result}{Ray\+Result}} containing the distance to the hitpoint and meshid it hit. If the distance is equal to -\/1, then the ray did not intersect any geometry. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a9b28c2746d7859db1ce70a87ab935063}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a9b28c2746d7859db1ce70a87ab935063}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForDistances@{IntersectForDistances}}
\index{IntersectForDistances@{IntersectForDistances}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForDistances()}{IntersectForDistances()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_ray_results}{Ray\+Results}} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Distances (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{origins,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{directions,  }\item[{float}]{max\+\_\+distance }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast multiple rays and recieve the distance and meshid of geometry intersected by each in return. 


\begin{DoxyParams}{Parameters}
{\em bvh} & A valid B\+VH containing geometry to intersect with. \\
\hline
{\em origins} & A list of x, y, z coordinates to cast rays in. \\
\hline
{\em directions} & A list of x, y, z directions to fire in. \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersection.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_ray_results}{Ray\+Results}} for the hitpoint of each ray casted in order. If a ray didn\textquotesingle{}t intersect any geometry, then its distance and meshid will be -\/1.
\end{DoxyReturn}
Can be casted in 3 configurations\+: 


\begin{DoxyItemize}
\item Equal amount of directions/origins\+: Cast a ray for every pair of origin/direction in order.\+i.\+e. (origin\mbox{[}0\mbox{]}, direction\mbox{[}0\mbox{]}), (origin\mbox{[}1\mbox{]}, direction\mbox{[}1\mbox{]}), etc.  
\item One direction, multiple origins\+: Cast a ray in the given direction from each origin point in origins.  
\item One origin, multiple directions\+: Cast a ray from the origin point in each direction in directions  
\end{DoxyItemize}


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Length of directions and origins did not match any of the valid cases. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForPoint@{IntersectForPoint}}
\index{IntersectForPoint@{IntersectForPoint}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForPoint()}{IntersectForPoint()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Point (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{float}]{x,  }\item[{float}]{y,  }\item[{float}]{z,  }\item[{float}]{dx,  }\item[{float}]{dy,  }\item[{float}]{dz,  }\item[{float}]{max\+\_\+distance = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast a single ray, and get a point in return if it intersects any geometry. 


\begin{DoxyParams}{Parameters}
{\em bvh} & B\+VH of geometry to intersect. \\
\hline
{\em x} & x component of the ray\textquotesingle{}s origin point \\
\hline
{\em y} & y component of the ray\textquotesingle{}s origin point \\
\hline
{\em z} & z component of the ray\textquotesingle{}s origin point \\
\hline
{\em dx} & x component of the ray\textquotesingle{}s direction \\
\hline
{\em dy} & y component of the ray\textquotesingle{}s direction \\
\hline
{\em dz} & z component of the ray\textquotesingle{}s direction \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersections. Set to -\/1 for infinite\\
\hline
\end{DoxyParams}
\begin{DoxyRemark}{Remarks}
Consider calling \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_ae3364703368c059a9e5bda35ca41492a}{Intersect\+For\+Points}} when casting mutliple rays at once since it can make use of parallel processing to drastically reduce the time it takes to cast each ray.
\end{DoxyRemark}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} containing the hitpoint. If no hit was detected, the point will be invalid. This can easily be checked using \mbox{\hyperlink{struct_human_factors_1_1_vector3_d_ad5ca9e5b9921fc94c5cbdb139a33cc54}{Vector3\+D.\+Is\+Valid}}. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a2d6fd1eb3e172c59014d6b1b24a2c1c9}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a2d6fd1eb3e172c59014d6b1b24a2c1c9}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForPoint@{IntersectForPoint}}
\index{IntersectForPoint@{IntersectForPoint}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForPoint()}{IntersectForPoint()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Point (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{origin,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{direction,  }\item[{float}]{max\+\_\+distance = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast a single ray, and get a point in return if it intersects any geometry. 


\begin{DoxyParams}{Parameters}
{\em bvh} & B\+VH of geometry to intersect. \\
\hline
{\em origin} & Origin point to cast the ray from. \\
\hline
{\em direction} & direction to cast the ray in. \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersections.\+Set to -\/1 for infinite\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} containing the hitpoint. If no hit was detected, the point will be invalid. This can easily be checked using \mbox{\hyperlink{struct_human_factors_1_1_vector3_d_ad5ca9e5b9921fc94c5cbdb139a33cc54}{Vector3\+D.\+Is\+Valid}}.
\end{DoxyReturn}
This calls the other overload with the components of origin and direction.

\begin{DoxyRemark}{Remarks}
Consider calling \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_ae3364703368c059a9e5bda35ca41492a}{Intersect\+For\+Points}} when casting mutliple rays at once since it can make use of parallel processing to drastically reduce the time it takes to get the results of every ray. 
\end{DoxyRemark}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_ae3364703368c059a9e5bda35ca41492a}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_ae3364703368c059a9e5bda35ca41492a}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForPoints@{IntersectForPoints}}
\index{IntersectForPoints@{IntersectForPoints}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForPoints()}{IntersectForPoints()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} \mbox{[}$\,$\mbox{]} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Points (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{origins,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{directions,  }\item[{float}]{max\+\_\+distance }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast multiple rays and recieve hitpoints in return. 


\begin{DoxyParams}{Parameters}
{\em bvh} & A valid B\+VH containing geometry to intersect with. \\
\hline
{\em origins} & A list of x,y,z coordinates to cast rays in. \\
\hline
{\em directions} & A list of x,y,z directions to fire in. \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersection.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} for the hitpoint of each ray casted in order. If a ray didn\textquotesingle{}t intersect any geometry, then its point will be invalid, checkable using \mbox{\hyperlink{struct_human_factors_1_1_vector3_d_ad5ca9e5b9921fc94c5cbdb139a33cc54}{Vector3\+D.\+Is\+Valid()}}
\end{DoxyReturn}
Can be casted in 3 configurations\+: 


\begin{DoxyItemize}
\item Equal amount of directions/origins\+: Cast a ray for every pair of origin/direction in order. i.\+e. (origin\mbox{[}0\mbox{]}, direction\mbox{[}0\mbox{]}), (origin\mbox{[}1\mbox{]}, direction\mbox{[}1\mbox{]}), etc.  
\item One direction, multiple origins\+: Fire a ray in the given direction from each origin point in origins.  
\item One origin, multiple directions\+: Fire a ray from the origin point in each direction in directions.  
\end{DoxyItemize}


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Length of directions and origins did not match any of the valid cases. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a910e0b4ba8e99cdc45a0df115c89ff15}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a910e0b4ba8e99cdc45a0df115c89ff15}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectOccluded@{IntersectOccluded}}
\index{IntersectOccluded@{IntersectOccluded}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectOccluded()}{IntersectOccluded()}}
{\footnotesize\ttfamily static bool \mbox{[}$\,$\mbox{]} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+Occluded (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{origin,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{direction,  }\item[{float}]{max\+\_\+distance }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Determine if any geometry occludes a point from a direction. 


\begin{DoxyParams}{Parameters}
{\em bvh} & A valid Embree B\+VH. \\
\hline
{\em origin} & One or more origins. \\
\hline
{\em direction} & One or more directions. \\
\hline
{\em max\+\_\+distance} & Maximum distance that a ray can travel. Any hits beyond this point are not counted.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of true or false values indicating hits or misses respectively.
\end{DoxyReturn}
Can be casted in 3 configurations\+: 


\begin{DoxyItemize}
\item Equal amount of directions/origins\+: Cast a ray for every pair of origin/direction in order.\+i.\+e. (origin\mbox{[}0\mbox{]}, direction\mbox{[}0\mbox{]}), (origin\mbox{[}1\mbox{]}, direction\mbox{[}1\mbox{]}), etc.  
\item One direction, multiple origins\+: Cast a ray in the given direction from each origin point in origins.  
\item One origin, multiple directions\+: Cast a ray from the origin point in each direction in directions  
\end{DoxyItemize}

\begin{DoxyRemark}{Remarks}
Occlusion rays are the fastest raycasting function, however are only capable of returning or not they hit anything. This can be useful for line of sight checks. Will execute in parallel if multiple origins/directions are supplied. 
\end{DoxyRemark}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\+Csharp/packages/raytracer/src/\mbox{\hyperlink{_embree_ray_tracer_8cs}{Embree\+Ray\+Tracer.\+cs}}\end{DoxyCompactItemize}
