\hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer}{}\doxysection{Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer Class Reference}
\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer}\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}


Cast rays with Intel\textquotesingle{}s Embree raytracing library.  


\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}{Intersect\+For\+Point}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, float x, float y, float z, float dx, float dy, float dz, float max\+\_\+distance=-\/1)
\begin{DoxyCompactList}\small\item\em Cast a single ray, and get a point in return if it intersects any geometry. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a2d6fd1eb3e172c59014d6b1b24a2c1c9}{Intersect\+For\+Point}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} origin, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} direction, float max\+\_\+distance=-\/1)
\begin{DoxyCompactList}\small\item\em Cast a single ray, and get a point in return if it intersects any geometry. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}\mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a97e8b50b5bbb182d12416e7638dad9e9}{Intersect\+For\+Points}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ origins, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ directions, float max\+\_\+distance=-\/1)
\begin{DoxyCompactList}\small\item\em Cast multiple rays and recieve hitpoints in return. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{struct_human_factors_1_1_ray_tracing_1_1_ray_result}{Ray\+Result}} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a929f4285ca85814545d3f0b30cc26048}{Intersect\+For\+Distance}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} origin, \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} direction, float max\+\_\+distance=-\/1)
\begin{DoxyCompactList}\small\item\em Cast a single ray and get the distance to its hit and the mesh\+ID if it hit anything. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_ray_results}{Ray\+Results}} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a04dd5147c6613ec137069bf2fdaa0e73}{Intersect\+For\+Distances}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ origins, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ directions, float max\+\_\+distance=-\/1)
\begin{DoxyCompactList}\small\item\em Cast multiple rays and recieve the distance and meshid of geometry intersected by each in return. \end{DoxyCompactList}\item 
static bool\mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a0d503f39da6389a369d58d4945388e33}{Intersect\+Occluded}} (\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} bvh, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ origin, I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$ direction, float max\+\_\+distance=-\/1)
\begin{DoxyCompactList}\small\item\em Determine if any geometry occludes a point from a direction. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Cast rays with Intel\textquotesingle{}s Embree raytracing library. 

\begin{DoxyRemark}{Remarks}
All functions in this class first require the creation of an \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} with valid mesh geometry.
\end{DoxyRemark}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_human_factors_1_1_geometry_1_1_mesh_info}{Geometry.\+Mesh\+Info}} for details on converting a mesh to a format that \mbox{\hyperlink{namespace_human_factors}{Human\+Factors}} can interpret 

\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}} for details on generating a B\+VH from geometry. 
\end{DoxySeeAlso}


Definition at line 39 of file Embree\+Ray\+Tracer.\+cs.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a929f4285ca85814545d3f0b30cc26048}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a929f4285ca85814545d3f0b30cc26048}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForDistance@{IntersectForDistance}}
\index{IntersectForDistance@{IntersectForDistance}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForDistance()}{IntersectForDistance()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_human_factors_1_1_ray_tracing_1_1_ray_result}{Ray\+Result}} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Distance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{origin,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{direction,  }\item[{float}]{max\+\_\+distance = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast a single ray and get the distance to its hit and the mesh\+ID if it hit anything. 


\begin{DoxyParams}{Parameters}
{\em bvh} & A valid B\+VH containing the geometry to intersect with. \\
\hline
{\em origin} & x,y,z coordinates for the ray\textquotesingle{}s origin point. \\
\hline
{\em direction} & x,y,z coordinates for the direction for the ray to be casted in. \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersection. Set to -\/1 for infinite.\\
\hline
\end{DoxyParams}
\begin{DoxyRemark}{Remarks}
This can be faster than \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a97e8b50b5bbb182d12416e7638dad9e9}{Intersect\+For\+Points}}, as the data returned is lighter. If you only need the distance or mesh\+ID, this function is recommended.
\end{DoxyRemark}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{struct_human_factors_1_1_ray_tracing_1_1_ray_result}{Ray\+Result}} containing the distance to the hitpoint and meshid it hit. If the distance is equal to -\/1, then the ray did not intersect any geometry.
\end{DoxyReturn}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Load an OBJ from a filepath  into a new meshinfo instance}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} good\_mesh\_path = \textcolor{stringliteral}{"ExampleModels/plane.obj"};}
\DoxyCodeLine{            MeshInfo Mesh = OBJLoader.LoadOBJ(good\_mesh\_path, CommonRotations.Yup\_To\_Zup);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Construct a BVH from the mesh}}
\DoxyCodeLine{            EmbreeBVH BVH = \textcolor{keyword}{new} EmbreeBVH(Mesh);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{           }
\DoxyCodeLine{            \textcolor{comment}{// Create origin and direction to cast ray straight down at the plane}}
\DoxyCodeLine{            Vector3D origin = \textcolor{keyword}{new} Vector3D(0, 0, 1);}
\DoxyCodeLine{            Vector3D direction = \textcolor{keyword}{new} Vector3D(0, 0, -\/1);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Cast ray and get the distance/MeshID}}
\DoxyCodeLine{            RayResult result = EmbreeRaytracer.IntersectForDistance(BVH, origin, direction);}
\DoxyCodeLine{            }
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print the distance/MeshID}}
\DoxyCodeLine{            Debug.WriteLine(result);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}
{\ttfamily \mbox{[}1,0\mbox{]}} 
\end{DoxyParagraph}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a04dd5147c6613ec137069bf2fdaa0e73}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a04dd5147c6613ec137069bf2fdaa0e73}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForDistances@{IntersectForDistances}}
\index{IntersectForDistances@{IntersectForDistances}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForDistances()}{IntersectForDistances()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_ray_results}{Ray\+Results}} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Distances (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{origins,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{directions,  }\item[{float}]{max\+\_\+distance = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast multiple rays and recieve the distance and meshid of geometry intersected by each in return. 


\begin{DoxyParams}{Parameters}
{\em bvh} & A valid B\+VH containing geometry to intersect with. \\
\hline
{\em origins} & A list of x, y, z coordinates to cast rays in. \\
\hline
{\em directions} & A list of x, y, z directions to fire in. \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersection.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_ray_results}{Ray\+Results}} for the hitpoint of each ray casted in order. If a ray didn\textquotesingle{}t intersect any geometry, then its distance and meshid will be -\/1.
\end{DoxyReturn}
Can be casted in 3 configurations\+: 


\begin{DoxyItemize}
\item Equal amount of directions/origins\+: Cast a ray for every pair of origin/direction in order.\+i.\+e. (origin\mbox{[}0\mbox{]}, direction\mbox{[}0\mbox{]}), (origin\mbox{[}1\mbox{]}, direction\mbox{[}1\mbox{]}), etc.  
\item One direction, multiple origins\+: Cast a ray in the given direction from each origin point in origins.  
\item One origin, multiple directions\+: Cast a ray from the origin point in each direction in directions  
\end{DoxyItemize}


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Length of directions and origins did not match any of the valid cases. \\
\hline
\end{DoxyExceptions}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Load an OBJ from a filepath  into a new meshinfo instance}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} good\_mesh\_path = \textcolor{stringliteral}{"ExampleModels/plane.obj"};}
\DoxyCodeLine{            MeshInfo Mesh = OBJLoader.LoadOBJ(good\_mesh\_path, CommonRotations.Yup\_To\_Zup);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Construct a BVH from the mesh}}
\DoxyCodeLine{            EmbreeBVH BVH = \textcolor{keyword}{new} EmbreeBVH(Mesh);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Construct origin/distance arrays}}
\DoxyCodeLine{            \textcolor{keywordtype}{int} num\_rays = 6;}
\DoxyCodeLine{            Vector3D[] origin\_vector = \textcolor{keyword}{new} Vector3D[num\_rays];}
\DoxyCodeLine{            Vector3D[] direction\_vector = \textcolor{keyword}{new} Vector3D[num\_rays];}
\DoxyCodeLine{            \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_rays; i++)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                origin\_vector[i] = \textcolor{keyword}{new} Vector3D(0, 0, i);}
\DoxyCodeLine{                direction\_vector[i] = \textcolor{keyword}{new} Vector3D(0, 0, -\/1);}
\DoxyCodeLine{            \}}
\DoxyCodeLine{            }
\DoxyCodeLine{            \textcolor{comment}{// Cast rays and get results}}
\DoxyCodeLine{            RayResults results = EmbreeRaytracer.IntersectForDistances(BVH, origin\_vector, direction\_vector);}
\DoxyCodeLine{                }
\DoxyCodeLine{            \textcolor{comment}{// Print Results. The distance should equal the origin's z value, except for the first one, which}}
\DoxyCodeLine{            \textcolor{comment}{// should miss since it's inside the plane}}
\DoxyCodeLine{            \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < num\_rays; i++)}
\DoxyCodeLine{                Debug.WriteLine(\textcolor{stringliteral}{"Origin: \{0\}, Result: \{1\}"}, origin\_vector[i], results[i]);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCode}{0}
\DoxyCodeLine{Origin: (0, 0, 0), Result: [-\/1,-\/1]}
\DoxyCodeLine{Origin: (0, 0, 1), Result: [1,0]}
\DoxyCodeLine{Origin: (0, 0, 2), Result: [2,0]}
\DoxyCodeLine{Origin: (0, 0, 3), Result: [3,0]}
\DoxyCodeLine{Origin: (0, 0, 4), Result: [4,0]}
\DoxyCodeLine{Origin: (0, 0, 5), Result: [5,0]}
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForPoint@{IntersectForPoint}}
\index{IntersectForPoint@{IntersectForPoint}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForPoint()}{IntersectForPoint()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Point (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{float}]{x,  }\item[{float}]{y,  }\item[{float}]{z,  }\item[{float}]{dx,  }\item[{float}]{dy,  }\item[{float}]{dz,  }\item[{float}]{max\+\_\+distance = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast a single ray, and get a point in return if it intersects any geometry. 


\begin{DoxyParams}{Parameters}
{\em bvh} & B\+VH of geometry to intersect. \\
\hline
{\em x} & x component of the ray\textquotesingle{}s origin point \\
\hline
{\em y} & y component of the ray\textquotesingle{}s origin point \\
\hline
{\em z} & z component of the ray\textquotesingle{}s origin point \\
\hline
{\em dx} & x component of the ray\textquotesingle{}s direction \\
\hline
{\em dy} & y component of the ray\textquotesingle{}s direction \\
\hline
{\em dz} & z component of the ray\textquotesingle{}s direction \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersections. Set to -\/1 for infinite\\
\hline
\end{DoxyParams}
\begin{DoxyRemark}{Remarks}
Consider calling \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a97e8b50b5bbb182d12416e7638dad9e9}{Intersect\+For\+Points}} when casting mutliple rays at once since it can make use of parallel processing to drastically reduce the time it takes to cast each ray.
\end{DoxyRemark}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} containing the hitpoint. If no hit was detected, the point will be invalid. This can easily be checked using \mbox{\hyperlink{struct_human_factors_1_1_vector3_d_ad5ca9e5b9921fc94c5cbdb139a33cc54}{Vector3\+D.\+Is\+Valid}}.
\end{DoxyReturn}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Load an OBJ from a filepath  into a new meshinfo instance}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} good\_mesh\_path = \textcolor{stringliteral}{"ExampleModels/plane.obj"};}
\DoxyCodeLine{            MeshInfo Mesh = OBJLoader.LoadOBJ(good\_mesh\_path, CommonRotations.Yup\_To\_Zup);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Construct a BVH from the mesh}}
\DoxyCodeLine{            EmbreeBVH BVH = \textcolor{keyword}{new} EmbreeBVH(Mesh);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Define an origin and direction}}
\DoxyCodeLine{            Vector3D origin = \textcolor{keyword}{new} Vector3D(0, 0, 1);}
\DoxyCodeLine{            Vector3D direction = \textcolor{keyword}{new} Vector3D(0, 0, -\/1);}
\DoxyCodeLine{            }
\DoxyCodeLine{            \textcolor{comment}{// Cast a ray from origin an direction and get the point}}
\DoxyCodeLine{            Vector3D good\_point = \mbox{\hyperlink{namespace_human_factors}{HumanFactors}}.\mbox{\hyperlink{namespace_human_factors_1_1_ray_tracing}{RayTracing}}.\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer}{EmbreeRaytracer}}.\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}{IntersectForPoint}}(BVH, origin, direction, -\/1);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print the point}}
\DoxyCodeLine{            Debug.WriteLine(good\_point);}
\DoxyCodeLine{            }
\end{DoxyCodeInclude}
{\ttfamily (0, 0, 0)} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{           }
\DoxyCodeLine{            \textcolor{comment}{// Do the same in a direction we know will miss}}
\DoxyCodeLine{            Vector3D bad\_direction = \textcolor{keyword}{new} Vector3D(0, 0, 1);}
\DoxyCodeLine{            Vector3D bad\_point = \mbox{\hyperlink{namespace_human_factors}{HumanFactors}}.\mbox{\hyperlink{namespace_human_factors_1_1_ray_tracing}{RayTracing}}.\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer}{EmbreeRaytracer}}.\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}{IntersectForPoint}}(BVH, origin, bad\_direction, -\/1);}
\DoxyCodeLine{           }
\DoxyCodeLine{            \textcolor{comment}{// Print the result of the missed ray}}
\DoxyCodeLine{            Debug.WriteLine(bad\_point);}
\DoxyCodeLine{            }
\end{DoxyCodeInclude}
{\ttfamily (NaN, NaN, NaN)} 
\end{DoxyParagraph}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a2d6fd1eb3e172c59014d6b1b24a2c1c9}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a2d6fd1eb3e172c59014d6b1b24a2c1c9}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForPoint@{IntersectForPoint}}
\index{IntersectForPoint@{IntersectForPoint}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForPoint()}{IntersectForPoint()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Point (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{origin,  }\item[{\mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}}}]{direction,  }\item[{float}]{max\+\_\+distance = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast a single ray, and get a point in return if it intersects any geometry. 


\begin{DoxyParams}{Parameters}
{\em bvh} & B\+VH of geometry to intersect. \\
\hline
{\em origin} & Origin point to cast the ray from. \\
\hline
{\em direction} & direction to cast the ray in. \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersections.\+Set to -\/1 for infinite\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} containing the hitpoint. If no hit was detected, the point will be invalid. This can easily be checked using \mbox{\hyperlink{struct_human_factors_1_1_vector3_d_ad5ca9e5b9921fc94c5cbdb139a33cc54}{Vector3\+D.\+Is\+Valid}}.
\end{DoxyReturn}
This calls the other overload with the components of origin and direction.

\begin{DoxyRemark}{Remarks}
Consider calling \mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a97e8b50b5bbb182d12416e7638dad9e9}{Intersect\+For\+Points}} when casting mutliple rays at once since it can make use of parallel processing to drastically reduce the time it takes to get the results of every ray.
\end{DoxyRemark}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Load an OBJ from a filepath  into a new meshinfo instance}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} good\_mesh\_path = \textcolor{stringliteral}{"ExampleModels/plane.obj"};}
\DoxyCodeLine{            MeshInfo Mesh = OBJLoader.LoadOBJ(good\_mesh\_path, CommonRotations.Yup\_To\_Zup);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Construct a BVH from the mesh}}
\DoxyCodeLine{            EmbreeBVH BVH = \textcolor{keyword}{new} EmbreeBVH(Mesh);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Define the X,Y,Z coordinates for the origin and direction}}
\DoxyCodeLine{            \textcolor{keywordtype}{float} x = 0; \textcolor{keywordtype}{float} y = 0; \textcolor{keywordtype}{float} z = 1;}
\DoxyCodeLine{            \textcolor{keywordtype}{float} dx = 0; \textcolor{keywordtype}{float} dy = 0; \textcolor{keywordtype}{float} dz = -\/1;           }
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Cast a ray from origin an direction and get the point}}
\DoxyCodeLine{            Vector3D good\_point = \mbox{\hyperlink{namespace_human_factors}{HumanFactors}}.\mbox{\hyperlink{namespace_human_factors_1_1_ray_tracing}{RayTracing}}.\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer}{EmbreeRaytracer}}.\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}{IntersectForPoint}}(}
\DoxyCodeLine{                BVH, x, y, z, dx, dy, dz, -\/1}
\DoxyCodeLine{           );}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print the point}}
\DoxyCodeLine{            Debug.WriteLine(good\_point);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}
{\ttfamily (0, 0, 0)} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Do the same in a direction we know will miss}}
\DoxyCodeLine{            \textcolor{keywordtype}{float} bad\_dir\_x = 0; \textcolor{keywordtype}{float} bad\_dir\_y = 0; \textcolor{keywordtype}{float} bad\_dir\_z = 1;}
\DoxyCodeLine{            Vector3D bad\_point = \mbox{\hyperlink{namespace_human_factors}{HumanFactors}}.\mbox{\hyperlink{namespace_human_factors_1_1_ray_tracing}{RayTracing}}.\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer}{EmbreeRaytracer}}.\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_afc149e5c713d0fcce5d142c82fd7e292}{IntersectForPoint}}(}
\DoxyCodeLine{                BVH, x, y, z, bad\_dir\_x, bad\_dir\_y, bad\_dir\_z, -\/1}
\DoxyCodeLine{           );}
\DoxyCodeLine{            \textcolor{comment}{// Print the result of the missed ray}}
\DoxyCodeLine{            Debug.WriteLine(bad\_point);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}
{\ttfamily (NaN, NaN, NaN)} 
\end{DoxyParagraph}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a97e8b50b5bbb182d12416e7638dad9e9}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a97e8b50b5bbb182d12416e7638dad9e9}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectForPoints@{IntersectForPoints}}
\index{IntersectForPoints@{IntersectForPoints}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectForPoints()}{IntersectForPoints()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} \mbox{[}$\,$\mbox{]} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+For\+Points (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{origins,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{directions,  }\item[{float}]{max\+\_\+distance = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cast multiple rays and recieve hitpoints in return. 


\begin{DoxyParams}{Parameters}
{\em bvh} & A valid B\+VH containing geometry to intersect with. \\
\hline
{\em origins} & A list of x,y,z coordinates to cast rays in. \\
\hline
{\em directions} & A list of x,y,z directions to fire in. \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider for intersection.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} for the hitpoint of each ray casted in order. If a ray didn\textquotesingle{}t intersect any geometry, then its point will be invalid, checkable using \mbox{\hyperlink{struct_human_factors_1_1_vector3_d_ad5ca9e5b9921fc94c5cbdb139a33cc54}{Vector3\+D.\+Is\+Valid()}}
\end{DoxyReturn}
Can be casted in 3 configurations\+: 


\begin{DoxyItemize}
\item Equal amount of directions/origins\+: Cast a ray for every pair of origin/direction in order. i.\+e. (origin\mbox{[}0\mbox{]}, direction\mbox{[}0\mbox{]}), (origin\mbox{[}1\mbox{]}, direction\mbox{[}1\mbox{]}), etc.  
\item One direction, multiple origins\+: Fire a ray in the given direction from each origin point in origins.  
\item One origin, multiple directions\+: Fire a ray from the origin point in each direction in directions.  
\end{DoxyItemize}


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Length of directions and origins did not match any of the valid cases.\\
\hline
\end{DoxyExceptions}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Load an OBJ from a filepath  into a new meshinfo instance}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} good\_mesh\_path = \textcolor{stringliteral}{"ExampleModels/plane.obj"};}
\DoxyCodeLine{            MeshInfo Mesh = OBJLoader.LoadOBJ(good\_mesh\_path, CommonRotations.Yup\_To\_Zup);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Construct a BVH from the mesh}}
\DoxyCodeLine{            EmbreeBVH BVH = \textcolor{keyword}{new} EmbreeBVH(Mesh);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordtype}{int} num\_points = 5;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Create and fill a vector of origins and directions}}
\DoxyCodeLine{            Vector3D[] origin\_vector = \textcolor{keyword}{new} Vector3D[num\_points];}
\DoxyCodeLine{            Vector3D[] direction\_vector = \textcolor{keyword}{new} Vector3D[num\_points];}
\DoxyCodeLine{            \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_points; i++)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                origin\_vector[i] = \textcolor{keyword}{new} Vector3D(0, i, 1);}
\DoxyCodeLine{                direction\_vector[i] = \textcolor{keyword}{new} Vector3D(0, 0, -\/1);}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Cast all rays in a single call}}
\DoxyCodeLine{            Vector3D[] results = EmbreeRaytracer.IntersectForPoints(BVH, origin\_vector, direction\_vector, -\/1);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print results}}
\DoxyCodeLine{            \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_points; i++)}
\DoxyCodeLine{                Debug.WriteLine(String.Format(\textcolor{stringliteral}{"Origin: \{0\}, Intersection: \{1\}"}, origin\_vector[i], results[i]));}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCode}{0}
\DoxyCodeLine{Origin: (0, 0, 1), Intersection: (0, 0, 0)}
\DoxyCodeLine{Origin: (0, 1, 1), Intersection: (0, 1, 0)}
\DoxyCodeLine{Origin: (0, 2, 1), Intersection: (0, 2, 0)}
\DoxyCodeLine{Origin: (0, 3, 1), Intersection: (0, 3, 0)}
\DoxyCodeLine{Origin: (0, 4, 1), Intersection: (0, 4, 0)}
\end{DoxyCode}
 
\end{DoxyParagraph}
\mbox{\Hypertarget{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a0d503f39da6389a369d58d4945388e33}\label{class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_a0d503f39da6389a369d58d4945388e33}} 
\index{HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}!IntersectOccluded@{IntersectOccluded}}
\index{IntersectOccluded@{IntersectOccluded}!HumanFactors.RayTracing.EmbreeRaytracer@{HumanFactors.RayTracing.EmbreeRaytracer}}
\doxysubsubsection{\texorpdfstring{IntersectOccluded()}{IntersectOccluded()}}
{\footnotesize\ttfamily static bool \mbox{[}$\,$\mbox{]} Human\+Factors.\+Ray\+Tracing.\+Embree\+Raytracer.\+Intersect\+Occluded (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h}{Embree\+B\+VH}}}]{bvh,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{origin,  }\item[{I\+Enumerable$<$ \mbox{\hyperlink{struct_human_factors_1_1_vector3_d}{Vector3D}} $>$}]{direction,  }\item[{float}]{max\+\_\+distance = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Determine if any geometry occludes a point from a direction. 


\begin{DoxyParams}{Parameters}
{\em bvh} & A valid Embree B\+VH. \\
\hline
{\em origin} & One or more origins. \\
\hline
{\em direction} & One or more directions. \\
\hline
{\em max\+\_\+distance} & Maximum distance that a ray can travel. Any hits beyond this point are not counted.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of true or false values indicating hits or misses respectively.
\end{DoxyReturn}
Can be casted in 3 configurations\+: 


\begin{DoxyItemize}
\item Equal amount of directions/origins\+: Cast a ray for every pair of origin/direction in order.\+i.\+e. (origin\mbox{[}0\mbox{]}, direction\mbox{[}0\mbox{]}), (origin\mbox{[}1\mbox{]}, direction\mbox{[}1\mbox{]}), etc.  
\item One direction, multiple origins\+: Cast a ray in the given direction from each origin point in origins.  
\item One origin, multiple directions\+: Cast a ray from the origin point in each direction in directions  
\end{DoxyItemize}

\begin{DoxyRemark}{Remarks}
Occlusion rays are the fastest raycasting function, however are only capable of returning or not they hit anything. This can be useful for line of sight checks. Will execute in parallel if multiple origins/directions are supplied.
\end{DoxyRemark}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Load an OBJ from a filepath  into a new meshinfo instance}}
\DoxyCodeLine{            \textcolor{keywordtype}{string} good\_mesh\_path = \textcolor{stringliteral}{"ExampleModels/plane.obj"};}
\DoxyCodeLine{            MeshInfo Mesh = OBJLoader.LoadOBJ(good\_mesh\_path, CommonRotations.Yup\_To\_Zup);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Construct a BVH from the mesh}}
\DoxyCodeLine{            EmbreeBVH BVH = \textcolor{keyword}{new} EmbreeBVH(Mesh);}
\DoxyCodeLine{}
\end{DoxyCodeInclude}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Create origin and direction arrays}}
\DoxyCodeLine{            Vector3D[] origins = \{ \textcolor{keyword}{new} Vector3D(0, 0, 1), \textcolor{keyword}{new} Vector3D(0, 0, -\/1) \};}
\DoxyCodeLine{            Vector3D[] directions = \{ \textcolor{keyword}{new} Vector3D(0, 0, -\/1), \textcolor{keyword}{new} Vector3D(0, 0, -\/1) \};}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Cast a ray from the origin and direction at every matching index }}
\DoxyCodeLine{            \textcolor{keywordtype}{bool}[] intersections = EmbreeRaytracer.IntersectOccluded(BVH, origins, directions, -\/1);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// Print the results. Ray 1 should intersect the plane, and ray 2 should miss it. }}
\DoxyCodeLine{            Debug.WriteLine(String.Format(\textcolor{stringliteral}{"Ray 1: \{0\}, Ray 2 : \{1\}"}, intersections[0], intersections[1]));}
\DoxyCodeLine{}
\end{DoxyCodeInclude}
{\ttfamily Ray 1\+: True, Ray 2 \+: False} 
\end{DoxyParagraph}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\+Csharp/packages/raytracer/src/\mbox{\hyperlink{_embree_ray_tracer_8cs}{Embree\+Ray\+Tracer.\+cs}}\end{DoxyCompactItemize}
