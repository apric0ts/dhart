<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.18">
  <compounddef id="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer" kind="class" language="C#" prot="public">
    <compoundname>HumanFactors::RayTracing::EmbreeRaytracer</compoundname>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1afc149e5c713d0fcce5d142c82fd7e292" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref></type>
        <definition>static Vector3D HumanFactors.RayTracing.EmbreeRaytracer.IntersectForPoint</definition>
        <argsstring>(EmbreeBVH bvh, float x, float y, float z, float dx, float dy, float dz, float max_distance=-1)</argsstring>
        <name>IntersectForPoint</name>
        <param>
          <type><ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h" kindref="compound">EmbreeBVH</ref></type>
          <declname>bvh</declname>
        </param>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <param>
          <type>float</type>
          <declname>y</declname>
        </param>
        <param>
          <type>float</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dy</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dz</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_distance</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Cast a single ray, and get a point in return if it intersects any geometry. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bvh</parametername>
</parameternamelist>
<parameterdescription>
<para>BVH of geometry to intersect. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>x component of the ray&apos;s origin point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>y component of the ray&apos;s origin point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>z component of the ray&apos;s origin point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dx</parametername>
</parameternamelist>
<parameterdescription>
<para>x component of the ray&apos;s direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dy</parametername>
</parameternamelist>
<parameterdescription>
<para>y component of the ray&apos;s direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dz</parametername>
</parameternamelist>
<parameterdescription>
<para>z component of the ray&apos;s direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_distance</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum distance to consider for intersections. Set to -1 for infinite</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="remark"><para>Consider calling <ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a97e8b50b5bbb182d12416e7638dad9e9" kindref="member">IntersectForPoints</ref> when casting mutliple rays at once since it can make use of parallel processing to drastically reduce the time it takes to cast each ray.</para>
</simplesect>
<simplesect kind="return"><para>A <ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref> containing the hitpoint. If no hit was detected, the point will be invalid. This can easily be checked using <ref refid="struct_human_factors_1_1_vector3_d_1ad5ca9e5b9921fc94c5cbdb139a33cc54" kindref="member">Vector3D.IsValid</ref>.</para>
</simplesect>
<simplesect kind="par"><title>Example</title><para><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>an<sp/>OBJ<sp/>from<sp/>a<sp/>filepath<sp/><sp/>into<sp/>a<sp/>new<sp/>meshinfo<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>good_mesh_path<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;ExampleModels/plane.obj&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MeshInfo<sp/>Mesh<sp/>=<sp/>OBJLoader.LoadOBJ(good_mesh_path,<sp/>CommonRotations.Yup_To_Zup);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>BVH<sp/>from<sp/>the<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EmbreeBVH<sp/>BVH<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>EmbreeBVH(Mesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>an<sp/>origin<sp/>and<sp/>direction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D<sp/>origin<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D<sp/>direction<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Cast<sp/>a<sp/>ray<sp/>from<sp/>origin<sp/>an<sp/>direction<sp/>and<sp/>get<sp/>the<sp/>point</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D<sp/>good_point<sp/>=<sp/><ref refid="namespace_human_factors" kindref="compound">HumanFactors</ref>.<ref refid="namespace_human_factors_1_1_ray_tracing" kindref="compound">RayTracing</ref>.<ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer" kindref="compound">EmbreeRaytracer</ref>.<ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1afc149e5c713d0fcce5d142c82fd7e292" kindref="member">IntersectForPoint</ref>(BVH,<sp/>origin,<sp/>direction,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>point</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.WriteLine(good_point);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
</programlisting><computeroutput>(0, 0, 0)</computeroutput> <programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>the<sp/>same<sp/>in<sp/>a<sp/>direction<sp/>we<sp/>know<sp/>will<sp/>miss</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D<sp/>bad_direction<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D<sp/>bad_point<sp/>=<sp/><ref refid="namespace_human_factors" kindref="compound">HumanFactors</ref>.<ref refid="namespace_human_factors_1_1_ray_tracing" kindref="compound">RayTracing</ref>.<ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer" kindref="compound">EmbreeRaytracer</ref>.<ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1afc149e5c713d0fcce5d142c82fd7e292" kindref="member">IntersectForPoint</ref>(BVH,<sp/>origin,<sp/>bad_direction,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>result<sp/>of<sp/>the<sp/>missed<sp/>ray</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.WriteLine(bad_point);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
</programlisting><computeroutput>(NaN, NaN, NaN)</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Csharp/packages/raytracer/src/EmbreeRayTracer.cs" line="70" column="32"/>
      </memberdef>
      <memberdef kind="function" id="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a2d6fd1eb3e172c59014d6b1b24a2c1c9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref></type>
        <definition>static Vector3D HumanFactors.RayTracing.EmbreeRaytracer.IntersectForPoint</definition>
        <argsstring>(EmbreeBVH bvh, Vector3D origin, Vector3D direction, float max_distance=-1)</argsstring>
        <name>IntersectForPoint</name>
        <param>
          <type><ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h" kindref="compound">EmbreeBVH</ref></type>
          <declname>bvh</declname>
        </param>
        <param>
          <type><ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref></type>
          <declname>origin</declname>
        </param>
        <param>
          <type><ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref></type>
          <declname>direction</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_distance</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Cast a single ray, and get a point in return if it intersects any geometry. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bvh</parametername>
</parameternamelist>
<parameterdescription>
<para>BVH of geometry to intersect. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>origin</parametername>
</parameternamelist>
<parameterdescription>
<para>Origin point to cast the ray from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>direction</parametername>
</parameternamelist>
<parameterdescription>
<para>direction to cast the ray in. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_distance</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum distance to consider for intersections.Set to -1 for infinite</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref> containing the hitpoint. If no hit was detected, the point will be invalid. This can easily be checked using <ref refid="struct_human_factors_1_1_vector3_d_1ad5ca9e5b9921fc94c5cbdb139a33cc54" kindref="member">Vector3D.IsValid</ref>.</para>
</simplesect>
This calls the other overload with the components of origin and direction.</para>
<para><simplesect kind="remark"><para>Consider calling <ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a97e8b50b5bbb182d12416e7638dad9e9" kindref="member">IntersectForPoints</ref> when casting mutliple rays at once since it can make use of parallel processing to drastically reduce the time it takes to get the results of every ray.</para>
</simplesect>
<simplesect kind="par"><title>Example</title><para><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>an<sp/>OBJ<sp/>from<sp/>a<sp/>filepath<sp/><sp/>into<sp/>a<sp/>new<sp/>meshinfo<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>good_mesh_path<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;ExampleModels/plane.obj&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MeshInfo<sp/>Mesh<sp/>=<sp/>OBJLoader.LoadOBJ(good_mesh_path,<sp/>CommonRotations.Yup_To_Zup);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>BVH<sp/>from<sp/>the<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EmbreeBVH<sp/>BVH<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>EmbreeBVH(Mesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>the<sp/>X,Y,Z<sp/>coordinates<sp/>for<sp/>the<sp/>origin<sp/>and<sp/>direction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>x<sp/>=<sp/>0;<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>y<sp/>=<sp/>0;<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>z<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dx<sp/>=<sp/>0;<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dy<sp/>=<sp/>0;<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dz<sp/>=<sp/>-1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Cast<sp/>a<sp/>ray<sp/>from<sp/>origin<sp/>an<sp/>direction<sp/>and<sp/>get<sp/>the<sp/>point</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D<sp/>good_point<sp/>=<sp/><ref refid="namespace_human_factors" kindref="compound">HumanFactors</ref>.<ref refid="namespace_human_factors_1_1_ray_tracing" kindref="compound">RayTracing</ref>.<ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer" kindref="compound">EmbreeRaytracer</ref>.<ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1afc149e5c713d0fcce5d142c82fd7e292" kindref="member">IntersectForPoint</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BVH,<sp/>x,<sp/>y,<sp/>z,<sp/>dx,<sp/>dy,<sp/>dz,<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>point</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.WriteLine(good_point);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><computeroutput>(0, 0, 0)</computeroutput> <programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Do<sp/>the<sp/>same<sp/>in<sp/>a<sp/>direction<sp/>we<sp/>know<sp/>will<sp/>miss</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>bad_dir_x<sp/>=<sp/>0;<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>bad_dir_y<sp/>=<sp/>0;<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>bad_dir_z<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D<sp/>bad_point<sp/>=<sp/><ref refid="namespace_human_factors" kindref="compound">HumanFactors</ref>.<ref refid="namespace_human_factors_1_1_ray_tracing" kindref="compound">RayTracing</ref>.<ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer" kindref="compound">EmbreeRaytracer</ref>.<ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1afc149e5c713d0fcce5d142c82fd7e292" kindref="member">IntersectForPoint</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BVH,<sp/>x,<sp/>y,<sp/>z,<sp/>bad_dir_x,<sp/>bad_dir_y,<sp/>bad_dir_z,<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>result<sp/>of<sp/>the<sp/>missed<sp/>ray</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.WriteLine(bad_point);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><computeroutput>(NaN, NaN, NaN)</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Csharp/packages/raytracer/src/EmbreeRayTracer.cs" line="110" column="32"/>
      </memberdef>
      <memberdef kind="function" id="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a97e8b50b5bbb182d12416e7638dad9e9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref>[]</type>
        <definition>static Vector3D [] HumanFactors.RayTracing.EmbreeRaytracer.IntersectForPoints</definition>
        <argsstring>(EmbreeBVH bvh, IEnumerable&lt; Vector3D &gt; origins, IEnumerable&lt; Vector3D &gt; directions, float max_distance=-1)</argsstring>
        <name>IntersectForPoints</name>
        <param>
          <type><ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h" kindref="compound">EmbreeBVH</ref></type>
          <declname>bvh</declname>
        </param>
        <param>
          <type>IEnumerable&lt; <ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref> &gt;</type>
          <declname>origins</declname>
        </param>
        <param>
          <type>IEnumerable&lt; <ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref> &gt;</type>
          <declname>directions</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_distance</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Cast multiple rays and recieve hitpoints in return. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bvh</parametername>
</parameternamelist>
<parameterdescription>
<para>A valid BVH containing geometry to intersect with. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>origins</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of x,y,z coordinates to cast rays in. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>directions</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of x,y,z directions to fire in. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_distance</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum distance to consider for intersection.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An array of <ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref> for the hitpoint of each ray casted in order. If a ray didn&apos;t intersect any geometry, then its point will be invalid, checkable using <ref refid="struct_human_factors_1_1_vector3_d_1ad5ca9e5b9921fc94c5cbdb139a33cc54" kindref="member">Vector3D.IsValid()</ref></para>
</simplesect>
Can be casted in 3 configurations: </para>
<para><itemizedlist>
<listitem>
<para>Equal amount of directions/origins: Cast a ray for every pair of origin/direction in order. i.e. (origin[0], direction[0]), (origin[1], direction[1]), etc.  </para>
</listitem>
<listitem>
<para>One direction, multiple origins: Fire a ray in the given direction from each origin point in origins.  </para>
</listitem>
<listitem>
<para>One origin, multiple directions: Fire a ray from the origin point in each direction in directions.  </para>
</listitem>
</itemizedlist>
</para>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>System.ArgumentException</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of directions and origins did not match any of the valid cases.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Example</title><para><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>an<sp/>OBJ<sp/>from<sp/>a<sp/>filepath<sp/><sp/>into<sp/>a<sp/>new<sp/>meshinfo<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>good_mesh_path<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;ExampleModels/plane.obj&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MeshInfo<sp/>Mesh<sp/>=<sp/>OBJLoader.LoadOBJ(good_mesh_path,<sp/>CommonRotations.Yup_To_Zup);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>BVH<sp/>from<sp/>the<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EmbreeBVH<sp/>BVH<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>EmbreeBVH(Mesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_points<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>and<sp/>fill<sp/>a<sp/>vector<sp/>of<sp/>origins<sp/>and<sp/>directions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D[]<sp/>origin_vector<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D[num_points];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D[]<sp/>direction_vector<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D[num_points];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_points;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>origin_vector[i]<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>i,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>direction_vector[i]<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Cast<sp/>all<sp/>rays<sp/>in<sp/>a<sp/>single<sp/>call</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D[]<sp/>results<sp/>=<sp/>EmbreeRaytracer.IntersectForPoints(BVH,<sp/>origin_vector,<sp/>direction_vector,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>results</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_points;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.WriteLine(String.Format(</highlight><highlight class="stringliteral">&quot;Origin:<sp/>{0},<sp/>Intersection:<sp/>{1}&quot;</highlight><highlight class="normal">,<sp/>origin_vector[i],<sp/>results[i]));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><programlisting><codeline><highlight class="normal">Origin:<sp/>(0,<sp/>0,<sp/>1),<sp/>Intersection:<sp/>(0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal">Origin:<sp/>(0,<sp/>1,<sp/>1),<sp/>Intersection:<sp/>(0,<sp/>1,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal">Origin:<sp/>(0,<sp/>2,<sp/>1),<sp/>Intersection:<sp/>(0,<sp/>2,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal">Origin:<sp/>(0,<sp/>3,<sp/>1),<sp/>Intersection:<sp/>(0,<sp/>3,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal">Origin:<sp/>(0,<sp/>4,<sp/>1),<sp/>Intersection:<sp/>(0,<sp/>4,<sp/>0)</highlight></codeline>
</programlisting> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Csharp/packages/raytracer/src/EmbreeRayTracer.cs" line="157" column="32"/>
      </memberdef>
      <memberdef kind="function" id="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a929f4285ca85814545d3f0b30cc26048" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_human_factors_1_1_ray_tracing_1_1_ray_result" kindref="compound">RayResult</ref></type>
        <definition>static RayResult HumanFactors.RayTracing.EmbreeRaytracer.IntersectForDistance</definition>
        <argsstring>(EmbreeBVH bvh, Vector3D origin, Vector3D direction, float max_distance=-1)</argsstring>
        <name>IntersectForDistance</name>
        <param>
          <type><ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h" kindref="compound">EmbreeBVH</ref></type>
          <declname>bvh</declname>
        </param>
        <param>
          <type><ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref></type>
          <declname>origin</declname>
        </param>
        <param>
          <type><ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref></type>
          <declname>direction</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_distance</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Cast a single ray and get the distance to its hit and the meshID if it hit anything. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bvh</parametername>
</parameternamelist>
<parameterdescription>
<para>A valid BVH containing the geometry to intersect with. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>origin</parametername>
</parameternamelist>
<parameterdescription>
<para>x,y,z coordinates for the ray&apos;s origin point. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>direction</parametername>
</parameternamelist>
<parameterdescription>
<para>x,y,z coordinates for the direction for the ray to be casted in. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_distance</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum distance to consider for intersection. Set to -1 for infinite.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="remark"><para>This can be faster than <ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a97e8b50b5bbb182d12416e7638dad9e9" kindref="member">IntersectForPoints</ref>, as the data returned is lighter. If you only need the distance or meshID, this function is recommended.</para>
</simplesect>
<simplesect kind="return"><para>A <ref refid="struct_human_factors_1_1_ray_tracing_1_1_ray_result" kindref="compound">RayResult</ref> containing the distance to the hitpoint and meshid it hit. If the distance is equal to -1, then the ray did not intersect any geometry.</para>
</simplesect>
<simplesect kind="par"><title>Example</title><para><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>an<sp/>OBJ<sp/>from<sp/>a<sp/>filepath<sp/><sp/>into<sp/>a<sp/>new<sp/>meshinfo<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>good_mesh_path<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;ExampleModels/plane.obj&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MeshInfo<sp/>Mesh<sp/>=<sp/>OBJLoader.LoadOBJ(good_mesh_path,<sp/>CommonRotations.Yup_To_Zup);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>BVH<sp/>from<sp/>the<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EmbreeBVH<sp/>BVH<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>EmbreeBVH(Mesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>origin<sp/>and<sp/>direction<sp/>to<sp/>cast<sp/>ray<sp/>straight<sp/>down<sp/>at<sp/>the<sp/>plane</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D<sp/>origin<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D<sp/>direction<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Cast<sp/>ray<sp/>and<sp/>get<sp/>the<sp/>distance/MeshID</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RayResult<sp/>result<sp/>=<sp/>EmbreeRaytracer.IntersectForDistance(BVH,<sp/>origin,<sp/>direction);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>distance/MeshID</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.WriteLine(result);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><computeroutput>[1,0]</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Csharp/packages/raytracer/src/EmbreeRayTracer.cs" line="186" column="33"/>
      </memberdef>
      <memberdef kind="function" id="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a04dd5147c6613ec137069bf2fdaa0e73" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_human_factors_1_1_ray_tracing_1_1_ray_results" kindref="compound">RayResults</ref></type>
        <definition>static RayResults HumanFactors.RayTracing.EmbreeRaytracer.IntersectForDistances</definition>
        <argsstring>(EmbreeBVH bvh, IEnumerable&lt; Vector3D &gt; origins, IEnumerable&lt; Vector3D &gt; directions, float max_distance=-1)</argsstring>
        <name>IntersectForDistances</name>
        <param>
          <type><ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h" kindref="compound">EmbreeBVH</ref></type>
          <declname>bvh</declname>
        </param>
        <param>
          <type>IEnumerable&lt; <ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref> &gt;</type>
          <declname>origins</declname>
        </param>
        <param>
          <type>IEnumerable&lt; <ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref> &gt;</type>
          <declname>directions</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_distance</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Cast multiple rays and recieve the distance and meshid of geometry intersected by each in return. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bvh</parametername>
</parameternamelist>
<parameterdescription>
<para>A valid BVH containing geometry to intersect with. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>origins</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of x, y, z coordinates to cast rays in. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>directions</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of x, y, z directions to fire in. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_distance</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum distance to consider for intersection.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An array of <ref refid="class_human_factors_1_1_ray_tracing_1_1_ray_results" kindref="compound">RayResults</ref> for the hitpoint of each ray casted in order. If a ray didn&apos;t intersect any geometry, then its distance and meshid will be -1.</para>
</simplesect>
Can be casted in 3 configurations: </para>
<para><itemizedlist>
<listitem>
<para>Equal amount of directions/origins: Cast a ray for every pair of origin/direction in order.i.e. (origin[0], direction[0]), (origin[1], direction[1]), etc.  </para>
</listitem>
<listitem>
<para>One direction, multiple origins: Cast a ray in the given direction from each origin point in origins.  </para>
</listitem>
<listitem>
<para>One origin, multiple directions: Cast a ray from the origin point in each direction in directions  </para>
</listitem>
</itemizedlist>
</para>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>System.ArgumentException</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of directions and origins did not match any of the valid cases. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Example</title><para><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>an<sp/>OBJ<sp/>from<sp/>a<sp/>filepath<sp/><sp/>into<sp/>a<sp/>new<sp/>meshinfo<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>good_mesh_path<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;ExampleModels/plane.obj&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MeshInfo<sp/>Mesh<sp/>=<sp/>OBJLoader.LoadOBJ(good_mesh_path,<sp/>CommonRotations.Yup_To_Zup);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>BVH<sp/>from<sp/>the<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EmbreeBVH<sp/>BVH<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>EmbreeBVH(Mesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>origin/distance<sp/>arrays</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_rays<sp/>=<sp/>6;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D[]<sp/>origin_vector<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D[num_rays];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D[]<sp/>direction_vector<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D[num_rays];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_rays;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>origin_vector[i]<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>direction_vector[i]<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Cast<sp/>rays<sp/>and<sp/>get<sp/>results</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RayResults<sp/>results<sp/>=<sp/>EmbreeRaytracer.IntersectForDistances(BVH,<sp/>origin_vector,<sp/>direction_vector);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>Results.<sp/>The<sp/>distance<sp/>should<sp/>equal<sp/>the<sp/>origin&apos;s<sp/>z<sp/>value,<sp/>except<sp/>for<sp/>the<sp/>first<sp/>one,<sp/>which</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>should<sp/>miss<sp/>since<sp/>it&apos;s<sp/>inside<sp/>the<sp/>plane</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_rays;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.WriteLine(</highlight><highlight class="stringliteral">&quot;Origin:<sp/>{0},<sp/>Result:<sp/>{1}&quot;</highlight><highlight class="normal">,<sp/>origin_vector[i],<sp/>results[i]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><programlisting><codeline><highlight class="normal">Origin:<sp/>(0,<sp/>0,<sp/>0),<sp/>Result:<sp/>[-1,-1]</highlight></codeline>
<codeline><highlight class="normal">Origin:<sp/>(0,<sp/>0,<sp/>1),<sp/>Result:<sp/>[1,0]</highlight></codeline>
<codeline><highlight class="normal">Origin:<sp/>(0,<sp/>0,<sp/>2),<sp/>Result:<sp/>[2,0]</highlight></codeline>
<codeline><highlight class="normal">Origin:<sp/>(0,<sp/>0,<sp/>3),<sp/>Result:<sp/>[3,0]</highlight></codeline>
<codeline><highlight class="normal">Origin:<sp/>(0,<sp/>0,<sp/>4),<sp/>Result:<sp/>[4,0]</highlight></codeline>
<codeline><highlight class="normal">Origin:<sp/>(0,<sp/>0,<sp/>5),<sp/>Result:<sp/>[5,0]</highlight></codeline>
</programlisting> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Csharp/packages/raytracer/src/EmbreeRayTracer.cs" line="237" column="34"/>
      </memberdef>
      <memberdef kind="function" id="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a0d503f39da6389a369d58d4945388e33" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool[]</type>
        <definition>static bool [] HumanFactors.RayTracing.EmbreeRaytracer.IntersectOccluded</definition>
        <argsstring>(EmbreeBVH bvh, IEnumerable&lt; Vector3D &gt; origin, IEnumerable&lt; Vector3D &gt; direction, float max_distance=-1)</argsstring>
        <name>IntersectOccluded</name>
        <param>
          <type><ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h" kindref="compound">EmbreeBVH</ref></type>
          <declname>bvh</declname>
        </param>
        <param>
          <type>IEnumerable&lt; <ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref> &gt;</type>
          <declname>origin</declname>
        </param>
        <param>
          <type>IEnumerable&lt; <ref refid="struct_human_factors_1_1_vector3_d" kindref="compound">Vector3D</ref> &gt;</type>
          <declname>direction</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_distance</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Determine if any geometry occludes a point from a direction. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bvh</parametername>
</parameternamelist>
<parameterdescription>
<para>A valid Embree BVH. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>origin</parametername>
</parameternamelist>
<parameterdescription>
<para>One or more origins. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>direction</parametername>
</parameternamelist>
<parameterdescription>
<para>One or more directions. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_distance</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum distance that a ray can travel. Any hits beyond this point are not counted.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An array of true or false values indicating hits or misses respectively.</para>
</simplesect>
Can be casted in 3 configurations: </para>
<para><itemizedlist>
<listitem>
<para>Equal amount of directions/origins: Cast a ray for every pair of origin/direction in order.i.e. (origin[0], direction[0]), (origin[1], direction[1]), etc.  </para>
</listitem>
<listitem>
<para>One direction, multiple origins: Cast a ray in the given direction from each origin point in origins.  </para>
</listitem>
<listitem>
<para>One origin, multiple directions: Cast a ray from the origin point in each direction in directions  </para>
</listitem>
</itemizedlist>
</para>
<para><simplesect kind="remark"><para>Occlusion rays are the fastest raycasting function, however are only capable of returning or not they hit anything. This can be useful for line of sight checks. Will execute in parallel if multiple origins/directions are supplied.</para>
</simplesect>
<simplesect kind="par"><title>Example</title><para><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>an<sp/>OBJ<sp/>from<sp/>a<sp/>filepath<sp/><sp/>into<sp/>a<sp/>new<sp/>meshinfo<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>good_mesh_path<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;ExampleModels/plane.obj&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MeshInfo<sp/>Mesh<sp/>=<sp/>OBJLoader.LoadOBJ(good_mesh_path,<sp/>CommonRotations.Yup_To_Zup);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>BVH<sp/>from<sp/>the<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EmbreeBVH<sp/>BVH<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>EmbreeBVH(Mesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><programlisting filename="raytracer\test_raytracer.cs"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>origin<sp/>and<sp/>direction<sp/>arrays</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D[]<sp/>origins<sp/>=<sp/>{<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>1),<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>-1)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3D[]<sp/>directions<sp/>=<sp/>{<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>-1),<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Vector3D(0,<sp/>0,<sp/>-1)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Cast<sp/>a<sp/>ray<sp/>from<sp/>the<sp/>origin<sp/>and<sp/>direction<sp/>at<sp/>every<sp/>matching<sp/>index<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">[]<sp/>intersections<sp/>=<sp/>EmbreeRaytracer.IntersectOccluded(BVH,<sp/>origins,<sp/>directions,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>results.<sp/>Ray<sp/>1<sp/>should<sp/>intersect<sp/>the<sp/>plane,<sp/>and<sp/>ray<sp/>2<sp/>should<sp/>miss<sp/>it.<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.WriteLine(String.Format(</highlight><highlight class="stringliteral">&quot;Ray<sp/>1:<sp/>{0},<sp/>Ray<sp/>2<sp/>:<sp/>{1}&quot;</highlight><highlight class="normal">,<sp/>intersections[0],<sp/>intersections[1]));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting><computeroutput>Ray 1: True, Ray 2 : False</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Csharp/packages/raytracer/src/EmbreeRayTracer.cs" line="283" column="28"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Cast rays with Intel&apos;s Embree raytracing library. </para>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="remark"><para>All functions in this class first require the creation of an <ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h" kindref="compound">EmbreeBVH</ref> with valid mesh geometry.</para>
</simplesect>
<simplesect kind="see"><para><ref refid="class_human_factors_1_1_geometry_1_1_mesh_info" kindref="compound">Geometry.MeshInfo</ref> for details on converting a mesh to a format that <ref refid="namespace_human_factors" kindref="compound">HumanFactors</ref> can interpret </para>
</simplesect>
<simplesect kind="see"><para><ref refid="class_human_factors_1_1_ray_tracing_1_1_embree_b_v_h" kindref="compound">EmbreeBVH</ref> for details on generating a BVH from geometry. </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="src/Csharp/packages/raytracer/src/EmbreeRayTracer.cs" line="39" column="19" bodyfile="src/Csharp/packages/raytracer/src/EmbreeRayTracer.cs" bodystart="40" bodyend="289"/>
    <listofallmembers>
      <member refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a929f4285ca85814545d3f0b30cc26048" prot="public" virt="non-virtual"><scope>HumanFactors::RayTracing::EmbreeRaytracer</scope><name>IntersectForDistance</name></member>
      <member refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a04dd5147c6613ec137069bf2fdaa0e73" prot="public" virt="non-virtual"><scope>HumanFactors::RayTracing::EmbreeRaytracer</scope><name>IntersectForDistances</name></member>
      <member refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1afc149e5c713d0fcce5d142c82fd7e292" prot="public" virt="non-virtual"><scope>HumanFactors::RayTracing::EmbreeRaytracer</scope><name>IntersectForPoint</name></member>
      <member refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a2d6fd1eb3e172c59014d6b1b24a2c1c9" prot="public" virt="non-virtual"><scope>HumanFactors::RayTracing::EmbreeRaytracer</scope><name>IntersectForPoint</name></member>
      <member refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a97e8b50b5bbb182d12416e7638dad9e9" prot="public" virt="non-virtual"><scope>HumanFactors::RayTracing::EmbreeRaytracer</scope><name>IntersectForPoints</name></member>
      <member refid="class_human_factors_1_1_ray_tracing_1_1_embree_raytracer_1a0d503f39da6389a369d58d4945388e33" prot="public" virt="non-virtual"><scope>HumanFactors::RayTracing::EmbreeRaytracer</scope><name>IntersectOccluded</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
