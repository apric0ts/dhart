\hypertarget{a00390}{}\doxysection{Pathfinding}
\label{a00390}\index{Pathfinding@{Pathfinding}}


Find paths between different points in a graph.  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} \mbox{\hyperlink{a00390_ga3dc85450e989a996a3c3fcfad0a5944e}{Create\+Path}} (const \mbox{\hyperlink{a01497}{H\+F\+::\+Spatial\+Structures\+::\+Graph}} $\ast$g, int start, int end, const char $\ast$cost\+\_\+type, int $\ast$out\+\_\+size, \mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$out\+\_\+path, \mbox{\hyperlink{a02025}{H\+F\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$out\+\_\+data)
\begin{DoxyCompactList}\small\item\em Find the shortest path from start to end. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} \mbox{\hyperlink{a00390_gae1ac2805c3b86883bb88269ed3868367}{Create\+Paths}} (const \mbox{\hyperlink{a01497}{H\+F\+::\+Spatial\+Structures\+::\+Graph}} $\ast$g, const int $\ast$start, const int $\ast$end, const char $\ast$cost\+\_\+type, \mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$out\+\_\+path\+\_\+ptr\+\_\+holder, \mbox{\hyperlink{a02025}{H\+F\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$out\+\_\+path\+\_\+member\+\_\+ptr\+\_\+holder, int $\ast$out\+\_\+sizes, int num\+\_\+paths)
\begin{DoxyCompactList}\small\item\em Find multiple shortest paths in paralllel. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} \mbox{\hyperlink{a00390_gaac725d282f4fecd3aba1b3273c26e7e1}{Get\+Path\+Info}} (\mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$p, \mbox{\hyperlink{a02025}{H\+F\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$out\+\_\+member\+\_\+ptr, int $\ast$out\+\_\+size)
\begin{DoxyCompactList}\small\item\em Get the size of a path and a pointer to its path members. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} \mbox{\hyperlink{a00390_ga884a3374d971261a01ccfd3b21e288e5}{Destroy\+Path}} (\mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$path\+\_\+to\+\_\+destroy)
\begin{DoxyCompactList}\small\item\em Delete a path. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} \mbox{\hyperlink{a00390_gaba6ec6ce84974dd6a311d7d65dd34221}{Create\+All\+To\+All\+Paths}} (const \mbox{\hyperlink{a01497}{H\+F\+::\+Spatial\+Structures\+::\+Graph}} $\ast$g, const char $\ast$cost\+\_\+type, \mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$out\+\_\+path\+\_\+ptr\+\_\+holder, \mbox{\hyperlink{a02025}{H\+F\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$out\+\_\+path\+\_\+member\+\_\+ptr\+\_\+holder, int $\ast$out\+\_\+sizes, int num\+\_\+paths)
\begin{DoxyCompactList}\small\item\em Find a path from every node in a graph to every other node. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} \mbox{\hyperlink{a00390_ga27b1f45019ccbda909301520d1c738ca}{Calculate\+Distance\+And\+Predecessor}} (const \mbox{\hyperlink{a01497}{H\+F\+::\+Spatial\+Structures\+::\+Graph}} $\ast$g, const char $\ast$cost\+\_\+name, std\+::vector$<$ float $>$ $\ast$$\ast$out\+\_\+dist\+\_\+vector, float $\ast$$\ast$out\+\_\+dist\+\_\+data, std\+::vector$<$ int $>$ $\ast$$\ast$out\+\_\+pred\+\_\+vector, int $\ast$$\ast$out\+\_\+pred\+\_\+data)
\begin{DoxyCompactList}\small\item\em Calculate the distance and predecessor matricies for a graph. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Find paths between different points in a graph. 

\hypertarget{a00390_mesh_setup_energy_blob}{}\doxysubsection{Mesh setup (energy blob)}\label{a00390_mesh_setup_energy_blob}
Begin by loading an .obj file\+:~\newline



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Status code variable, value returned by C Interface functions}}
\DoxyCodeLine{\textcolor{comment}{// See documentation for HF::Exceptions::HF\_STATUS for error code definitions.}}
\DoxyCodeLine{\textcolor{keywordtype}{int} status = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Get model path}}
\DoxyCodeLine{\textcolor{comment}{// This is a relative path to your obj file.}}
\DoxyCodeLine{\textcolor{keyword}{const} std::string obj\_path\_str = \textcolor{stringliteral}{"energy\_blob\_zup.obj"};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Size of obj file string (character count)}}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} obj\_length = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(obj\_path\_str.size());}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// This will point to memory on free store.}}
\DoxyCodeLine{\textcolor{comment}{// The memory will be allocated inside the LoadOBJ function,}}
\DoxyCodeLine{\textcolor{comment}{// and it must be freed using DestroyMeshInfo.}}
\DoxyCodeLine{std::vector<HF::Geometry::MeshInfo>* loaded\_obj = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Load mesh.}}
\DoxyCodeLine{\textcolor{comment}{// Notice that we pass the address of the loaded\_obj pointer}}
\DoxyCodeLine{\textcolor{comment}{// to LoadOBJ. We do not want to pass loaded\_obj by value, but by address -\/-\/}}
\DoxyCodeLine{\textcolor{comment}{// so that we can dereference it and assign it to the address of (pointer to)}}
\DoxyCodeLine{\textcolor{comment}{// the free store memory allocated within LoadOBJ.}}
\DoxyCodeLine{\textcolor{keyword}{const} std::array<float, 3> rot \{ 0.0f, 0.0f, 0.0f \};    \textcolor{comment}{// No rotation.}}
\DoxyCodeLine{status = \mbox{\hyperlink{a00389_ga0805e80d13b29aeddc35f0bcf3f16a1a}{LoadOBJ}}(obj\_path\_str.c\_str(), obj\_length, rot[0], rot[1], rot[2], \&loaded\_obj);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{    \textcolor{comment}{// All C Interface functions return a status code.}}
\DoxyCodeLine{    \textcolor{comment}{// Error!}}
\DoxyCodeLine{    std::cerr << \textcolor{stringliteral}{"Error at LoadOBJ, code: "} << status << std::endl;}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{else} \{}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"LoadOBJ loaded mesh successfully into loaded\_obj at address "} << loaded\_obj << \textcolor{stringliteral}{", code: "} << status << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}


Then, review the example at \mbox{\hyperlink{a00391_raytracer_setup}{Raytracer setup}} (how to create a B\+VH).~\newline
\hypertarget{a00390_generate_graph}{}\doxysubsection{Graph generation}\label{a00390_generate_graph}
You will then generate a graph, using the B\+VH\+:~\newline



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Define start point.}}
\DoxyCodeLine{\textcolor{comment}{// These are Cartesian coordinates.}}
\DoxyCodeLine{\textcolor{comment}{// If not above solid ground, no nodes will be generated.}}
\DoxyCodeLine{\textcolor{keyword}{const} std::array<float, 3> start\_point\{ -\/30.0f, 0.0f, 20.0f \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Define spacing.}}
\DoxyCodeLine{\textcolor{comment}{// This is the spacing between nodes, with respect to each axis.}}
\DoxyCodeLine{\textcolor{comment}{// Lower values create more nodes, yielding a higher resolution graph.}}
\DoxyCodeLine{\textcolor{keyword}{const} std::array<float, 3> spacing\{ 2.0f, 2.0f, 180.0f \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Value of -\/ 1 will generate infinitely many nodes.}}
\DoxyCodeLine{\textcolor{comment}{// Final node count may be greater than this value.}}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_nodes = 5000;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} up\_step = 30;                 \textcolor{comment}{// Maximum step height the graph can traverse.}}
\DoxyCodeLine{                                        \textcolor{comment}{// Steps steeper than this are considered to be inaccessible.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} down\_step = 70;               \textcolor{comment}{// Maximum step down the graph can traverse.}}
\DoxyCodeLine{                                        \textcolor{comment}{// Steps steeper than this are considered to be inaccessible.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} up\_slope = 60;                \textcolor{comment}{// Maximum upward slope the graph can traverse (in degrees).}}
\DoxyCodeLine{                                        \textcolor{comment}{// Slopes steeper than this are considered to be inaccessible.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} down\_slope = 60;              \textcolor{comment}{// Maximum downward slope the graph can traverse (in degrees).}}
\DoxyCodeLine{                                        \textcolor{comment}{// Slopes steeper than this are considered to be inaccessible.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_step\_connections = 1;     \textcolor{comment}{// Multiplier for number of children to generate for each node.}}
\DoxyCodeLine{                                        \textcolor{comment}{// Increasing this value increases the number of edges in the graph,}}
\DoxyCodeLine{                                        \textcolor{comment}{// therefore increasing the memory footprint of the algorithm overall.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} core\_count = -\/1;              \textcolor{comment}{// CPU core count. A value of (-\/1) will use all available cores.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Generate graph.}}
\DoxyCodeLine{\textcolor{comment}{// Notice that we pass the address of the graph pointer into GenerateGraph.}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{// GenerateGraph will assign the deferenced address to a pointer that points}}
\DoxyCodeLine{\textcolor{comment}{// to memory on the free store. We will call DestroyGraph to release the memory resources later on.}}
\DoxyCodeLine{\mbox{\hyperlink{a01497}{HF::SpatialStructures::Graph}}* graph = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{}
\DoxyCodeLine{status = \mbox{\hyperlink{a00388_gac2583dc1ee6786b15fa4f06bfde2130a}{GenerateGraph}}(bvh, start\_point.data(), spacing.data(), max\_nodes,}
\DoxyCodeLine{    up\_step, down\_step, up\_slope, down\_slope,}
\DoxyCodeLine{    max\_step\_connections, core\_count, \&graph);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{    std::cerr << \textcolor{stringliteral}{"Error at GenerateGraph, code: "} << status << std::endl;}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{else} \{}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Generate graph ran successfully -\/ graph stored at address "} << graph << \textcolor{stringliteral}{", code: "} << status << std::endl;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Always compress the graph after generating a graph/adding new edges}}
\DoxyCodeLine{status = \mbox{\hyperlink{a00392_gab7ecc1be5c746ed3f99ab7494316c65d}{Compress}}(graph);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{    \textcolor{comment}{// Error!}}
\DoxyCodeLine{    std::cerr << \textcolor{stringliteral}{"Error at Compress, code: "} << status << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{a00390_get_all_nodes}{}\doxysubsection{Get nodes from graph}\label{a00390_get_all_nodes}
You can retrieve the nodes from the generated graph like this\+:~\newline



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Get nodes.}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{// The address of the local variable node\_vector will be passed to GetAllNodesFromGraph;}}
\DoxyCodeLine{\textcolor{comment}{// it will be dereferenced inside that function and assigned memory via operator new.}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{// We will have to call DestroyNodes on node\_vector to properly release this memory.}}
\DoxyCodeLine{\textcolor{comment}{// node\_vector\_data points to the internal buffer that resides within *(node\_vector).}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{// When we call DestroyNodes, node\_vector\_data's memory will also be released.}}
\DoxyCodeLine{std::vector<HF::SpatialStructures::Node>* node\_vector = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{\mbox{\hyperlink{a02017}{HF::SpatialStructures::Node}}* node\_vector\_data = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{}
\DoxyCodeLine{status = \mbox{\hyperlink{a00392_ga0cc5b82caab046c65a201e4e7be5e9d4}{GetAllNodesFromGraph}}(graph, \&node\_vector, \&node\_vector\_data);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{    \textcolor{comment}{// Error!}}
\DoxyCodeLine{    std::cerr << \textcolor{stringliteral}{"Error at GetAllNodesFromGraph, code: "} << status << std::endl;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Get size of node vector}}
\DoxyCodeLine{\textcolor{keywordtype}{int} node\_vector\_size = -\/1;}
\DoxyCodeLine{status = \mbox{\hyperlink{a00392_gac17c1fc05e6bf6900bac8689b7619bfb}{GetSizeOfNodeVector}}(node\_vector, \&node\_vector\_size);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{    \textcolor{comment}{// Error!}}
\DoxyCodeLine{    std::cerr << \textcolor{stringliteral}{"Error at GetSizeOfNodeVector code: "} << status << std::endl;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Print number of nodes in the graph}}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_node = node\_vector\_size -\/ 1;  \textcolor{comment}{// This is the max index of *node\_vector}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Graph Generated with "} << node\_vector\_size << \textcolor{stringliteral}{" nodes"} << std::endl;}
\end{DoxyCode}
\hypertarget{a00390_nodes_teardown}{}\doxysubsection{Destroy nodes from graph}\label{a00390_nodes_teardown}
When you are finished with the graph node container, you must destroy it\+:~\newline



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// destroy vector<Node>}}
\DoxyCodeLine{status = \mbox{\hyperlink{a00392_ga87e9b9ecfc5293712d75f3cb8c992c77}{DestroyNodes}}(node\_vector);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{    std::cerr << \textcolor{stringliteral}{"Error at DestroyNodes, code: "} << status << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{a00390_graph_teardown}{}\doxysubsection{Destroy graph}\label{a00390_graph_teardown}
When you are finished with the graph, you must destroy it\+:~\newline



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// destroy graph}}
\DoxyCodeLine{status = \mbox{\hyperlink{a00392_ga645abacd11e1fa535f953344aaa77727}{DestroyGraph}}(graph);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{    std::cerr << \textcolor{stringliteral}{"Error at DestroyGraph, code: "} << status << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{a00390_ga27b1f45019ccbda909301520d1c738ca}\label{a00390_ga27b1f45019ccbda909301520d1c738ca}} 
\index{Pathfinding@{Pathfinding}!CalculateDistanceAndPredecessor@{CalculateDistanceAndPredecessor}}
\index{CalculateDistanceAndPredecessor@{CalculateDistanceAndPredecessor}!Pathfinding@{Pathfinding}}
\doxysubsubsection{\texorpdfstring{CalculateDistanceAndPredecessor()}{CalculateDistanceAndPredecessor()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} Calculate\+Distance\+And\+Predecessor (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a01497}{H\+F\+::\+Spatial\+Structures\+::\+Graph}} $\ast$}]{g,  }\item[{const char $\ast$}]{cost\+\_\+name,  }\item[{std\+::vector$<$ float $>$ $\ast$$\ast$}]{out\+\_\+dist\+\_\+vector,  }\item[{float $\ast$$\ast$}]{out\+\_\+dist\+\_\+data,  }\item[{std\+::vector$<$ int $>$ $\ast$$\ast$}]{out\+\_\+pred\+\_\+vector,  }\item[{int $\ast$$\ast$}]{out\+\_\+pred\+\_\+data }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00359}{Cinterface/pathfinder\+\_\+\+C.\+h}}$>$}



Calculate the distance and predecessor matricies for a graph. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph calculate the distance and predecessor matricies for\\
\hline
{\em cost\+\_\+name} & The name of the cost type to use for generating paths. Leaving as an empty string will use the default cost of {\ttfamily g}.\\
\hline
{\em out\+\_\+dist\+\_\+vector} & Pointer to be updated with a vector containing the distance matrix \\
\hline
{\em out\+\_\+dist\+\_\+data} & Pointer to be updated with a pointer to the data contained by {\ttfamily out\+\_\+dist\+\_\+vector}\\
\hline
{\em out\+\_\+pred\+\_\+vector} & Pointer to be updated with the vector containing the predecessor matrix. \\
\hline
{\em out\+\_\+pred\+\_\+data} & Pointer to be updated with the data of {\ttfamily out\+\_\+pred\+\_\+vector}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+OK} If the function completed successfully. 

{\ttfamily H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+N\+O\+\_\+\+C\+O\+ST} If {\ttfamily cost type} was not the key of any existing cost type in the graph.
\end{DoxyReturn}
\begin{DoxyPostcond}{Postcondition}
1) {\ttfamily out\+\_\+dist\+\_\+vector} is updated to contain a pointer to the newly created distance matrix 

2) {\ttfamily out\+\_\+dist\+\_\+data} is updated to contain a pointer to the data of {\ttfamily out\+\_\+dist\+\_\+vector} 

3) {\ttfamily out\+\_\+pred\+\_\+vector} is updated to contain a pointer to the newly created predecessor matrix 

4) {\ttfamily out\+\_\+pred\+\_\+data} is updated to contain a pointer to the data of {\ttfamily out\+\_\+pred\+\_\+vector}
\end{DoxyPostcond}
\begin{DoxyWarning}{Warning}
It is the caller\textquotesingle{}s responsibility to deallocate the distance and predecessor matricies by calling Destroy\+Int\+Vector and Destroy\+Float\+Vector. Failing to do so W\+I\+LL leak memory. Do N\+OT attempt to delete the data arrays, they will automatically be deleted when their vectors are deleted.
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00391_raytracer_setup}{Raytracer setup}} (how to create a B\+VH), \mbox{\hyperlink{a00391_raytracer_teardown}{Raytracer teardown}} (how to destroy a B\+VH) 

\mbox{\hyperlink{a00347_af77723a4383b278169e80cf0e361ec44}{Destroy\+Float\+Vector}} 

\mbox{\hyperlink{a00347_aa1d3e9d7be8628eb59f2ef8f8e156a75}{Destroy\+Int\+Vector}} 

\mbox{\hyperlink{a00390_ga884a3374d971261a01ccfd3b21e288e5}{Destroy\+Path}} for information on deleting the path after usage.
\end{DoxySeeAlso}
Begin by reviewing the example at \mbox{\hyperlink{a00391_raytracer_setup}{Raytracer setup}} to load an .obj file (mesh), and create a B\+VH from the mesh.~\newline
 Then generate a graph (\mbox{\hyperlink{a00390_generate_graph}{Graph generation}}) from the B\+VH -- see \mbox{\hyperlink{a00390_get_all_nodes}{Get nodes from graph}} on how to retrieve nodes from the graph.~\newline


\begin{DoxyParagraph}{Example}

\end{DoxyParagraph}
Create a graph, add some edges -- then invoke \mbox{\hyperlink{a00390_ga27b1f45019ccbda909301520d1c738ca}{Calculate\+Distance\+And\+Predecessor}} ~\newline
 
\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 Print the result\+:~\newline
 
\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 ~\newline
 {\ttfamily $>$$>$$>$ Distance Matrix\+: \mbox{[}0.\+000000, 10.\+000000, 5.\+000000, 10.\+000000, 0.\+000000, 15.\+000000, -\/1.\+000000, -\/1.\+000000, 0.\+000000\mbox{]}}~\newline
{\ttfamily $>$$>$$>$ Predecessor Matrix\+: \mbox{[}0, 0, 0, 1, 1, 0, -\/1, -\/1, 2\mbox{]}\textbackslash{}n} 

Definition at line 171 of file pathfinder\+\_\+\+C.\+cpp.



References H\+F\+::\+Pathfinding\+::\+Create\+Boost\+Graph(), H\+F\+::\+Pathfinding\+::\+Distance\+And\+Predecessor\+::dist, H\+F\+::\+Pathfinding\+::\+Generate\+Distance\+And\+Pred(), H\+F\+::\+Exceptions\+::\+N\+O\+\_\+\+C\+O\+ST, H\+F\+::\+Exceptions\+::\+OK, and H\+F\+::\+Pathfinding\+::\+Distance\+And\+Predecessor\+::pred.



Referenced by T\+E\+S\+T(), and C\+Interface\+Tests\+::\+T\+E\+S\+T().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00390_ga27b1f45019ccbda909301520d1c738ca_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00390_ga27b1f45019ccbda909301520d1c738ca_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00390_gaba6ec6ce84974dd6a311d7d65dd34221}\label{a00390_gaba6ec6ce84974dd6a311d7d65dd34221}} 
\index{Pathfinding@{Pathfinding}!CreateAllToAllPaths@{CreateAllToAllPaths}}
\index{CreateAllToAllPaths@{CreateAllToAllPaths}!Pathfinding@{Pathfinding}}
\doxysubsubsection{\texorpdfstring{CreateAllToAllPaths()}{CreateAllToAllPaths()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} Create\+All\+To\+All\+Paths (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a01497}{H\+F\+::\+Spatial\+Structures\+::\+Graph}} $\ast$}]{g,  }\item[{const char $\ast$}]{cost\+\_\+type,  }\item[{\mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$}]{out\+\_\+path\+\_\+ptr\+\_\+holder,  }\item[{\mbox{\hyperlink{a02025}{H\+F\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$}]{out\+\_\+path\+\_\+member\+\_\+ptr\+\_\+holder,  }\item[{int $\ast$}]{out\+\_\+sizes,  }\item[{int}]{num\+\_\+paths }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00359}{Cinterface/pathfinder\+\_\+\+C.\+h}}$>$}



Find a path from every node in a graph to every other node. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph to conduct the search on nodes that already exist within the graph.\\
\hline
{\em cost\+\_\+name} & The name of the cost type to use for generating paths. Leaving as an empty string will use the default cost of {\ttfamily g}.\\
\hline
{\em out\+\_\+size} & An empty array of integers that will be updated to contain the length of every path in {\ttfamily path\+\_\+members}. Paths that could not be generated will be left with a length of zero.\\
\hline
{\em out\+\_\+path} & Location for the the path pointer array to be created. Paths that could not be generated will be left as null pointers.\\
\hline
{\em out\+\_\+data} & Location for the pathmember pointer array to be created. All path member pointers will point to the Path\+Members of the Path in paths at the same index. Paths that could not be generated will be left as null pointers.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+OK} The completed successfully and all postconditions were fulfilled. 

{\ttfamily H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+N\+O\+\_\+\+C\+O\+ST} {\ttfamily cost\+\_\+name} is not a valid cost type name
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
If {\ttfamily cost\+\_\+type} is specified, {\ttfamily cost\+\_\+type} must be the the key of an already existing cost in {\ttfamily g}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
1) {\ttfamily out\+\_\+path\+\_\+members} will point to a vector of pointers to vectors of Path\+Members with an element for every path. Paths that could not be generated will be set to null pointers. 

2) {\ttfamily out\+\_\+paths} will point to a vector of pointers to paths with an element for every path. Paths that could not be generated will be set to null pointers. 

3) {\ttfamily out\+\_\+sizes} will point to an array of integers containing the size of every path in {\ttfamily out\+\_\+paths}. Paths that could not be generated will have a size of 0.
\end{DoxyPostcond}
\begin{DoxyWarning}{Warning}
The caller is responsible for freeing all of the memory allocated in {\ttfamily out\+\_\+paths}and {\ttfamily out\+\_\+sizes}. The contents of {\ttfamily out\+\_\+path\+\_\+members} will automatically be deleted when the path they belong to is deleted. Do not try to manually delete {\ttfamily out\+\_\+path\+\_\+members} or the path that owns it will throw a null pointer exception when it is deleted.
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00389_mesh_setup}{Mesh setup}} (how to load an .O\+BJ file/create a mesh) 

\mbox{\hyperlink{a00391_raytracer_setup}{Raytracer setup}} (how to create a B\+VH) 

\mbox{\hyperlink{a00390_generate_graph}{Graph generation}} (how to generate a graph from a B\+VH) 

\mbox{\hyperlink{a00390_get_all_nodes}{Get nodes from graph}} (how to retrieve nodes from a graph) 

\mbox{\hyperlink{a00390_ga884a3374d971261a01ccfd3b21e288e5}{Destroy\+Path}} for information on deleting the path after usage. 

\mbox{\hyperlink{a00390_nodes_teardown}{Destroy nodes from graph}} (how to destroy nodes from a graph) 

\mbox{\hyperlink{a00390_graph_teardown}{Destroy graph}} (how to destroy a graph) 

\mbox{\hyperlink{a00391_raytracer_teardown}{Raytracer teardown}} (how to destroy a B\+VH) 

\mbox{\hyperlink{a00389_mesh_teardown}{Mesh teardown}} (how to destroy a mesh)
\end{DoxySeeAlso}
Now we are ready to invoke \mbox{\hyperlink{a00390_gaba6ec6ce84974dd6a311d7d65dd34221}{Create\+All\+To\+All\+Paths}} . 
\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 ~\newline
 
\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}


Definition at line 138 of file pathfinder\+\_\+\+C.\+cpp.



References H\+F\+::\+Pathfinding\+::\+Create\+Boost\+Graph(), H\+F\+::\+Exceptions\+::\+G\+E\+N\+E\+R\+I\+C\+\_\+\+E\+R\+R\+OR, H\+F\+::\+Pathfinding\+::\+Insert\+All\+To\+All\+Paths\+Into\+Array(), H\+F\+::\+Exceptions\+::\+N\+O\+\_\+\+C\+O\+ST, and H\+F\+::\+Exceptions\+::\+OK.



Referenced by C\+Interface\+Tests\+::\+T\+E\+S\+T().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00390_gaba6ec6ce84974dd6a311d7d65dd34221_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=349pt]{a00390_gaba6ec6ce84974dd6a311d7d65dd34221_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00390_ga3dc85450e989a996a3c3fcfad0a5944e}\label{a00390_ga3dc85450e989a996a3c3fcfad0a5944e}} 
\index{Pathfinding@{Pathfinding}!CreatePath@{CreatePath}}
\index{CreatePath@{CreatePath}!Pathfinding@{Pathfinding}}
\doxysubsubsection{\texorpdfstring{CreatePath()}{CreatePath()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} Create\+Path (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a01497}{H\+F\+::\+Spatial\+Structures\+::\+Graph}} $\ast$}]{g,  }\item[{int}]{start,  }\item[{int}]{end,  }\item[{const char $\ast$}]{cost\+\_\+type,  }\item[{int $\ast$}]{out\+\_\+size,  }\item[{\mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$}]{out\+\_\+path,  }\item[{\mbox{\hyperlink{a02025}{H\+F\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$}]{out\+\_\+data }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00359}{Cinterface/pathfinder\+\_\+\+C.\+h}}$>$}



Find the shortest path from start to end. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph to conduct the search on. \\
\hline
{\em start} & Start node of the path. \\
\hline
{\em end} & End node of the path.\\
\hline
{\em cost\+\_\+name} & The name of the cost in {\ttfamily g} to use for shortest path calculations. Set to an empty string to use the cost {\ttfamily g} was constructed with.\\
\hline
{\em out\+\_\+size} & Updated to the length of the found path on success. Set to 0 if no path could be found. \\
\hline
{\em out\+\_\+path} & Output parameter for a pointer to the generated path. Will be null if no path could be found \\
\hline
{\em out\+\_\+data} & Output parameter for a pointer to the data of the generated path. Will be null if no path could be found.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+OK} The function completed successfully. 

{\ttfamily H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+N\+O\+\_\+\+P\+A\+TH} No path could be found 

{\ttfamily H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+N\+O\+\_\+\+C\+O\+ST} {\ttfamily cost\+\_\+name} is not an empty string or the key of a cost that already exists in G
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
1) {\ttfamily start} and {\ttfamily end} contain both contain the Ids of nodes already in the graph 

2) If not set to the empty string, {\ttfamily cost\+\_\+name} is the key to a valid cost type already defined in {\ttfamily g}.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
If {\ttfamily OK} is returned, a path between start and end was found and {\ttfamily out\+\_\+size}, {\ttfamily out\+\_\+path}, and {\ttfamily out\+\_\+data}, are updated to contain the number of nodes in the path, a pointer to the path itself, and a pointer to the Path\+Members it holds respectively.
\end{DoxyPostcond}
\begin{DoxyWarning}{Warning}
The caller is responsible for deleting the path returned by out\+\_\+path by calling Destroy\+Path if this function completes successfully. Freeing the memory for a path will also free the memory for its path members, so do not attempt to access its members after deletion.
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00389_mesh_setup}{Mesh setup}} (how to load an .O\+BJ file/create a mesh) 

\mbox{\hyperlink{a00391_raytracer_setup}{Raytracer setup}} (how to create a B\+VH) 

\mbox{\hyperlink{a00390_generate_graph}{Graph generation}} (how to generate a graph from a B\+VH) 

\mbox{\hyperlink{a00390_get_all_nodes}{Get nodes from graph}} (how to retrieve nodes from a graph) 

\mbox{\hyperlink{a00390_ga884a3374d971261a01ccfd3b21e288e5}{Destroy\+Path}} for information on deleting the path after usage. 

\mbox{\hyperlink{a00390_nodes_teardown}{Destroy nodes from graph}} (how to destroy nodes from a graph) 

\mbox{\hyperlink{a00390_graph_teardown}{Destroy graph}} (how to destroy a graph) 

\mbox{\hyperlink{a00391_raytracer_teardown}{Raytracer teardown}} (how to destroy a B\+VH) 

\mbox{\hyperlink{a00389_mesh_teardown}{Mesh teardown}} (how to destroy a mesh)
\end{DoxySeeAlso}
Begin by reviewing the example at \mbox{\hyperlink{a00391_raytracer_setup}{Raytracer setup}} to load an .obj file (mesh), and create a B\+VH from the mesh.~\newline
 Then generate a graph (\mbox{\hyperlink{a00390_generate_graph}{Graph generation}}) from the B\+VH -- see \mbox{\hyperlink{a00390_get_all_nodes}{Get nodes from graph}} on how to retrieve nodes from the graph.~\newline


Now we are ready to create a path. We will find the path from the first node to the last indexed node. ~\newline
 
\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 From here, please review the examples on how to destroy a path (\mbox{\hyperlink{a00390_ga884a3374d971261a01ccfd3b21e288e5}{Destroy\+Path}}),~\newline
 as well as how to destroy a vector$<$\mbox{\hyperlink{a02017}{H\+F\+::\+Spatial\+Structures\+::\+Node}}$>$ (\mbox{\hyperlink{a00390_nodes_teardown}{Destroy nodes from graph}}),~\newline
 how to destroy a \mbox{\hyperlink{a01497}{H\+F\+::\+Spatial\+Structures\+::\+Graph}} (\mbox{\hyperlink{a00390_graph_teardown}{Destroy graph}}),~\newline
 how to destroy a \mbox{\hyperlink{a01357}{H\+F\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} (\mbox{\hyperlink{a00391_raytracer_teardown}{Raytracer teardown}}),~\newline
 and how to destroy a vector$<$\mbox{\hyperlink{a01297}{H\+F\+::\+Geometry\+::\+Mesh\+Info}}$>$ (\mbox{\hyperlink{a00389_mesh_teardown}{Mesh teardown}}).

{\ttfamily $>$$>$$>$ Load\+O\+BJ loaded mesh successfully into loaded\+\_\+obj at address 000001D\+F01\+E\+B9470, code\+: 1}~\newline
{\ttfamily $>$$>$$>$ Create\+Raytracer created Embree\+Ray\+Tracer successfully into bvh at address 000001D\+F01\+E\+B5100, code\+: 1}~\newline
{\ttfamily $>$$>$$>$ Generate graph ran successfully -\/ graph stored at address 000001D\+F0\+B\+C\+E\+D\+D\+A0, code\+: 1}~\newline
{\ttfamily $>$$>$$>$ Graph Generated with 886 nodes}~\newline
{\ttfamily $>$$>$$>$ Create\+Path stored path successfully -\/ path stored at address 000001D\+F01\+E\+B9590, code\+: 1}~\newline
{\ttfamily $>$$>$$>$ Total path cost\+: 77.\+6772}~\newline


Definition at line 23 of file pathfinder\+\_\+\+C.\+cpp.



References H\+F\+::\+Pathfinding\+::\+Create\+Boost\+Graph(), H\+F\+::\+Spatial\+Structures\+::\+Path\+::empty(), H\+F\+::\+Pathfinding\+::\+Find\+Path(), H\+F\+::\+Exceptions\+::\+G\+E\+N\+E\+R\+I\+C\+\_\+\+E\+R\+R\+OR, H\+F\+::\+Spatial\+Structures\+::\+Path\+::\+Get\+P\+M\+Pointer(), H\+F\+::\+Exceptions\+::\+N\+O\+\_\+\+C\+O\+ST, H\+F\+::\+Exceptions\+::\+N\+O\+\_\+\+P\+A\+TH, H\+F\+::\+Exceptions\+::\+OK, and H\+F\+::\+Spatial\+Structures\+::\+Path\+::size().



Referenced by C\+Interface\+Tests\+::\+T\+E\+S\+T().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00390_ga3dc85450e989a996a3c3fcfad0a5944e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=308pt]{a00390_ga3dc85450e989a996a3c3fcfad0a5944e_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00390_gae1ac2805c3b86883bb88269ed3868367}\label{a00390_gae1ac2805c3b86883bb88269ed3868367}} 
\index{Pathfinding@{Pathfinding}!CreatePaths@{CreatePaths}}
\index{CreatePaths@{CreatePaths}!Pathfinding@{Pathfinding}}
\doxysubsubsection{\texorpdfstring{CreatePaths()}{CreatePaths()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} Create\+Paths (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a01497}{H\+F\+::\+Spatial\+Structures\+::\+Graph}} $\ast$}]{g,  }\item[{const int $\ast$}]{start,  }\item[{const int $\ast$}]{end,  }\item[{const char $\ast$}]{cost\+\_\+type,  }\item[{\mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$}]{out\+\_\+path\+\_\+ptr\+\_\+holder,  }\item[{\mbox{\hyperlink{a02025}{H\+F\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$}]{out\+\_\+path\+\_\+member\+\_\+ptr\+\_\+holder,  }\item[{int $\ast$}]{out\+\_\+sizes,  }\item[{int}]{num\+\_\+paths }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00359}{Cinterface/pathfinder\+\_\+\+C.\+h}}$>$}



Find multiple shortest paths in paralllel. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph to conduct the search on\\
\hline
{\em start} & An array of ids for starting nodes. Length must match that of end and all the I\+DS must belong to nodes that already exist within the graph.\\
\hline
{\em end} & An array of ids for ending nodes. Length must match that of start and all the I\+DS must belong to nodes that already exist within the graph.\\
\hline
{\em cost\+\_\+name} & The name of the cost type to use for generating paths. Leaving as an empty string will use the default cost of {\ttfamily g}.\\
\hline
{\em out\+\_\+size} & An empty array of integers that will be updated to contain the length of every path in {\ttfamily path\+\_\+members}. Paths that could not be generated will be left with a length of zero.\\
\hline
{\em out\+\_\+path} & Location for the the path pointer array to be created. Paths that could not be generated will be left as null pointers.\\
\hline
{\em out\+\_\+data} & Location for the pathmember pointer array to be created. All path member pointers will point to the Path\+Members of the Path in paths at the same index. Paths that could not be generated will be left as null pointers.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+OK} if the function completes successfully 

{\ttfamily H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+N\+O\+\_\+\+C\+O\+ST} is {\ttfamily cost\+\_\+name} is not a valid cost type name
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
1) The length of {\ttfamily start\+\_\+ids}, {\ttfamily end\+\_\+ids}, and {\ttfamily out\+\_\+size} must be equal. 

2) If {\ttfamily cost\+\_\+type} is specified, {\ttfamily cost\+\_\+type} must be the the key of an already existing cost in {\ttfamily g}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
1) {\ttfamily out\+\_\+path\+\_\+members} will point to a vector of pointers to vectors of Path\+Members with an element for every path. paths that could not be generated will be set to null pointers. 

2) {\ttfamily out\+\_\+paths} will point to a vector of pointers to paths with an element for every path. Paths that could not be generated will be set to null pointers. 

3) {\ttfamily out\+\_\+sizes} will point to an array of integers containing the size of every path in {\ttfamily out\+\_\+paths}. Paths that could not be generated will have a size of 0.
\end{DoxyPostcond}
\begin{DoxyWarning}{Warning}
The caller is responsible for freeing all of the memory allocated in {\ttfamily out\+\_\+paths} and {\ttfamily out\+\_\+sizes}. The contents of {\ttfamily out\+\_\+path\+\_\+members} will automatically be deleted when the path they belong to is deleted. Do not try to manually delete {\ttfamily out\+\_\+path\+\_\+members} or the path that owns it will throw a null pointer exception when it is deleted.
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00389_mesh_setup}{Mesh setup}} (how to load an .O\+BJ file/create a mesh) 

\mbox{\hyperlink{a00391_raytracer_setup}{Raytracer setup}} (how to create a B\+VH) 

\mbox{\hyperlink{a00390_generate_graph}{Graph generation}} (how to generate a graph from a B\+VH) 

\mbox{\hyperlink{a00390_get_all_nodes}{Get nodes from graph}} (how to retrieve nodes from a graph) 

\mbox{\hyperlink{a00390_ga884a3374d971261a01ccfd3b21e288e5}{Destroy\+Path}} for information on deleting the path after usage. 

\mbox{\hyperlink{a00390_nodes_teardown}{Destroy nodes from graph}} (how to destroy nodes from a graph) 

\mbox{\hyperlink{a00390_graph_teardown}{Destroy graph}} (how to destroy a graph) 

\mbox{\hyperlink{a00391_raytracer_teardown}{Raytracer teardown}} (how to destroy a B\+VH) 

\mbox{\hyperlink{a00389_mesh_teardown}{Mesh teardown}} (how to destroy a mesh)
\end{DoxySeeAlso}
No cost type\+:~\newline



\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 With a cost type\+:~\newline



\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 {\ttfamily $>$$>$$>$ T\+O\+DO output}~\newline


Definition at line 70 of file pathfinder\+\_\+\+C.\+cpp.



References H\+F\+::\+Pathfinding\+::\+Create\+Boost\+Graph(), H\+F\+::\+Exceptions\+::\+G\+E\+N\+E\+R\+I\+C\+\_\+\+E\+R\+R\+OR, H\+F\+::\+Pathfinding\+::\+Insert\+Paths\+Into\+Array(), H\+F\+::\+Exceptions\+::\+N\+O\+\_\+\+C\+O\+ST, and H\+F\+::\+Exceptions\+::\+OK.



Referenced by C\+Interface\+Tests\+::\+T\+E\+S\+T().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00390_gae1ac2805c3b86883bb88269ed3868367_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=313pt]{a00390_gae1ac2805c3b86883bb88269ed3868367_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00390_ga884a3374d971261a01ccfd3b21e288e5}\label{a00390_ga884a3374d971261a01ccfd3b21e288e5}} 
\index{Pathfinding@{Pathfinding}!DestroyPath@{DestroyPath}}
\index{DestroyPath@{DestroyPath}!Pathfinding@{Pathfinding}}
\doxysubsubsection{\texorpdfstring{DestroyPath()}{DestroyPath()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} Destroy\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$}]{path\+\_\+to\+\_\+destroy }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00359}{Cinterface/pathfinder\+\_\+\+C.\+h}}$>$}



Delete a path. 


\begin{DoxyParams}{Parameters}
{\em path\+\_\+to\+\_\+destroy} & Pointer to the path to delete.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+OK on return.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00389_mesh_setup}{Mesh setup}} (how to load an .O\+BJ file/create a mesh) 

\mbox{\hyperlink{a00391_raytracer_setup}{Raytracer setup}} (how to create a B\+VH) 

\mbox{\hyperlink{a00390_generate_graph}{Graph generation}} (how to generate a graph from a B\+VH) 

\mbox{\hyperlink{a00390_get_all_nodes}{Get nodes from graph}} (how to retrieve nodes from a graph) 

\mbox{\hyperlink{a00390_ga884a3374d971261a01ccfd3b21e288e5}{Destroy\+Path}} for information on deleting the path after usage. 

\mbox{\hyperlink{a00390_nodes_teardown}{Destroy nodes from graph}} (how to destroy nodes from a graph) 

\mbox{\hyperlink{a00390_graph_teardown}{Destroy graph}} (how to destroy a graph) 

\mbox{\hyperlink{a00391_raytracer_teardown}{Raytracer teardown}} (how to destroy a B\+VH) 

\mbox{\hyperlink{a00389_mesh_teardown}{Mesh teardown}} (how to destroy a mesh)
\end{DoxySeeAlso}

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 {\ttfamily $>$$>$$>$ T\+O\+DO output}~\newline


Definition at line 133 of file pathfinder\+\_\+\+C.\+cpp.



References Delete\+Raw\+Ptr(), and H\+F\+::\+Exceptions\+::\+OK.



Referenced by C\+Interface\+Tests\+::\+T\+E\+S\+T().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=275pt]{a00390_ga884a3374d971261a01ccfd3b21e288e5_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=314pt]{a00390_ga884a3374d971261a01ccfd3b21e288e5_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00390_gaac725d282f4fecd3aba1b3273c26e7e1}\label{a00390_gaac725d282f4fecd3aba1b3273c26e7e1}} 
\index{Pathfinding@{Pathfinding}!GetPathInfo@{GetPathInfo}}
\index{GetPathInfo@{GetPathInfo}!Pathfinding@{Pathfinding}}
\doxysubsubsection{\texorpdfstring{GetPathInfo()}{GetPathInfo()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00377_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE}} Get\+Path\+Info (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a02029}{H\+F\+::\+Spatial\+Structures\+::\+Path}} $\ast$}]{p,  }\item[{\mbox{\hyperlink{a02025}{Path\+Member}} $\ast$$\ast$}]{out\+\_\+member\+\_\+ptr,  }\item[{int $\ast$}]{out\+\_\+size }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00359}{Cinterface/pathfinder\+\_\+\+C.\+h}}$>$}



Get the size of a path and a pointer to its path members. 


\begin{DoxyParams}{Parameters}
{\em p} & Pointer to the path to get information from. This can handle null values. \\
\hline
{\em out\+\_\+member\+\_\+ptr} & Pointer to the path to get information from. Should not be null. \\
\hline
{\em out\+\_\+size} & The number of path members in the path. (Path\+Member count within $\ast$p)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+OK on success, H\+F\+\_\+\+S\+T\+A\+T\+U\+S\+::\+N\+O\+\_\+\+P\+A\+TH if the path $\ast$p is invalid
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00389_mesh_setup}{Mesh setup}} (how to load an .O\+BJ file/create a mesh) 

\mbox{\hyperlink{a00391_raytracer_setup}{Raytracer setup}} (how to create a B\+VH) 

\mbox{\hyperlink{a00390_generate_graph}{Graph generation}} (how to generate a graph from a B\+VH) 

\mbox{\hyperlink{a00390_get_all_nodes}{Get nodes from graph}} (how to retrieve nodes from a graph) 

\mbox{\hyperlink{a00390_ga884a3374d971261a01ccfd3b21e288e5}{Destroy\+Path}} for information on deleting the path after usage. 

\mbox{\hyperlink{a00390_nodes_teardown}{Destroy nodes from graph}} (how to destroy nodes from a graph) 

\mbox{\hyperlink{a00390_graph_teardown}{Destroy graph}} (how to destroy a graph) 

\mbox{\hyperlink{a00391_raytracer_teardown}{Raytracer teardown}} (how to destroy a B\+VH) 

\mbox{\hyperlink{a00389_mesh_teardown}{Mesh teardown}} (how to destroy a mesh)
\end{DoxySeeAlso}

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 {\ttfamily $>$$>$$>$ T\+O\+DO output}~\newline
 Get the size of a path and a pointer to its path members.

Definition at line 115 of file pathfinder\+\_\+\+C.\+cpp.



References H\+F\+::\+Spatial\+Structures\+::\+Path\+::\+Get\+P\+M\+Pointer(), H\+F\+::\+Exceptions\+::\+N\+O\+\_\+\+P\+A\+TH, H\+F\+::\+Exceptions\+::\+OK, and H\+F\+::\+Spatial\+Structures\+::\+Path\+::size().



Referenced by C\+Interface\+Tests\+::\+T\+E\+S\+T().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{a00390_gaac725d282f4fecd3aba1b3273c26e7e1_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{a00390_gaac725d282f4fecd3aba1b3273c26e7e1_icgraph}
\end{center}
\end{figure}
